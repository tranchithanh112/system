<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<PAL1131 version="1.0">
  <PROJECT name="XP70">
    <METRIC>
      <COMPANY><![CDATA[PRAXIS]]></COMPANY>
      <MANAGER><![CDATA[RES]]></MANAGER>
      <VERSION><![CDATA[0.001]]></VERSION>
      <CREATED year="2010" month="5" day="5" hour="16" minutes="10" seconds="38" milisec="890" />
    </METRIC>
    <OPTIONS>
      <PV value="00000D94" />
      <II value="0000003D" />
      <PAL1131G used="0" />
      <LC year="2019" month="5" day="11" hour="7" minutes="48" seconds="42" milisec="844" />
      <LCF>
        <ABSOLUTE>D:\Software\System\PAL1131\VM\VM-Praxis-LCD.xml</ABSOLUTE>
        <APPVARS>$VMsDir\VM-Praxis-LCD.xml</APPVARS>
        <ENVVARS>D:\Software\System\PAL1131\VM\VM-Praxis-LCD.xml</ENVVARS>
      </LCF>
      <CREATOR>1.0</CREATOR>
      <LASTSAVEDWITH>1.1.3.13</LASTSAVEDWITH>
      <DCP>
        <ABSOLUTE>D:\SOFTWARE\SYSTEM\SETUP\XP\XP70\Pal1131_XP70.dcp</ABSOLUTE>
        <APPVARS>D:\SOFTWARE\SYSTEM\SETUP\XP\XP70\Pal1131_XP70.dcp</APPVARS>
        <ENVVARS>D:\SOFTWARE\SYSTEM\SETUP\XP\XP70\Pal1131_XP70.dcp</ENVVARS>
      </DCP>
      <XCP>
        <ABSOLUTE>D:\SOFTWARE\SYSTEM\SETUP\XP\XP70\Pal1131_XP70.xcp</ABSOLUTE>
        <APPVARS>D:\SOFTWARE\SYSTEM\SETUP\XP\XP70\Pal1131_XP70.xcp</APPVARS>
        <ENVVARS>D:\SOFTWARE\SYSTEM\SETUP\XP\XP70\Pal1131_XP70.xcp</ENVVARS>
      </XCP>
      <HCP>
        <ABSOLUTE>D:\SOFTWARE\SYSTEM\SETUP\XP\XP70\Pal1131_XP70.hcp</ABSOLUTE>
        <APPVARS>D:\SOFTWARE\SYSTEM\SETUP\XP\XP70\Pal1131_XP70.hcp</APPVARS>
        <ENVVARS>D:\SOFTWARE\SYSTEM\SETUP\XP\XP70\Pal1131_XP70.hcp</ENVVARS>
      </HCP>
      <CST>
        <ABSOLUTE>D:\SOFTWARE\SYSTEM\SETUP\XP\XP70\Pal1131_XP70.cst</ABSOLUTE>
        <APPVARS>D:\SOFTWARE\SYSTEM\SETUP\XP\XP70\Pal1131_XP70.cst</APPVARS>
        <ENVVARS>D:\SOFTWARE\SYSTEM\SETUP\XP\XP70\Pal1131_XP70.cst</ENVVARS>
      </CST>
      <HCPFlags enabled="0" />
      <OverrideDefaultPaths enabled="0" />
    </OPTIONS>
    <LIBRARY>
      <PKG name="IEC_61131" version="131072" filename="D:\Software\System\PAL1131\Libraries\IEC 61131-3.lcp">
        <CREATED year="2017" month="2" day="7" hour="16" minutes="21" seconds="4" milisec="911" />
        <APPVARS>$LibDir\IEC 61131-3.lcp</APPVARS>
        <ENVVARS>D:\Software\System\PAL1131\Libraries\IEC 61131-3.lcp</ENVVARS>
        <IMP name="CTD" type="FBLK" />
        <IMP name="CTU" type="FBLK" />
        <IMP name="CTUD" type="FBLK" />
        <IMP name="F_TRIG" type="FBLK" />
        <IMP name="R_TRIG" type="FBLK" />
        <IMP name="RS" type="FBLK" />
        <IMP name="SEMA" type="FBLK" />
        <IMP name="SR" type="FBLK" />
        <IMP name="TOF" type="FBLK" />
        <IMP name="TON" type="FBLK" />
        <IMP name="TP" type="FBLK" />
      </PKG>
    </LIBRARY>
    <POU>
      <ITEM lang="ST" type="PRG" name="GLOB_VAR" editor="PAL1131.ST"><![CDATA[PROGRAM GLOB_VAR

// ########################################################## 
// DECLARE GLOBAL VARIABLES => FIRST POU / NO CODE !          
// ########################################################## 


VAR_EXTERNAL (*$AUTO *)
END_VAR
 
VAR
END_VAR
 
 // NO CODE HERE IN THIS POU  !!!!!! 
 
 // APPLICATION REVISIONS ------------------------------------------------------------- 
 // ----------------------------------------------------------------------------------- 
 // USE FOLLOWING APPLICATION REVISION NUMBER TEMPLATE :                                
 // *****   YYXXXS.SSX   *******    
 // WHERE:  YYXXX       = PROJECT SPECIAL FOR PROJECT NPYY-XXX   
 //              S.SS   = STANDARD PMS APPLICATION NUMBER        
 //                  X  = SPECIAL                                
 
 P0112 := FINT#2.000 ;  // CURRENT APPLICATION VERSION => SEE MENU <1.1.2>  

 //**********************************
 // REVISION :    2.00               
 // DATE     :    2017, FEBRUARY-24     
 // AUTHOR   :    MH                 
 // ADDED    :    UP TO 15 CONTROLLERS     
 // UPDATED POU:  ALL  
 // TESTED WITH:  Release: 2017-01-15 (6.0.1.3) Update 1             

 //**********************************
 //**********************************
 // REVISION :    1.470               
 // DATE     :    2014, AUGUST-12     
 // AUTHOR   :    TvS                 
 // ADDED    :    VOLTAGE CONTROL     
 // ADDED    :    LOWLOAD STOP, IDLE RUN & ALS CONTROL VIA MIMIC  
 // ADDED    :    LOAD & KVAR SETPOINT NOW VISIBLE IN MIMIC  
 // UPDATED POU:  BUG IN TAC CONTROLER  
 // UPDATED POU:  BUG IN SHAFT/SHORE CONNECT  
 // UPDATED POU:  NO AUTO SYNC WITH SHORE/SHAFT  
 // UPDATED POU:  WRONGE CHANNEL IN MBS (NOW KW VIA 6X045)  
 // TESTED WITH:  Release: 2014-05-03 Update 04             

 //**********************************

 //**********************************
 // REVISION :    1.460              
 // DATE     :    2012, OCTOBER-22   
 // AUTHOR   :    RvdM               
 // ADDED    :    SIMULATOR UPGRADED TO 9 CONTROLLERS      
 //          :    MAX GENS ON BUS FUNCTION 
 // UPDATED POU: CONNECTING, AUT_STOP  
 // TESTED WITH:  Release: 2011-01-12 Update 21             

 //**********************************

 //**********************************
 // REVISION :    1.450              
 // DATE :        2012, OCTOBER-22   
 // AUTHOR :      TvS                
 // DESCRIPTION:  STANDARD PMS       
 // UPDATES:      ADDED REQUEST AFTER VISIT TERASAKI SHANGHAI, SEE CHANGES DOCUMENT WITH RELEASE 
 // TESTED WITH:  Release: 2011-01-12 Update 17.1             
 //*********************************************************  

 //**********************************
 // REVISION :    1.430              
 // DATE :        2012, JULY-26      
 // AUTHOR :      RvdM               
 // DESCRIPTION:  STANDARD PMS       
 // UPDATES:      1 ADDED: SEQUENCE CHANGE ON CB OPEN/CLOSE FOR 'LAST ON = FIRST OFF' FUNCTION
 //               2 DEBUG: SEQ_MASK FORCED TO FALSE IF FUNC IS NOT DG
 //               3 DEBUG: ENABLE BUS AND GEN ALARMS ALSO FOR SHORE
 // UPDATED POU:  1 STANDBY_SEQUENCE from line 209  
 //               2 STANDBY_SEQUENCE from line 315  
 //               3 IOB_CB_TRIP line 158             
 // UPDATED CH.:  ADDED 333 as P0163 TO ACTIVATE LAST ON = FIRST OFF  
 // TESTED WITH:  Release: 2011-01-12 Update 17             
 //*********************************************************  

 //**********************************
 // REVISION :    1.420              
 // DATE :        2012, JUNE-15      
 // AUTHOR :      RES                
 // DESCRIPTION:  STANDARD PMS       
 // UPDATES:      S/W CRASH IN SIMULATION MODE ONLY WHEN BT#A CONFIG ON BUS#1 ; LOAD SHARE CALCS CHANGED 
 // UPDATED POU:  INPUTS, GEN_CALCULATE, BUS_CALCULATE          
 // UPDATED CH.:  NONE  
 // TESTED WITH:  Release: 2011-01-12 Update 17             
 //*********************************************************  

 //**********************************
 // REVISION :    1.410              
 // DATE :        2012, MAY-11       
 // AUTHOR :      RES                
 // DESCRIPTION:  STANDARD PMS       
 // UPDATES:      DEBUG: NO CB OPEN FAILURE IN L0CAL; ABT AUTO MODE ADDED  
 // UPDATED POU:  CONNECTING, DISCONNECTING, CONTROLLERS, IOB_CB_TRIP, OPERATION_MODE, GEN_CALCULATE, BUS_CALCULATE            
 // UPDATED CH.:  NONE  
 // TESTED WITH:  Release: 2011-01-12 Update 17             
 //*********************************************************  
//**********************************
 // REVISION :    1.400              
 // DATE :        2012, APR-17       
 // AUTHOR :      RES                
 // DESCRIPTION:  STANDARD PMS       
 // UPDATES:      ADDED SHAFT+SHORE, UPDATED DISPLAY (EU, READY, SEQUENCE), ADDED INP FOR STOP BUZZER, SPLIT MMIMIC/MBS CAHNNELS  
 // UPDATED POU:  INPUTS, GENERAL, BUS_CALCULATE .....            
 // UPDATED CH.:  ADDED 094,095,096,466...476, DELETED 183  
 // TESTED WITH:  Release: 2011-01-12 Update 17             
 //*********************************************************  
//**********************************
 // REVISION :    1.320              
 // DATE :        2012, FEB-3       
 // AUTHOR :      RES                
 // DESCRIPTION:  STANDARD PMS       
 // UPDATES:      ABT A-FEEDBACK OF BREAKER, ABT EVALUATION GRID4+5, BLOCK BUZZER 
 // UPDATED POU:  INPUTS, BUS_CALCULATE, GENERAL             
 // UPDATED CH.:  1131 REF LIST, SIMULATOR                  
 // TESTED WITH:  Release: 2011-01-12 Update 13             
 //*********************************************************  

 //**********************************
 // REVISION :    1.310              
 // DATE :        2011, DEC-19       
 // AUTHOR :      RES                
 // DESCRIPTION:  STANDARD PMS       
 // UPDATES:      ADDED OPTIONAL *SYNC-CHECK BACKUP RELAY*  
 // UPDATED POU:  NONE                                       
 // UPDATED CH.:  178, 179, 180, 181                        
 // TESTED WITH:  Release: 2011-01-12 Update 13             
 //*********************************************************  
 //**********************************
 // REVISION :    1.300              
 // DATE :        2011, NOV-24       
 // AUTHOR :      RES                
 // DESCRIPTION:  STANDARD PMS       
 // UPDATES:      FOR RELEASE        
 // UPDATED POU:  MULTIPLE                   
 //**********************************  
 //**********************************
 // REVISION :    1.200 NOT RELEASED 
 // DATE :        2011, OCT-27       
 // AUTHOR :      RES                
 // DESCRIPTION:  STANDARD PMS       
 // UPDATES:      PREPARATIONS FOR STAND-ALONE PMS IO-BOARD 
 // UPDATED POU:  MULTIPLE                   
 //**********************************  
 //**********************************
 // REVISION :    1.100 NOT RELEASED 
 // DATE :        2011, OCT-07       
 // AUTHOR :      RES                
 // DESCRIPTION:  STANDARD PMS       
 // UPDATES:      ARRAYS, INPUT 18+35, STANDBY START/REQUEST, TRIP in LOCAL 
 // UPDATED POU:  MULTIPLE                   
 //**********************************  
 //**********************************
 // REVISION :    1.030              
 // DATE :        2011, MAR-02       
 // AUTHOR :      RES                
 // DESCRIPTION:  FIRST ISSUE STANDARD PMS         
 // UPDATE (1):   BUZZER TRIGGER CHANGED TO INPUT CHANNEL "PULSE ON NEXT ALARM" 
 // UPDATED POU:  GROUP_ALARMS + NEW PAL CHANNEL 201   
 // UPDATE (2):   CHANGED FUNCTION OF P0423 TO "COOLDOWN WITH PRE-ALARM" 
 // UPDATED POU:  STOP_AUTO + ENG_STOP   
 // UPDATE (3):   CONNECT CB AFTER SUBSTITUTE START + UPDATE OF REV 1.02 
 // UPDATED POU:  GEN_CONNECT   
 // UPDATE (4):   BUS ABN TRIP ONLY IF ABN ALARM COMES WHILE SONEONE ELSE SYNCING  
 // UPDATED POU:  GEN_PROTECTION   
 //**********************************  
 //**********************************
 // REVISION :    1.020              
 // DATE :        2011, FEB-24       
 // AUTHOR :      RES                
 // DESCRIPTION:  FIRST ISSUE STANDARD PMS         
 // UPDATED POU:  GEN_CONNECT        
 // UPDATES:      KEEP IN "SYNCHRONIZING" UNTIL DEAD/LIVE-BUS OR TIME-OUT 
 //               AND NOT ALLOW TO CHANGE THE CONNECT MODE AFTER INITIATED 
 //**********************************  
 //**********************************
 // REVISION :    1.010              
 // DATE :        2011, FEB-16       
 // AUTHOR :      RES                
 // DESCRIPTION:  FIRST ISSUE STANDARD PMS         
 // UPDATES:      PMS IO BOARD DEBUG/TEST MODES ADDED    
 //               SOME 'BLACK_OUT' CONDITIONS UPDATED TO 'DEAD_BUS'  
 //               PHASE_FAULT CONDITION UPDATED (W/DELAY 
 //********************************** 
 //**********************************
 // REVISION :    1.000               
 // DATE :        2010, NOV-25       
 // AUTHOR :      RES                
 // DESCRIPTION:  FIRST ISSUE STANDARD PMS         
 // UPDATES:      DG, EM, ABT FUNCTIONALITY         
 //********************************** 

 
 // BE AWARE OF HIDDEN FUNCTION TO KILL ALL BUZZERS FOR THE SAKE OF YOUR CO-WORKERS                         
 // ------------------------------------------------------------------------------------------------------- 
 // SIMULTANEOUS PUSH *STOP HORN* + *ALARM* FOR 2+ SECONDS ON ANY PANEL TO BLOCK/UNBLOCK ALL PANEL BUZZERS 
 // UNBLOCK ON SAME PANEL WHERE YOU BLOCKED OR POWER-DOWN/UP THIS PANEL TO UNBLOCK                          
 
 
 
 //************** GENERATOR / ENGINE STATUSSES ***************
 //   variables in CAPITALS are globals                       
 

 //  ----------------------------  
 //  READY2START **************** 
 //  ---------------------------- 
 //  STARTING consist off:             => OWN BUS: BUS_STARTING (AUTO)  
 //  -------                      
 // *  START_ENGINE =>  RUNNING   
 // *  ENERGIZING   =>  ENERGIZED 
 //  ---------------------------- 
 //  SYNCHRONIZING :                   => OWN BUS: BUS_CONNECTING (AUTO) 
 //  -------                      
 // *  incl. closing CB            
 //  ----------------------------  
 //  BREAKER ******************** 
 //  ----------------------------  
 // *  OFFLOADING     _______         => OWN BUS: BUS_OFFLOADING (AUTO)
 // *  incl. OPENING CB            
 //  ----------------------------  
 //  BREAKER (off) ************** 
 //  ----------------------------  
 //  COOLING_DOWN                  
 //  STOPPING                          => OWN BUS: BUS_STOPPING (AUTO)
 //  ----------------------------  
 //  READY2START **************** 
 //  ----------------------------  

 
VAR_GLOBAL RETAIN 

END_VAR


VAR_GLOBAL
    
  //**********************************************************
  //    CONFIG / OPTIONS                                      
  //**********************************************************  
  MAXXP:           INT := 15;     // MAX PROCESSORS => MANIPULATE FOR TESTING   

  CONF_HVYCONS:    BOOL := FALSE;     // ARE HEAVY CONSUMERS CONFIGURED?  
  CONF_AVR:        BOOL := FALSE;     // IS AVR (KVAR CONTROL) CONFIGURED? 
  CONF_PRELUB:     BOOL := FALSE;     // IS PRE-LUBRICATION CONFIGURED? 
  ANY_NONPREF:     BOOL := FALSE;     // IS NON-PREF CONFIGURED 
  CONF_NONPREF:    ARRAY[1..4] OF BOOL;     // WHICH NON-PREF GROUPS CONFIGURED?   
   
  //**********************************************************
  //    START / CONNECT / DISCONNECT / STOP                   
  //**********************************************************  

  STARTING:         BOOL := FALSE ;    // STATUS - STARTING                       
  ENERGIZING:       BOOL := FALSE;        // STARTING STATUS - ENERGIZING         


  SYNCHRONIZING:       BOOL := FALSE;     // STATUS - SYNCHRONIZING    

  OFFLOADING:          BOOL := FALSE ;    // STATUS - OFFLOADING                                    
  OPENING:             BOOL := FALSE ;       // OFFLOADING STATUS - OPENING (CB)     
  LOWLOAD_STOP:        BOOL := FALSE ;       // LOW LOAD STOPPING STATUS   

  STOPPING:            BOOL := FALSE ;    // STATUS STOPPING                         

  //**********************************************************
  //    GENERAL ARRAYS                                        
  //**********************************************************  
  
  XP_VALID:        ARRAY[1..15] OF BOOL ;   // DATA RECEIVED FROM THIS XP IS VALID 
  STB_CODE:        ARRAY[1..15] OF INT  ;   // ARRAY WITH STANDBY SEQUENCES 
  SEQ_MASK:        ARRAY[1..15] OF BOOL ;   // SHARED BETWEEN FUNCTIONS FOR MASKING UNRELEVANT XP 
  SEQUENCE:        ARRAY[1..15] OF INT  ;   // SHARED BETWEEN FUNCTIONS FOR (UNMASKED) SEQUENCE 

  
  //**********************************************************
  //    GENERAL                                               
  //**********************************************************  

  AUTO:            BOOL ;             // AUTO MODE   
  MANUAL:          BOOL ;             // MANUAL MODE     
  LOCAL:           BOOL ;             // LOCAL MODE    
  MANUAL_FLC:      BOOL ;             // MANUAL -> WITH AUTO FREQ+LOAD CONTROL ONLY (HARBOUR MODE) 
   
  GRID:            INT  ;             // GRID SETTING 
  ADDRESS:         INT  ;             // ADDRESS SETTING 
  FUNC:            INT ;              // FUNCTION 
  BUS:             INT ;              // BUS 
  BREAKER:         BOOL;              // CIRCUIT BREAKER 

  FLASH:           BOOL;              // LAMP FLASHER 
  FLASH_SLOW:      BOOL;              // LAMP FLASHER  
  FLASH_FAST:      BOOL;              // LAMP FLASHER        
  RESET:           BOOL := FALSE;     // RESET OPRATION FAILURES 
                             
  BUS_ABNORMAL:    BOOL := FALSE;     // OTHER GEN ABNORMAL ALARM => SUBSTITUTE BUT NO INCR/DECR   
  BUS_ALM:         BOOL := FALSE;     // GEN ALARM 

  BUSVOLT_PERC:    FINT ;             // BUS VOLTAGE IN PERCENTS 
  BUSFREQ_PERC:    FINT ;             // BUS FREQUENCY IN PERCENT 
   
  CRITICAL_ALARM:  BOOL := FALSE;     // CRITICAL ALARM => RESET BEFORE NEXT OPERATION 

  CMD_START:       BOOL := FALSE;     // ENGINE START COMMAND 
  CMD_OPEN:        BOOL := FALSE;     // CB OPEN COMMAND 

  SUBSTITUTE_TRIP: BOOL := FALSE;    //  TRIP OVER BLACKOUT WHEN ABNORMAL SUBSTITUTION  
     
  AUTO_STOP:       BOOL := FALSE;    
  STANDBY_REQUEST: BOOL := FALSE;
  STBY_START_FAIL: BOOL ;
             
  DEAD_BUS:        BOOL := TRUE;
  LIVE_BUS:        BOOL := FALSE;
  BO_PREVENT_OK:   BOOL := FALSE;     // BLACKOUT PREVENT CHECK OKAY 
  PHASE_FAULT:     BOOL := FALSE;     // GENERATOR/BUS MISSING/WRONG PHASE 

  VOLT_SETPOINT:   FINT ;
  LOAD_CONTROL:    BOOL := TRUE;                
  KVAR_CONTROL:    BOOL := TRUE;
  LOAD_SP:         FINT;
  KVAR_SP:         FINT;
   
  HARBOUR_MODE:    BOOL := FALSE;
  SHAFT_PREUNLOAD: BOOL := FALSE;     // FIRST STAGE OF SHAFT/SHORE UNLOAD 
  
  ABN_TRIP_REQ:    BOOL := FALSE;     // <ALM227> CB ABNORMAL TRIPPED WITH > 1x DG 
  //**********************************************************
  //    ABT                                                   
  //**********************************************************                

  ABT_DGX1:        INT ;   // NUMBER OF GENERATORS ON LEFT BUS 
  DEAD_BUS2:       BOOL ;  // RIGHT BUS DEAD -> LEFT BUS DEAD = DEAD_BUS 
  ABT_DGX2:        INT ;   // NUMBER OF GENERATORS ON RIGHT BUS 
  ABT_SERIES:      BOOL ;  // IS THERE ANOTHER ABT WITH SAME BUS NUMBER => IF YES, THIS IS IN SERIES WITHOUT 'BUS' BETWEEN 
  ABT_SERIES_CB:   BOOL ;  // CB CLOSED OF SERIES ABT 
  ABT_NOTSYNC1:    BOOL ;  // NOT POSSIBLE TO SYNC ABT LEFT BUS 
  ABT_NOTSYNC2:    BOOL ;  // NOT POSSIBLE TO SYNC ABT RIGHT BUS 
  ABT_CLOSE_WAIT:  BOOL ;  // ABT CAN NOT CLOSE NOW DUE TO SYNCING/OFFLOADING ON BUS(SES)  
   
  //**********************************************************
  //    HARDWARE (E.G.SAMES) / SIMULATION SIGNALS             
  //**********************************************************  

  SIM_ON_SAMES  : BOOL;
  SIM_ON_WIRING : BOOL;                                                 
  
  GEN_VOLT:       FINT := 0 ;                                                                                                        
  GEN_FREQ:       FINT := 0 ; 
  GEN_AMP:        FINT := 0 ; 
  GEN_KW:         FINT := 0 ; 
  GEN_KVA:        FINT := 0 ;     
  GEN_KVAR:       FINT := 0 ; 

  BUS_VOLT:       FINT := 0 ;                                                                                                        
  BUS_FREQ:       FINT := 0 ;  
    
  START_FAIL:     BOOL ;             // START FAIL FROM DIN OR SIM 
  READY:          BOOL ;             // READY TO START FROM DIN OR SIM 
  PMS_SEL:        BOOL ;             // PMS LOCAL/REMOTE FROM DIN OR SIM 
  D_REMOTE:       BOOL ;             // DIESEL LOCAL/REMOTE FROM DIN OR SIM 
  
  //**********************************************************
  //       TO/FROM  OWN BUS POWER / LOAD / CB                 
  //**********************************************************
  
  // TOTALS 
  BUS_DGX:              INT;  // NUMBER OF GEN CONNECTED TO BUS 
  BUS_KW_POWER:         FINT; // BUS KW CAPABILITY  
  BUS_DG_POWER:         FINT; // BUS D/G CAPABILITY  
  BUS_KW_LOAD:          FINT; // BUS ACTUAL KW LOAD  
  BUS_SC_TRIP:          INT;  // NUMBER OF SHORT-CIRCUIT TRIPS ON BUS 

  // LOAD SHARING 
  BUS_LS_KW_POWER:      FINT; // BUS KW CAPABILITY FOR LOAD SHARE   
  BUS_LS_KW_LOAD:       FINT; // BUS ACTUAL KW LOAD FOR LOAD SHARE
  BUS_LS_KVAR_POWER:    FINT; // BUS KVAR CAPABILITY FOR LOAD SHARE
  BUS_LS_KVAR_LOAD:     FINT; // BUS ACTUAL KVAR LOAD FOR LOAD SHARE         
  BUS_LS_LOAD_PERC:     FINT; // BUS PERCENT KW LOAD 
  BUS_LS_KVAR_PERC:     FINT; // BUS PERCENT KVAR LOAD 
   
  // BUS COMMANDS                                   
  BUS_TRIP:             BOOL; // BUS 'TRIP ALL' COMMAND 
  BUS_TRIP_AUTO:        BOOL; // BUS 'TRIP ALL AUTO' COMMAND  
  BUS_INH_LLSTOP:       BOOL; // BUS INHIBIT LOW LOAD STOP  
  BUS_STBY_REQ:         BOOL; // BUS STANDBY REQUEST 
  BUS_GRP_STBY_REQ:     BOOL; // BUS STANDBY REQUEST FROM TRIPPED NON-PREF   
  BUS_HVY_STBY_REQ:     BOOL; // BUS STANDBY REQUEST BY HEAVY CONSUMERS 
  BUS_HVY_INH_STOP:     BOOL; // BUS INHIBIT STOP BY CONSUMER REQUEST(S) 
  BUS_SYNC:             BOOL; // SYNC ALL DG ON THIS BUS 
  BUS_SYNC_FREQ:        FINT; // CONTROL THIS BUS TO THIS FREQUENCY [%]    
  BUS_SYNC_VOLT:        FINT; // CONTROL THIS BUS TO THIS VOLTAGE [%]  
       
  // BUS STATUSSES 
  BUS_STARTING:         BOOL; // AUTO+STARTING ON OWN BUS   -OTHER THEN ME 
  BUS_STOPPING:         BOOL; // AUTO+STOPPING ON OWN BUS   -OTHER THEN ME 
  BUS_SYNCHRONIZING:    BOOL; // AUTO+CONNECTING ON OWN BUS -OTHER THEN ME 
  BUS_OFFLOADING:       BOOL; // AUTO+OFFLOADING ON OWN BUS -OTHER THEN ME  
  BUS_ALL_MANUAL:       BOOL; // ALL CONTROLLERS ON BUS IN MANUAL 
  BUS_SHAFT_SHORE:      BOOL; // SHAFT OR SHORE CONNECTED TO  BUS  
  BUS_BLOCKS_SYNC:      BOOL; // SYNC NOT POSSIBLE 
  BUS_OFFLOAD:          BOOL; // OFFLOAD FOR THIS BUS 
  BUS_OFFLOADTRIP:      BOOL; // TRIP AFTER OFFLOAD FOR THIS BUS 

  //**********************************************************
  //       BUS OF HEAVY CONSUMERS => POWER / LOAD / CB        
  //**********************************************************
  CONSUMER_DGX:         INT;  // NUMBER OF GEN CONNECTED TO BUS 
  CONSUMER_POWER:       FINT; // BUS KW CAPABILITY  
  CONSUMER_LOAD:        FINT; // BUS ACTUAL KW LOAD  
  DI_REQHEAVY:          ARRAY[1..4] OF BOOL;    // <41-44> Consumer block Request 1-4  
  DI_REQHEAVY_RUN:      ARRAY[1..4] OF BOOL;    // <46-49> Consumer block Request 1-4       
  REQHEAVY_PLS:         ARRAY[1..4] OF BOOL;    // <46-49> Request type is pulse 1-4  
    
  //**********************************************************
  //    ADD BUSES POWER/LOAD   E.G. BUS3ADD[4] = BUS3 + BUS4  
  //**********************************************************
  BUS1ADD:      ARRAY[1..5] OF BOOL;
  BUS2ADD:      ARRAY[1..5] OF BOOL;                                                
  BUS3ADD:      ARRAY[1..5] OF BOOL;
  BUS4ADD:      ARRAY[1..5] OF BOOL;
  BUS5ADD:      ARRAY[1..5] OF BOOL;
  
  //**********************************************************
  //    OPTIONAL DIGITAL INPUTS                               
  //**********************************************************
  DI_SHUTDOWN:       BOOL;	// <1> Engine safety shutdown    // <3>
  DI_AVR_ALARM:      BOOL;  // <4>
  DI_PRE_ALM:        BOOL;	// <2> Engine pre-alarm 
  DI_LOAD_SHIFT:     BOOL;  // <3> Start first stby, then unload    
  DI_CLOSE_CB:       BOOL;	// <11> CB close request 
  DI_OPEN_CB:        BOOL;	// <12> CB open request 
  DI_CBTRIPPED:      BOOL;	// <13> CB tripped 
  DI_TRIP_CB:        BOOL;	// <14> CB trip command 
  DI_TRIP_MANCB:     BOOL;	// <15> CB trip manual cmnd 
  DI_BUS_TRIPCB:     BOOL;	// <16> CB trip all command 
  DI_BUS_TRIPAUTOCB: BOOL;	// <17> CB trip all auto cmnd 
  DI_CB_SC_TRIPPED:  BOOL;  // <18> CB tripped by short-circuit device 
  DI_BT_A:           BOOL;	// <21> Bus-Tie #A status (to lower) 
  DI_BT_B:           BOOL;	// <22> Bus-Tie #B status (to higher) 
  DI_PTI:            BOOL;	// <31> PTI operation 
  DI_HARBOUR:        BOOL;	// <32> Harbour mode 
  DI_INH_LOWLOADSTOP:BOOL;	// <33> Inhibit low load stop 
  DI_FORCE_PREF_TRIP:BOOL;  // <35> Force Pref Trips on this board 
  DI_FORCE_PREF_TRIP_START_STBY:BOOL;  // <36> Force Pref Trips on this board    
  DI_STOPBUZ        :BOOL;  // <91> Stop panel buzzer           
  
  //**********************************************************
  //  DIGITAL OUTPUTS                                         
  //**********************************************************
  GRPOUT:    ARRAY[0..13] OF BOOL;      // DOUT CODE + 100 
  FUNCOUT:   ARRAY[1..33] OF BOOL;      // DOUT CODE + 300 
  IND241:    BOOL;                      // <241> BUS HIGH VOLTAGE (ABNORMAL) 
  IND242:    BOOL;                      // <242> BUS LOW VOLTAGE (ABNORMAL) 
  IND243:    BOOL;                      // <243> BUS HIGH FREQUENCY (ABNORMAL) 
  IND244:    BOOL;                      // <244> BUS LOW FREQUENCY (ABNORMAL) 
  IND251:    BOOL;                      // <251> BUS HIGH VOLTAGE (ALARM) 
  IND252:    BOOL;                      // <252> BUS LOW VOLTAGE (ALARM) 
  IND253:    BOOL;                      // <253> BUS HIGH FREQUENCY (ALARM) 
  IND254:    BOOL;                      // <254> BUS LOW FREQUENCY (ALARM) 

  DO_INC_VOLT  : BOOL; // DOUT-21 
  DO_DEC_VOLT  : BOOL; // DOUT-22 

END_VAR
 
END_PROGRAM]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="PRG" name="CHECK_SETTINGS" editor="PAL1131.ST"><![CDATA[PROGRAM CHECK_SETTINGS
VAR_EXTERNAL (*$AUTO*)
END_VAR
 
VAR

  COUNT          : ARRAY[1..15] OF INT;
  OLD_LC         : ARRAY[1..15] OF INT;
  OLD_GRID       : ARRAY[1..15] OF INT;
  COMM_TO:         ARRAY[1..15] OF BOOL;   // COMMUNICATION TIME_OUT => TO BE REPLACED BY F/W FUNCTION 

  NEW_GRID       : INT;
  CHECKS_TIMEOUT : INT;
  CHECKS_NORMAL  : INT;
    
  XP             : INT;
  I              : INT := 1;
  
  SET_GRID       : SET_1OF5;
  SET_FUNC       : SET_1OF5; 
  GETIP          : HW_XP;
  
  XP_MAX         : INT := 15;  

END_VAR  
 
  // CHECK *ADDRESS* SETTINGS   => ALM_502   ############################################   
  GETIP();
  ADDRESS := GETIP.IP - 60 ;
  P0111   := ADDRESS;

  IF OR((ADDRESS < 1),(ADDRESS > XP_MAX)) THEN
    ADDRESS         := 1 ;    // OTHERWISE ARRAY-BOUND ERROR I.E. 'UNEXPLAINED' CRASH OF PMS 
  END_IF
  _ADDRESS[ADDRESS] := ADDRESS;
  ALM_503           :=  ADDRESS <> P0111 ;

  // CHECK/UPDATE *FUNCTION* SETTINGS ############################################ 

  // FUNC 1: DIESEL GENERATOR 
  // FUNC 2: EMERGENCY GENERATOR 
  // FUNC 3: SHAFT GENERATOR 
  // FUNC 4: SHORE SUPPLY 
  // FUNC 5: ABT 

  SET_FUNC(IO1    := P0131,              
           IO2    := P0132, 
           IO3    := P0133, 
           IO4    := P0134, 
           IO5    := P0135,
           NEW    := 0
          );
  _FUNC[ADDRESS] := SET_FUNC.SELECT;
  FUNC           := _FUNC[ADDRESS];

  IF (FUNC=2) AND HARBOUR_MODE THEN             // INTERFACING IO-BOARD 
    IOB_XP_FUNC := 6;                 
  ELSE
    IOB_XP_FUNC := FUNC; 
  END_IF


  // CHECK OWN CONTROLLER +++++++++++++++++++++++++++++++++++++++++++++++++++++++

  // CHECK/UPDATE *GRID* SETTINGS   ############################################ 
  // TYPE 1; SINGE BUSBAR  _____________ 

  // TYPE 2; DUAL BUSBAR   ______/______ 

  // TYPE 3; TRIPLE BUSBAR ___/____/____ 

  // TYPE 4; RING BUSBAR   ______/______ 
  //                       /_____/_____/ 

  // TYPE 5; RING BUSBAR   ____/____/___ 
  //                       /_____/_____/ 

  SET_GRID(IO1    := P0121, 
           IO2    := P0122, 
           IO3    := P0123, 
           IO4    := P0124, 
           IO5    := P0125, 
           NEW    := NEW_GRID
           );

  _GRID[ADDRESS] := SET_GRID.SELECT;
  GRID           := _GRID[ADDRESS] ;
         
  // CHECK GRID CHANGE ON OTHER XP 
  NEW_GRID := 0;
  FOR XP:=1 TO MAXXP DO
    IF XP_VALID[XP] THEN
      IF _GRID[XP]<> OLD_GRID[XP] THEN
        NEW_GRID := _GRID[XP];
        EXIT;
      END_IF
    END_IF
  END_FOR
      
  // CHECK/UPDATE *BUS* SETTINGS ####(limit bus array boundary) #############   
  IF OR((P0141 < 1),(P0141 > 5)) THEN
    BUS := 1;
  ELSE                                                              
    BUS := P0141;
  END_IF                      
  _BUS[ADDRESS] := BUS ;

  // LIVE-CHECK OUT ######################################################################
  _LIVE_CHECK[ADDRESS] := _LIVE_CHECK[ADDRESS] + 1;         // LIVE_CHECK COUNTER 
  IF _LIVE_CHECK[ADDRESS] > 9999 THEN;
    _LIVE_CHECK[ADDRESS] := 1;
  END_IF

  // CHECK WHICH CONTROLLERS ARE AVAILABLE/VALID ################################################
  FOR XP := 1 TO XP_MAX DO
    XP_VALID[XP] := AND((_ADDRESS[XP] = XP),NOT COMM_TO[XP]); 
  END_FOR

  // CHECK HIGHEST AVAILABLE/VALID CONTROLLER  ################################################
  XP := XP_MAX;
  REPEAT
    IF XP_VALID[XP] THEN EXIT END_IF
    XP := XP - 1;
  UNTIL XP = 3 END_REPEAT  // ALLOW MINIMAL 3 CONTROLLERS
  IF XP >= 3 THEN MAXXP := XP; ELSE MAXXP := XP_MAX; END_IF // BE VERY SURE MAXXP IS VALID
   
  // CHECK *SAME* & VALID GRID & ON OTHER CONTROLLERS ##########################################
  ALM_502 := FALSE;
  FOR XP := 1 TO MAXXP DO
    IF XP_VALID[XP] AND (_GRID[XP] <> _GRID[ADDRESS]) THEN
      ALM_502 := TRUE;                 // WRONG GRID SETTING 
      EXIT;
    END_IF
  END_FOR

  // REMEMBER OTHER GRIDS 
  FOR XP := 1 TO XP_MAX DO
    IF XP_VALID[XP] THEN
      OLD_GRID[XP] := _GRID[XP];
    END_IF
  END_FOR

  //########################################################################################
  // CHECK ONE CONTROLLERS EACH LOOP  ######################################################
  //########################################################################################

  // CHECK CONTROLLERS LIVE CHECKS 
  CHECKS_TIMEOUT := 5 ;       // NUMBER OF WRONG LC-CHECKS BEFORE TIME-OUT: T= X*LOOP TIME*MAX_XP 
  CHECKS_NORMAL  := 3 ;       // NUMBER OF CORRECT LC-CHECKS BEFORE RESET TIME-OUT 

  IF _ADDRESS[I] = I THEN    // POWERED-UP 
    IF _LIVE_CHECK[I] = OLD_LC[I] THEN                  // COMMUNICATION TIME-OUT 
      COUNT[I] :=  COUNT[I] + 1;
    ELSE                                                   // COMMUNICATION OKAY 
      COUNT[I] :=  COUNT[I] - 1;                         
    END_IF
    OLD_LC[I] := _LIVE_CHECK[I] ;

    IF AND((COUNT[I] >= CHECKS_TIMEOUT),NOT COMM_TO[I]) THEN                  // SET TIME-OUT 
      COMM_TO[I] := TRUE;
    ELSIF AND((COUNT[I] <= (CHECKS_TIMEOUT - CHECKS_NORMAL)),COMM_TO[I]) THEN   // RESET TIME-OUT 
      COMM_TO[I] := FALSE;
      COUNT[I]   := 0;
    END_IF 
    IF COUNT[I]<0 THEN 
      COUNT[I]   := 0; 
    ELSIF COUNT[I] > CHECKS_TIMEOUT THEN
      COUNT[I]   := CHECKS_TIMEOUT;
    END_IF  
  END_IF

  // NEXT 
  I := I + 1;  
  IF I > XP_MAX THEN I := 1; END_IF

  // END *** CHECK ONE CONTROLLERS EACH LOOP  #######################################

  //#################################################################################
  //  SETTINGS ON PANEL COPIED TO IO-BOARD                                           
  //#################################################################################
  IOB_NOM_VOLT        := P0142 ;      // NOMINAL SETTINGS FOR PROTECTIONS 
  IOB_NOM_AMP         := P0146 ;
  IOB_NOM_FREQ        := P0143 ;
  IOB_NOM_KW          := P0147 ;
  IOB_LEVEL_ENERGIZED := P0431;

END_PROGRAM]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="PRG" name="GENERAL" editor="PAL1131.ST"><![CDATA[PROGRAM GENERAL

VAR_EXTERNAL (*$AUTO*) 
END_VAR

 VAR
 
    FLASH1         : FLASHER;
    FLASH2         : FLASHER;
    PULSE_RESET    : TP;
    SILENCE_CMD    : BOOL;
    
    N              : INT;
    TRIG_BUZ       : R_TRIG ;
    HOLD_BUZ       : RS ;
    STOP_BUZ       : BOOL;
    BLOCK_BUZS     : TOGGLE ;
    DELAY_LT       : TON;

END_VAR

  // note SIMULATION MODES => DG NUMBER IS ADDRESS(-60)!!!! 
  // 0 = OFF   
  // 1 = HARD-WIRED SIMULATION   => SAMES SIMULATION  
  // 2 = "SOFT-WIRED" SIMULATION => SAMES SIMULATION + BUS SIGNALS  
  IF NOT IOB_SIM_ENABLE THEN    // POWER CONNECTED TO IO-BOARD => RESET SIMULATION MODE 
    SIM_MODE := 0;
  END_IF                          

  SIM_ON_WIRING := SIM_MODE =  2; 
  SIM_ON_SAMES  := SIM_MODE >= 1 ;

  IOB_SIM_MODE  := SIM_MODE;       // SIM MODE TO IO-BOARD 

// FLASHERS 
  FLASH1(START := TRUE, PULSE:= T#300 , CYCLE:= T#600);
  FLASH2(START := TRUE, PULSE:= T#2000, CYCLE:= T#2500);
  FLASH       := FLASH1.Q ;
  FLASH_SLOW  := FLASH2.Q ;
  FLASH_FAST  := NOT FLASH_FAST ;

  // RESET OPERATIONAL FAILURES 
  PULSE_RESET(IN:= OR(PB_ACKN, MM_ACKN, MM_ACKSTOP, MBS_ACKSTOP), PT:= T#1s);
  RESET     := PULSE_RESET.Q    ;
  IOB_RESET := RESET;            // TO I/O-BOARD 

  // LAMP TEST 
  DELAY_LT(IN:= PB_STH , PT:=T#3s );            // LAMP TEST MET 3+SEC STOP-HORN 
  LAMP_TEST := DELAY_LT.Q ;

  // STOP HORN + HIDDEN FUNCTION: BLOCK THE BUZZERS 
  SILENCE_CMD := OR(PB_STH, DI_STOPBUZ, MM_STOPHORN, MM_ACKSTOP, MBS_ACKSTOP);
  BLOCK_BUZS(IN:= AND (LAMP_TEST, PB_ALARM));
  _STOP_HORN[ADDRESS] := OR(BLOCK_BUZS.OUT, SILENCE_CMD);    // TO OTHER PANELS 

  // STOP HORN FROM OTHER PANELS 
  STOP_BUZ := FALSE;
  N:= 1;
  REPEAT                                   // FROM OTHER PANELS 
    STOP_BUZ := _STOP_HORN[N] ;
    N        := N + 1;
  UNTIL OR((N> MAXXP), STOP_BUZ) END_REPEAT

  // BUZZER 
  TRIG_BUZ(CLK:= NEXT_ALARM ) ;  
  HOLD_BUZ(S:= TRIG_BUZ.Q, R1:= OR(SILENCE_CMD, STOP_BUZ) );
  BUZZER := HOLD_BUZ.Q1 ;

END_PROGRAM]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="PRG" name="INPUTS" editor="PAL1131.ST"><![CDATA[PROGRAM INPUTS

// ##########################################################
// SELECTION OF INPUT OPTIONS/FUNCTIONS                      
// ########################################################## 

VAR_EXTERNAL (*$AUTO*) 
END_VAR
 
VAR
                                 
  //  FIXED INPUTS                                                       
  //*********************************************************************
  // DI_CBCLOSED			// DIN9 - CB CLOSED STATUS          
  // DI_DRUN				// DIN10 - ENGINE RUNNING           
  // DI_START_FL			// DIN11 - ENGINE START FAIL        
  // DI_READY				// DIN12 - READY TO START           
  // DI_PMS_SEL				// DIN13 - SWBD/PMS SELECT          
  // DI_REMOTE				// DIN14 - ENGINE REMOTE CTRL       
  
  DIN           : INT;      // INPUT NUMBER 
  BT            : INT;
  USE_BTA       : BOOL;
  USE_BTB       : BOOL;

  DECODE_SIM_DG : DECODE_INT;
  T_ALM205      : TON;
  DELAY_READY   : TOF;

END_VAR

  // CONFIGURABLE DIGITAL INPUTS ############################################### 

  // DIGITAL INPUTS => DEFAULT SETTINGS IF NOT CONFIGURED  
  DI_SHUTDOWN        := FALSE;
  DI_PRE_ALM         := FALSE;
  DI_CLOSE_CB        := FALSE;
  DI_OPEN_CB         := FALSE;
  DI_CBTRIPPED       := FALSE;
  DI_TRIP_CB         := FALSE;
  DI_TRIP_MANCB      := FALSE;
  DI_BUS_TRIPCB      := FALSE;
  DI_BUS_TRIPAUTOCB  := FALSE;
  DI_CB_SC_TRIPPED   := FALSE;
  DI_AVR_ALARM       := FALSE;  // <19>
  DI_BT_A            := TRUE;
  DI_BT_B            := TRUE;
  DI_PTI             := FALSE;
  DI_HARBOUR         := FALSE;
  DI_INH_LOWLOADSTOP := FALSE;
  DI_FORCE_PREF_TRIP := FALSE;
  DI_FORCE_PREF_TRIP_START_STBY := FALSE;
  DI_REQHEAVY[1]     := FALSE;
  DI_REQHEAVY[2]     := FALSE;
  DI_REQHEAVY[3]     := FALSE;
  DI_REQHEAVY[4]     := FALSE;
  DI_REQHEAVY_RUN[1] := FALSE;
  DI_REQHEAVY_RUN[2] := FALSE;
  DI_REQHEAVY_RUN[3] := FALSE;
  DI_REQHEAVY_RUN[4] := FALSE;
  REQHEAVY_PLS[1]    := FALSE;
  REQHEAVY_PLS[2]    := FALSE;
  REQHEAVY_PLS[3]    := FALSE;
  REQHEAVY_PLS[4]    := FALSE;
  DI_STOPBUZ         := FALSE;
  DI_LOAD_SHIFT      := FALSE;

  // FOR EACH INPUT CHECK WHICH VARIABLE TO PROCESS 
        
  FOR DIN:=1 TO 8 DO
     
    CASE P031X[DIN] OF
       1:  DI_SHUTDOWN        := OR(DI_SHUTDOWN        , OPT_DIN[DIN]);
       2:  DI_PRE_ALM         := OR(DI_PRE_ALM         , OPT_DIN[DIN]);
       3:  DI_LOAD_SHIFT      := OR(DI_LOAD_SHIFT      , OPT_DIN[DIN]);
       11: DI_CLOSE_CB        := OR(DI_CLOSE_CB        , OPT_DIN[DIN]);
       12: DI_OPEN_CB         := OR(DI_OPEN_CB         , OPT_DIN[DIN]);
       13: DI_CBTRIPPED       := OR(DI_CBTRIPPED       , OPT_DIN[DIN]);
       14: DI_TRIP_CB         := OR(DI_TRIP_CB         , OPT_DIN[DIN]);
       15: DI_TRIP_MANCB      := OR(DI_TRIP_MANCB      , OPT_DIN[DIN]);
       16: DI_BUS_TRIPCB      := OR(DI_BUS_TRIPCB      , OPT_DIN[DIN]);
       17: DI_BUS_TRIPAUTOCB  := OR(DI_BUS_TRIPAUTOCB  , OPT_DIN[DIN]);
       18: DI_CB_SC_TRIPPED   := OR(DI_CB_SC_TRIPPED   , OPT_DIN[DIN]);
       19: DI_AVR_ALARM       := OR(DI_AVR_ALARM       , OPT_DIN[DIN]);
       21: DI_BT_A            :=                         OPT_DIN[DIN] ; USE_BTA := TRUE; 
       22: DI_BT_B            :=                         OPT_DIN[DIN] ; USE_BTB := TRUE; 
       31: DI_PTI             := OR(DI_PTI             , OPT_DIN[DIN]);
       32: DI_HARBOUR         := OR(DI_HARBOUR         , OPT_DIN[DIN]);
       33: DI_INH_LOWLOADSTOP := OR(DI_INH_LOWLOADSTOP , OPT_DIN[DIN]);
       35: DI_FORCE_PREF_TRIP := OR(DI_FORCE_PREF_TRIP , OPT_DIN[DIN]); 
       36: DI_FORCE_PREF_TRIP_START_STBY := OR(DI_FORCE_PREF_TRIP_START_STBY , OPT_DIN[DIN]); 
       41: DI_REQHEAVY[1]     := OR(DI_REQHEAVY[1]     , OPT_DIN[DIN]);
       42: DI_REQHEAVY[2]     := OR(DI_REQHEAVY[2]     , OPT_DIN[DIN]);
       43: DI_REQHEAVY[3]     := OR(DI_REQHEAVY[3]     , OPT_DIN[DIN]);
       44: DI_REQHEAVY[4]     := OR(DI_REQHEAVY[4]     , OPT_DIN[DIN]);
       46: DI_REQHEAVY_RUN[1] := OR(DI_REQHEAVY_RUN[1] , OPT_DIN[DIN]); REQHEAVY_PLS[1] := TRUE;
       47: DI_REQHEAVY_RUN[2] := OR(DI_REQHEAVY_RUN[2] , OPT_DIN[DIN]); REQHEAVY_PLS[2] := TRUE;
       48: DI_REQHEAVY_RUN[3] := OR(DI_REQHEAVY_RUN[3] , OPT_DIN[DIN]); REQHEAVY_PLS[3] := TRUE;
       49: DI_REQHEAVY_RUN[4] := OR(DI_REQHEAVY_RUN[4] , OPT_DIN[DIN]); REQHEAVY_PLS[4] := TRUE;                   
       91: DI_STOPBUZ         := OR(DI_STOPBUZ         , OPT_DIN[DIN]);
    END_CASE

  END_FOR
   
    
  // FIXED DIGITAL INPUTS ############################################### 
  IOB_SIM_CB  := FALSE;

  IF SIM_ON_WIRING THEN                            //  WIRING SIMULATION 

    DECODE_SIM_DG(IN:= SIM_IN_CODE[ADDRESS]);

    BREAKER     :=   DECODE_SIM_DG.B1;
    RUNNING     :=   DECODE_SIM_DG.B2;  
    START_FAIL  :=   DECODE_SIM_DG.B3;
    READY       :=   DECODE_SIM_DG.B4;
    PMS_SEL     :=   DECODE_SIM_DG.B5;
    D_REMOTE    :=   DECODE_SIM_DG.B6;
    IOB_SIM_CB  :=   BREAKER;

    // WIRING SIMULATION FOR BT'S   

    IF USE_BTA THEN
      BT := BUS-1 ;
      IF BT=0 THEN
        IF GRID=5 THEN
          BT := 5 ; 
        ELSIF GRID=4 THEN
          BT := 6 ;
        END_IF 
      END_IF
      DI_BT_A := SIM_BT[BT];
    END_IF
  
    IF USE_BTB THEN
      BT := BUS ;
      IF (BT=4) AND (GRID=4) THEN
        BT := 6 ;
      END_IF 
      DI_BT_B := SIM_BT[BT];
    END_IF  
  
  ELSE                                              // HARDWIRED INPUTS 

    BREAKER    := DI_CBCLOSED;
    RUNNING    := DI_RUN ;                       // => "READY" FOR SHAFT/SHORE 
    START_FAIL := DI_START_FL;
  
    IF (P0441<>FINT#0) THEN                          // READY TO START OFF DELAY ((WHILE STARTING READY GOES OFF) 
      DELAY_READY(IN:= DI_READY, PT:= FINT_TO_SEC(P0441));
      READY  := DELAY_READY.Q;
    ELSE
      READY  := DI_READY;
    END_IF
  
    PMS_SEL  := DI_PMS_SEL;
    D_REMOTE := DI_REMOTE;

  END_IF //SIM_ON_WIRING

  _BREAKER[ADDRESS] := BREAKER;

  // DISTRIBUTE TO OTHER XP 
  _TRIP_ALLCB[ADDRESS]     := DI_BUS_TRIPCB   ;
  _TRIP_ALLAUTOCB[ADDRESS] := DI_BUS_TRIPAUTOCB ;

  IF (FUNC=5) THEN                               // ABT     
    _BT_A[ADDRESS] := TRUE ;
    _BT_B[ADDRESS] := BREAKER ;
  ELSE
    _BT_A[ADDRESS] := DI_BT_A;
    _BT_B[ADDRESS] := DI_BT_B;
  END_IF //(FUNC=5) 

  IF OR((FUNC=1),(FUNC=2)) THEN
    T_ALM205(IN := NOT OR(READY, RUNNING, STOPPING), PT:= T#3s);
    ALM_205 := T_ALM205.Q;
  ELSE
    ALM_205 := FALSE;
  END_IF

END_PROGRAM]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="PRG" name="IOB_MEASURE" editor="PAL1131.ST"><![CDATA[PROGRAM IOB_MEASURE
VAR_EXTERNAL (*$AUTO*) END_VAR
 
VAR

END_VAR
   

  // HARDWARE MEASURE INPUTS 
  IOB_OUT_CB       := DI_CBCLOSED;               // CIRCUIT BREAKER STATUS 

  IOB_OUT_GENVOLT  := IOB_SAMES_GEN_VOLT;                                                                                                     
  IOB_OUT_GENFREQ  := IOB_SAMES_GEN_FREQ;
  IOB_OUT_BUSVOLT  := IOB_SAMES_BUS_VOLT ;
  IOB_OUT_BUSFREQ  := IOB_SAMES_BUS_FREQ ;

  IF IOB_OUT_CB  THEN
    IOB_OUT_GENAMP  := IOB_SAMES_GEN_AMP;
    IOB_OUT_GENKW   := IOB_SAMES_GEN_KW;
    IOB_OUT_GENKVAR := IOB_SAMES_GEN_KVAR ;        // SIM ON PANEL 
    IOB_OUT_GENKVA  := IOB_SAMES_GEN_KVA ;         // SIM ON PANEL 
    IOB_OUT_COSPHI  := IOB_SAMES_GEN_COSPHI ;      // SIM ON PANEL 
  ELSE
    IOB_OUT_GENAMP  := FINT#0;
    IOB_OUT_GENKW   := FINT#0;
    IOB_OUT_GENKVAR := FINT#0 ;
    IOB_OUT_GENKVA  := FINT#0 ;
    IOB_OUT_COSPHI  := FINT#1 ;
  END_IF

  // SUBSTITUTE SAMES VALUES IN SIMULATION MODE 1 OR 2  
  // SUBSTITUTE MEASUREMENTS USED ON IO-BOARD           
  // OTHER SIMULATION VALUES ARE SUBSTITUTED ON PANEL  

  IOB_SIM_ENABLE := (IOB_SAMES_GEN_VOLT < FINT#5) AND (IOB_SAMES_BUS_VOLT < FINT#5) ;     // SAFE FOR SIMULATION MODE 

  IF IOB_SIM_ENABLE THEN
    IF (IOB_SIM_MODE >= 1) THEN        // SAMES SIMULATION MODE 
      IOB_OUT_GENVOLT  := IOB_SIM_GENVOLT;                                                                                                     
      IOB_OUT_GENFREQ  := IOB_SIM_GENFREQ;
      IOB_OUT_GENAMP   := IOB_SIM_GENAMP;
      IOB_OUT_GENKW    := IOB_SIM_GENKW;
      IOB_OUT_BUSVOLT  := IOB_SIM_BUSVOLT;
      IOB_OUT_BUSFREQ  := IOB_SIM_BUSFREQ;
      IF (IOB_SIM_MODE >= 2) THEN        // WIRING SIMULATION MODE 
        IOB_OUT_CB  :=  IOB_SIM_CB;
      END_IF
    END_IF
  END_IF


  // SETTINGS FOR IO-BOARD SYNC CHECK 

  //**********************************************************
  //                                                          
  // P0511	<5.1.1> SYNC CHECK DELTA VOLTAGE                
  // P0512	<5.1.2> SYNC CHECK DELTA FREQUENCY NEGATIVE     
  // P0513	<5.1.3> SYNC CHECK DELTA FREQUENCY POSITIVE     
  // P0514	<5.1.4> SYNC CHECK DELTA PHASE ANGLE NEGATIVE   
  // P0515	<5.1.5> SYNC CHECK DELTA PHASE ANGLE POSITIVE   
  //                                                          
  //**********************************************************

  IOBINT_SY_DELTA_VOLT		:= IOB_NOM_VOLT * IOB_P0511 / FINT#100  ;   // (SYNC) Delta voltage [xx.xxxV] 
  IOBINT_SY_DELTA_FREQ_NEG	:= IOB_NOM_FREQ * IOB_P0512 / FINT#100  ;	// (SYNC) Delta frequency negative  [xx.xxxHz]  
  IOBINT_SY_DELTA_FREQ_POS	:= IOB_NOM_FREQ * IOB_P0513 / FINT#100  ;	// (SYNC) Delta frequency positive  [xx.xxxHz]  

END_PROGRAM]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="PRG" name="GEN_CALCULATE" editor="PAL1131.ST"><![CDATA[PROGRAM GEN_CALCULATE
VAR_EXTERNAL (*$AUTO*) END_VAR

VAR

  T_BLACKOUT        : TON; 
  GEN_PHI           : FINT ;
  BO_RECOVER        : BOOL;

  BUSVOLT_ENERGIZED : BOOL;
  GENVOLT_ENERGIZED : BOOL;  

  DELAY231          : TON;              // OVERLOAD 
  LATCH231          : SR;
  BO_DLY_ALM        : TON;
   
END_VAR

//########################################################

//**********************************************************
// P0241	<2.4.1> OVER-LOAD LEVEL                           
// P0242	<2.4.2> OVER-LOAD DELAY                           
// P0711	<7.1.1> BLACKOUT RECOVERY DELAY                   
//                                                          
// ALM_231	<231> OVER-LOAD                                 
// ALM_291	<291> BLACKOUT                                  
//                                                          
//**********************************************************


  // ACTUAL/SIMULATED SAMES VALUES FROM IO-BOARD 
  BUS_VOLT := IOB_OUT_BUSVOLT;                                                                                                
  BUS_FREQ := IOB_OUT_BUSFREQ;
  GEN_VOLT := IOB_OUT_GENVOLT ;                                                                                                    
  GEN_FREQ := IOB_OUT_GENFREQ ;
  GEN_AMP  := IOB_OUT_GENAMP;
  GEN_KW   := IOB_OUT_GENKW ;

  // ACTUAL SAMES VALUES FROM IO-BOARD 
  GEN_KVAR := IOB_OUT_GENKVAR ;
  GEN_KVA  := IOB_OUT_GENKVA ;
  GEN_PHI  := IOB_OUT_COSPHI ;

  // SUBSTITUTE SAMES VALUES ON PANEL IN SIMULATION MODE 1 OR 2  
  IF SIM_ON_SAMES THEN

    GEN_KVAR := SIM_KVAR_DG[ADDRESS] ;
    GEN_KVA  := (GEN_VOLT * GEN_AMP * _SQRT(FINT#3))/ FINT#1000 ;
    GEN_PHI  := GEN_KW / GEN_KVA;

  END_IF

  // SIMULATION VALUES TO IO-BOARD => USED IN SIMULATION ON IO-BOARD 
  IOB_SIM_GENVOLT := SIM_VOLT_DG[ADDRESS];
  IOB_SIM_GENFREQ := SIM_FREQ_DG[ADDRESS];
  IOB_SIM_GENAMP  := SIM_AMP_DG[ADDRESS];
  IOB_SIM_GENKW   := SIM_KW_DG[ADDRESS];
  IOB_SIM_BUSVOLT := SIM_BUSVOLT_DG[ADDRESS];                                                                                                
  IOB_SIM_BUSFREQ := SIM_BUSFREQ_DG[ADDRESS];   

  // LCD DISPLAY VALUES => to be checked after stand-alone io-board implementation 
  // VALUES AFTER SIMULATION ON PANEL OR ON IO-BOARD 
  DISP_COSPHI  := GEN_PHI ;
  DISPLAY_KVA  := GEN_KVA ;
  DISPLAY_KVAR := GEN_KVAR ;

  // PERCENT CALCULATIONS 
  KW_PERC      := DIV0(GEN_KW   ,  P0147)*FINT#100.0;                   // GENERATOR 
  KVAR_PERC    := DIV0(GEN_KVAR , (P0144 * P0145))*FINT#100.0;
  VOLT_PERC    := DIV0(GEN_VOLT ,  P0142)* FINT#100 ;
  FREQ_PERC    := DIV0(GEN_FREQ ,  P0143)* FINT#100 ;
  AMP_PERC     := DIV0(GEN_AMP  ,  P0146)* FINT#100 ;
  BUSVOLT_PERC := DIV0(BUS_VOLT ,  P0142)* FINT#100 ;                   // BUS 
  BUSFREQ_PERC := DIV0(BUS_FREQ ,  P0143)* FINT#100 ;

  // PART OF LOAD SHARE 
  _SHARED[ADDRESS] := AND(
                          (FUNC<=4),
                          (AUTO OR MANUAL_FLC),
                           NOT UNBALANCED_MODE,
                           BREAKER
                         );

// CALCULATE POWER/LOAD FOR LOAD SHARING DISTRIBUTE TO OTHER XP    
  IF AND((FUNC<=3), NOT OFFLOADING, BREAKER) THEN 
    _KW_POWER[ADDRESS]   := P0147 ;
    _KVAR_POWER[ADDRESS] := P0144 * P0145;   
  ELSE          
    _KW_POWER[ADDRESS]   := FINT#0 ;
    _KVAR_POWER[ADDRESS] := FINT#0 ;
  END_IF
   
  _KW_LOAD[ADDRESS]   := GEN_KW;   
  _KVAR_LOAD[ADDRESS] := GEN_KVAR;

  // BUS STATUS    
  BUSVOLT_ENERGIZED :=  BUSVOLT_PERC > P0431 ;
  GENVOLT_ENERGIZED :=  VOLT_PERC > P0431 ;

  DEAD_BUS := AND(
                  (BUSVOLT_PERC < FINT#20),    // LOW BUS VOLTAGE 
                  (BUSFREQ_PERC < FINT#20)     // LOW BUS FREQUENCY
                 ); 

  LIVE_BUS := AND(
                  NOT LOCAL,
                  BUSVOLT_ENERGIZED,        // ENERGIZED LEVEL 
                  (BUSFREQ_PERC > P0431)
                 ); 

  // DEAD/LIVE BUS(SES) DEPENDING APPLICATION 
  IF (FUNC=5) THEN      // ABT 

    DEAD_BUS := DEAD_BUS AND (ABT_DGX1 = 0) ;     // NO CB CLOSED ON OWN (=LEFT) BUS 

    DEAD_BUS2 := AND(
                     (VOLT_PERC < FINT#20),    // LOW 'GEN'/BUS2 VOLTAGE 
                     (FREQ_PERC < FINT#20),    // LOW 'GEN'/BUS2 FREQUENCY 
                     (ABT_DGX2 = 0)            // NO CB CLOSED ON OWN+1 (=RIGHT) BUS 
                     );
                     
    BO_RECOVER :=  OR(
                      AND(DEAD_BUS,  NOT DEAD_BUS2),
                      AND(DEAD_BUS2, NOT DEAD_BUS)
                     );

    ALM_231	:= FALSE ;
    ALM_291 := FALSE ; 

  ELSE
  
    DEAD_BUS   := AND(DEAD_BUS, (BUS_DGX = 0)) ;     // NO CB CLOSED ON OWN OR CONNECTED BUS 
    BO_RECOVER := DEAD_BUS;

    // ALM_231 OVERLOAD 
    DELAY231(IN:= AND((KW_PERC>P0241),  BREAKER), PT:=FINT_TO_SEC(P0242));			  
    LATCH231(S1:= DELAY231.Q , R:= RESET) ;
    ALM_231	:= LATCH231.Q1  ;	

    // ALM_291 BLACKOUT 
    BO_DLY_ALM(IN:= BLACKOUT, PT:=T#2s);
    ALM_291 := BO_DLY_ALM.Q ;  

  END_IF
  
  T_BLACKOUT(IN:= BO_RECOVER , PT:= FINT_TO_SEC(P0711)) ;
  BLACKOUT    := T_BLACKOUT.Q ;   

  PHASE_FAULT := OR(IOB_ALM_271, IOB_ALM_272, IOB_ALM_274, IOB_ALM_275) ;

END_PROGRAM]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="PRG" name="BUS_TIES" editor="PAL1131.ST"><![CDATA[PROGRAM BUS_TIES
 VAR_EXTERNAL (*$AUTO*) END_VAR
 
VAR
   
   //**********************************************************
   //    ALL CONTROLLERS BUS-TIES => TO SINGLE BUS-TIE         
   //**********************************************************

   BT12          : BOOL := TRUE;  // BUS-TIE 1~2                                                                                                                                    
   BT23          : BOOL := TRUE;  // BUS-TIE 2~3   
   BT34          : BOOL := TRUE;  // BUS-TIE 3~4   
   BT45          : BOOL := TRUE;  // BUS-TIE 4~5   
   BT14          : BOOL := TRUE;  // BUS-TIE 1~4   
   BT15          : BOOL := TRUE;  // BUS-TIE 1~5 

   LAST_BT12     : BOOL := TRUE;  // BUS-TIE 1~2                                                                                                                                    
   LAST_BT23     : BOOL := TRUE;  // BUS-TIE 2~3   
   LAST_BT34     : BOOL := TRUE;  // BUS-TIE 3~4   
   LAST_BT45     : BOOL := TRUE;  // BUS-TIE 4~5   
   LAST_BT14     : BOOL := TRUE;  // BUS-TIE 1~4   
   LAST_BT15     : BOOL := TRUE;  // BUS-TIE 1~5 
   
   UPDATE_BUSADD :  BOOL;      // BUS TIES HAVE CHANGED 
   XP            :  INT;

   POWER_UP      : BOOL := TRUE;      

END_VAR

  //################################################################


  //************************************************
  //    EVALUATE BUS-TIES OF EACH CONTROLLER        
  //************************************************

  // RESET BT 
  BT12 := TRUE;                                                                                                                                 
  BT23 := TRUE;                                 
  BT34 := TRUE;                                 
  BT45 := TRUE;                                 
  BT14 := TRUE;                                  
  BT15 := TRUE;                                 

  // EVALUATE 
  FOR XP:=1 TO MAXXP DO

    IF XP_VALID[XP]  THEN         // VERIFY THAT XP IS VALID   

      CASE _BUS[XP] OF        // BUS NO OF CONTROLLER 0 
      1: BT12 := AND(BT12, _BT_B[XP]);
         CASE GRID OF
         5: BT15 := AND(BT15, _BT_A[XP]); 
         4: BT14 := AND(BT14, _BT_A[XP]); 
         END_CASE
      2: BT12 := AND(BT12, _BT_A[XP]);
         BT23 := AND(BT23, _BT_B[XP]);
      3: BT23 := AND(BT23, _BT_A[XP]);
         BT34 := AND(BT34, _BT_B[XP]);
      4: BT34 := AND(BT34, _BT_A[XP]);
         CASE GRID OF
         4: BT14 := AND(BT14, _BT_B[XP]);
         5: BT45 := AND(BT45, _BT_B[XP]); 
         END_CASE      
      5: BT45 := AND(BT45, _BT_A[XP]);
         BT15 := AND(BT15, _BT_B[XP]);
      END_CASE             

    END_IF
   
    IF (FUNC=5) THEN         // ABT    
   
      // ASSUME/FORCE OWN BT IS OPENED FOR SPECIFIC BUSSADD CALCULATIONS ON LEFT & RIGHT SIDE 
      CASE BUS OF
      1: BT12 := FALSE ;
      2: BT23 := FALSE ;
      3: BT34 := FALSE ;
      4: CASE GRID OF
         4: BT14 := FALSE ;
         5: BT45 := FALSE ;
         END_CASE     
      5: BT15 := FALSE ;
      END_CASE
   
    END_IF

  END_FOR



  //**********************************************
  //             EVALUATE TIED-BUSES              
  //**********************************************

  UPDATE_BUSADD := OR((BT12<>LAST_BT12), 
                      (BT23<>LAST_BT23),
                      (BT34<>LAST_BT34),
                      (BT45<>LAST_BT45),
                      (BT14<>LAST_BT14),
                      (BT15<>LAST_BT15)) ;             // BUS TIES CHANGED 
      
                 
  IF OR(UPDATE_BUSADD, POWER_UP) THEN
                 
   // counter clockwise 

    BUS1ADD[5] := AND(BT15, (GRID=5));
    BUS2ADD[5] := AND(BT12, BUS1ADD[5]);
    BUS3ADD[5] := AND(BT23, BUS2ADD[5]);
    BUS4ADD[5] := AND(BT34, BUS3ADD[5]);
    BUS5ADD[5] := TRUE;

    BUS5ADD[4] := AND(BT45, (GRID=5));
    BUS1ADD[4] := AND(BUS1ADD[5], BUS5ADD[4]) OR AND(BT14, (GRID=4));
    BUS2ADD[4] := AND(BT12, BUS1ADD[4]);
    BUS3ADD[4] := AND(BT23, BUS2ADD[4]);
    BUS4ADD[4] := TRUE;

    BUS4ADD[3] := AND(BT34, (GRID>=4));
    BUS5ADD[3] := AND(BUS5ADD[4], BUS4ADD[3]);
    BUS1ADD[3] := AND(BUS1ADD[4], BUS4ADD[3]);
    BUS2ADD[3] := AND(BUS1ADD[3], BT12);
    BUS3ADD[3] := TRUE; 

    BUS3ADD[2] := AND(BT23, (GRID>=3));
    BUS4ADD[2] := AND(BUS4ADD[3], BUS3ADD[2]);
    BUS5ADD[2] := AND(BUS5ADD[3], BUS3ADD[2]);
    BUS1ADD[2] := AND(BUS1ADD[3], BUS3ADD[2]);
    BUS2ADD[2] := TRUE;

    BUS2ADD[1] := AND(BT12, (GRID>=3));
    BUS3ADD[1] := AND(BUS3ADD[2], BUS2ADD[1]);
    BUS4ADD[1] := AND(BUS4ADD[2], BUS2ADD[1]);
    BUS5ADD[1] := AND(BUS5ADD[2], BUS2ADD[1]);
    BUS1ADD[1] := TRUE;

    // clockwise (OR ccw) 

    BUS1ADD[2] := OR(BUS1ADD[2], AND((GRID>=2), BT12));
    BUS1ADD[3] := OR(BUS1ADD[3], AND((GRID>=3), BT12, BT23));
    BUS1ADD[4] := OR(BUS1ADD[4], AND((GRID>=4), BT12, BT23, BT34));
    BUS1ADD[5] := OR(BUS1ADD[5], AND((GRID>=5), BT12, BT23, BT34, BT45));

    BUS2ADD[1] := BUS1ADD[2];
    BUS2ADD[3] := OR(BUS2ADD[3], AND((GRID>=3), BT23));
    BUS2ADD[4] := OR(BUS2ADD[4], AND((GRID>=4), BT23, BT34));
    BUS2ADD[5] := OR(BUS2ADD[5], AND((GRID>=5), BT23, BT34, BT45));

    BUS3ADD[1] := BUS1ADD[3];
    BUS3ADD[2] := BUS2ADD[3];
    BUS3ADD[4] := OR(BUS3ADD[4], AND((GRID>=4), BT34));
    BUS3ADD[5] := OR(BUS3ADD[5], AND((GRID>=5), BT34, BT45));

    BUS4ADD[1] := BUS1ADD[4];
    BUS4ADD[2] := BUS2ADD[4];
    BUS4ADD[3] := BUS3ADD[4];
    BUS4ADD[5] := OR(BUS4ADD[5], AND((GRID>=5), BT45));

    BUS5ADD[1] := BUS1ADD[5];
    BUS5ADD[2] := BUS2ADD[5];
    BUS5ADD[3] := BUS3ADD[5];
    BUS5ADD[4] := BUS4ADD[5];

    POWER_UP := FALSE;

  END_IF


  // REMEMBER BT STATUSSES 
  LAST_BT12 := BT12;
  LAST_BT23 := BT23;                                 
  LAST_BT34 := BT34;                                 
  LAST_BT45 := BT45;                                 
  LAST_BT14 := BT14;                                  
  LAST_BT15 := BT15;  
     

END_PROGRAM]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="PRG" name="BUS_CALCULATE" editor="PAL1131.ST"><![CDATA[PROGRAM BUS_CALCULATE

VAR_EXTERNAL (*$AUTO*)
END_VAR
       
VAR

   HVY_BUSINH    : BUS_DECODE ;
   DG_OFFLOAD    : BUS_DECODE ;

   RELEVANT_XP   : BOOL ;
   RELEVANT_XP2  : BOOL ;
   RELEVANT_DATA : BOOL ;   
   AUTOXP        : BOOL;
   XP            : INT;
   B             : INT;
   Y             : INT; 
   I             : INT; 
   B2            : INT;

   NOT_SYNC      : BOOL;
   WAIT          : BOOL;
   CB            : INT;
       
END_VAR

//#############################################################################################


  //**********************************************************************
  //    CALCULATE POWER/LOAD/... FOR/RELATING OWN BUS                     
  //**********************************************************************

  // INIT VARIABLES 
  BUS_DGX           := 0; 
  BUS_KW_POWER      := FINT#0.0;
  BUS_DG_POWER      := FINT#0.0;
  BUS_KW_LOAD       := FINT#0.0;
  BUS_LS_KW_POWER   := FINT#0.0;  
  BUS_LS_KW_LOAD    := FINT#0.0;
  BUS_LS_KVAR_POWER := FINT#0.0;
  BUS_LS_KVAR_LOAD  := FINT#0.0;
  BUS_TRIP          := FALSE ;
  BUS_TRIP_AUTO     := FALSE ;
  BUS_INH_LLSTOP    := FALSE ;
  BUS_STBY_REQ      := FALSE ;
  BUS_HVY_STBY_REQ  := FALSE ;
  BUS_GRP_STBY_REQ  := FALSE ;
  BUS_STARTING      := FALSE ;
  BUS_STOPPING      := FALSE ;
  BUS_SYNCHRONIZING := FALSE ;
  BUS_OFFLOADING    := FALSE ;
  BUS_HVY_INH_STOP  := FALSE ;
  ABT_DGX1          := 0; 
  ABT_DGX2          := 0; 
  ABT_SERIES        := FALSE ;
  ABT_NOTSYNC1      := FALSE ; 
  ABT_NOTSYNC2      := FALSE ;
  ABT_CLOSE_WAIT    := FALSE ; 
  BUS_SYNC          := FALSE ;
  BUS_SYNC_FREQ     := FINT#100 ;
  BUS_SC_TRIP       := 0;  
  BUS_ALL_MANUAL    := MANUAL;
  BUS_SHAFT_SHORE   := FALSE;
  BUS_BLOCKS_SYNC   := FALSE;
  BUS_OFFLOAD       := FALSE;
  BUS_OFFLOADTRIP   := FALSE;
  BUS_ABNORMAL      := FALSE;
   
  // BUS CALCULATIONS  
  FOR XP:=1 TO MAXXP DO
   
    IF XP_VALID[XP]  THEN  
   
      B := _BUS[XP];
      RELEVANT_XP := BUSADD(BUS, B);   // IS THIS MY BUS OR BT CONNECTED BUS ? 
      
      IF (FUNC=5) THEN                 // RELEVANT IF THIS IS ABT ###################################### 

        IF (_FUNC[XP]<>5) THEN        // NO DATA FROM ABT 

          NOT_SYNC :=  AND(
                           OR((_FUNC[XP]=3), (_FUNC[XP]=4), (_MODUS[XP]< 4)),   // SHAFT, SHORE, NO FREQUENCY CONTROL
                           _BREAKER[XP]                                         // + CONNECTED 
                           ) ; 
          CB       :=  BOOL_TO_INT(_BREAKER[XP] ) ;   
                                                
          IF MANUAL THEN
            WAIT := OR(_SYNCHRONIZING[XP], _OFFLOADING[XP])  ;                          // CAN NOT YET SYNC                 
          ELSE
            WAIT := OR(_SYNCHRONIZING[XP], _STARTING[XP]) ;                             // WAIT WITH BLACKOUT RECOVERY 
          END_IF        
             
          // LEFT BUS 
          IF RELEVANT_XP THEN                

            ABT_DGX1 := ABT_DGX1 + CB;        // # BREAKERS CLOSED  
               
            IF NOT ABT_CLOSE_WAIT THEN ABT_CLOSE_WAIT := WAIT; END_IF      // TRY LATER 
            IF NOT ABT_NOTSYNC1   THEN ABT_NOTSYNC1   := NOT_SYNC; END_IF  // NOT POSSIBLE TO SYNC 

          END_IF // RELEVANT_XP
            
          // RIGHT BUS 
          B2 :=  BUS + 1;
          IF B2>GRID THEN B2 := 1; END_IF
            
          RELEVANT_XP2 := BUSADD(B2, B);   
          IF RELEVANT_XP2 THEN                

            ABT_DGX2 := ABT_DGX2 + CB;        // # BREAKERS CLOSED  
               
            IF NOT ABT_CLOSE_WAIT THEN ABT_CLOSE_WAIT := WAIT;     END_IF    // TRY LATER
            IF NOT ABT_NOTSYNC2   THEN ABT_NOTSYNC2   := NOT_SYNC; END_IF    // NOT POSSIBLE TO SYNC
           
          END_IF

        END_IF // (_FUNC[XP]<>5)

        IF AND((B = BUS), (_FUNC[XP]=5), (XP <> ADDRESS)) THEN  // ABT ON SAME BUS = IN SERIES 
          ABT_SERIES    := TRUE ;
          ABT_SERIES_CB := _BREAKER[XP] ;
        END_IF
         
        // CONDITION ON EITHER SIDE OR OWN 
        IF OR(RELEVANT_XP, RELEVANT_XP2) THEN
          BUS_SC_TRIP := BUS_SC_TRIP  + BOOL_TO_INT(_ALM229[XP]);            // ANY SHORT-CIRCUIT TRIP 
        END_IF
         
        IF AND((_STBYREQ_HVY_BUSX[XP] > 0), NOT BUS_HVY_INH_STOP) THEN
          HVY_BUSINH(CODE:= _STBYREQ_HVY_BUSX[XP]);                                          // BUS/INH CODE OF STANDBY REQUEST 
          BUS_HVY_INH_STOP := OR(BUSADD(BUS, HVY_BUSINH.BUS), BUSADD(B2, HVY_BUSINH.BUS));   // EITHER CONNECTED SIDE ? 
        END_IF         
      
      ELSE                             // RELEVANT IF THIS IS NOT ABT ################################### 

        IF RELEVANT_XP THEN            // ADD THIS CONTROLLER'S VARIABLES TO BUS VARIABLES 

          RELEVANT_DATA := _FUNC[XP] <> 5 ;

          IF RELEVANT_DATA THEN           
            BUS_DGX        := BUS_DGX      + BOOL_TO_INT(_BREAKER[XP]);                     // SEE GLOBAL_VAR 
            BUS_KW_POWER   := BUS_KW_POWER + _KW_POWER[XP];
            BUS_KW_LOAD    := BUS_KW_LOAD  + _KW_LOAD[XP];
            BUS_SC_TRIP    := BUS_SC_TRIP  + BOOL_TO_INT(_ALM229[XP]);

            IF MANUAL                                 THEN BUS_ALL_MANUAL := AND(BUS_ALL_MANUAL, (_MODUS[XP]= 3)) ; END_IF
            IF OR((_FUNC[XP]=1), (_FUNC[XP]=2))       THEN BUS_DG_POWER   := BUS_DG_POWER + _KW_POWER[XP];          END_IF  // TOTAL D/G POWER 
            IF NOT BUS_STBY_REQ                       THEN BUS_STBY_REQ   := _STANDBY_REQUEST[XP];                  END_IF                 
            IF AND(NOT BUS_ABNORMAL, (XP <> ADDRESS)) THEN BUS_ABNORMAL   := _BUS_ABN[XP] AND _BREAKER[XP];         END_IF  // BUS ABNORMAL REQUEST ACTIVE GEN 
               
            AUTOXP := _MODUS[XP]= 4 ;
            IF AND(AUTOXP, (XP <> ADDRESS)) THEN
              IF NOT BUS_STARTING       THEN BUS_STARTING      := _STARTING[XP];        END_IF
              IF NOT BUS_STOPPING       THEN BUS_STOPPING      := _STOPPING[XP];        END_IF            
              IF NOT BUS_SYNCHRONIZING  THEN BUS_SYNCHRONIZING := _SYNCHRONIZING[XP];   END_IF   
              IF NOT BUS_OFFLOADING     THEN BUS_OFFLOADING    := _OFFLOADING[XP];      END_IF   
            END_IF
                            
            // ADD FOR LOAD SHARE 
            IF _SHARED[XP] THEN
              BUS_LS_KW_LOAD     := BUS_LS_KW_LOAD    + _KW_LOAD[XP];          // ACTUAL LOAD KW         
              BUS_LS_KVAR_LOAD   := BUS_LS_KVAR_LOAD  + _KVAR_LOAD[XP];        // ACTUAL LOAD KVAR       
              BUS_LS_KW_POWER    := BUS_LS_KW_POWER   + _KW_POWER[XP];         // AVAILABLE POWER KW     
              BUS_LS_KVAR_POWER  := BUS_LS_KVAR_POWER + _KVAR_POWER[XP];       // AVAILABLE POWER KVAR   
            END_IF
            IF NOT BUS_SHAFT_SHORE THEN BUS_SHAFT_SHORE := AND(OR((_FUNC[XP]=3), (_FUNC[XP]=4)),_BREAKER[XP]); END_IF 
                            
            IF NOT BUS_BLOCKS_SYNC THEN 
              BUS_BLOCKS_SYNC := AND(OR((_FUNC[XP]=3), (_FUNC[XP]=4), (_MODUS[XP]< 4)), _BREAKER[XP]) ; 
            END_IF

          END_IF


           // -SET- 
          IF NOT BUS_TRIP                 THEN BUS_TRIP       := _TRIP_ALLCB[XP];     END_IF
          IF (AUTO AND NOT BUS_TRIP_AUTO) THEN BUS_TRIP_AUTO  := _TRIP_ALLAUTOCB[XP]; END_IF
          IF NOT BUS_INH_LLSTOP           THEN BUS_INH_LLSTOP := _INH_AUTOSTOP[XP];   END_IF        

        END_IF   // RELEVANT_XP

        // BUS SYNCHRONIZE REQUEST 
        IF AND((_SYNC_BUSX[XP] > 0), NOT BUS_SYNC) THEN                  // BUS NUMBER OF BUS SYNC REQUEST 
          RELEVANT_DATA := BUSADD(BUS, _SYNC_BUSX[XP]); 
          IF RELEVANT_DATA THEN
            BUS_SYNC      := TRUE ;
            BUS_SYNC_FREQ := _SYNC_FREQ_SETP[XP] ; // FREQ SETP [%] 
          END_IF 
        END_IF            

        IF OR((FUNC=1), (FUNC=2)) THEN      // RELEVANT IF THIS IS DG, EM                
        
          // STANDBY REQUEST BY HEAVY CONSUMERS 
          IF (_STBYREQ_HVY_BUSX[XP] > 0) THEN
            HVY_BUSINH(CODE:= _STBYREQ_HVY_BUSX[XP]);                // BUS/INH CODE OF STANDBY REQUEST 
            RELEVANT_DATA := BUSADD(BUS, HVY_BUSINH.BUS);                 // IS THIS MY BUS OR BT CONNECTED BUS ? 
            IF RELEVANT_DATA THEN
              BUS_HVY_INH_STOP := TRUE ;
              IF NOT BUS_HVY_STBY_REQ THEN BUS_HVY_STBY_REQ := HVY_BUSINH.BIT ; END_IF
            END_IF   
          END_IF       
    
          // STANDBY REQUEST BY NON-PREF GROUPS 
          IF AND((_STBYREQ_TRP_BUSX[XP] > 0), NOT BUS_GRP_STBY_REQ) THEN    // BUS NUMBER OF STANDBY REQUEST 
            RELEVANT_DATA := BUSADD(BUS, _STBYREQ_TRP_BUSX[XP]);            // IS THIS MY BUS OR BT CONNECTED BUS ? 
            IF RELEVANT_DATA THEN BUS_GRP_STBY_REQ := TRUE; END_IF
          END_IF 
           
          // OFFLOAD FROM SHAFT/SHORE 
          IF (_OFFLOAD_BUSX[XP] > 0) THEN
            DG_OFFLOAD(CODE:= _OFFLOAD_BUSX[XP]);                // OFFLOAD/TRIP CODE 
            RELEVANT_DATA := BUSADD(BUS, DG_OFFLOAD.BUS);        // IS THIS MY BUS OR BT CONNECTED BUS ? 
            IF RELEVANT_DATA THEN
              BUS_OFFLOAD     := TRUE ;
              BUS_OFFLOADTRIP := DG_OFFLOAD.BIT ;
            END_IF   
          END_IF                   
                     
        END_IF // OR((FUNC=1), (FUNC=2))

      END_IF  // (FUNC=5)

    END_IF //XP_VALID[XP]

  END_FOR  // XP:=1 TO MAXXP

  // INDICATION ON CHANNEL ONLY 
  OWNBUS_POWERKW := BUS_KW_POWER ;
  OWNBUS_LOADKW  := BUS_KW_LOAD;        
  OWNBUS_AVAILKW := HSS(BUS_KW_POWER - BUS_KW_LOAD, FINT#0);      

END_PROGRAM

  ]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="PRG" name="BUS_ALARMS" editor="PAL1131.ST"><![CDATA[PROGRAM BUS_ALARMS
 VAR_EXTERNAL (*$AUTO*) END_VAR
 
 VAR
 
    DELAY241     : TON;
    DELAY242     : TON;
    DELAY243     : TON; 
    DELAY244     : TON; 
    DELAY251     : TON;
    DELAY252     : TON;
    DELAY253     : TON; 
    DELAY254     : TON; 
         
    LATCH241     : SR;
    LATCH242     : SR;
    LATCH243     : SR; 
    LATCH244     : SR; 
    LATCH251     : SR;
    LATCH252     : SR;
    LATCH253     : SR; 
    LATCH254     : SR;  

    LATCH228     : SR;
    LATCH229     : SR;  
    
    TRIP_EXT     : BOOL := FALSE;
    TRIP_EXT_ALM : BOOL := FALSE;
    TRIP_BUS_EXT : BOOL := FALSE;
    TRIP_AUTO    : BOOL := FALSE; 
    
    RESET_TIMER  : BOOL; 
    OLD_BREAKER  : BOOL;   
    
    TRIG_ALM227  : R_TRIG ;     
    
 END_VAR

  IF (FUNC=5) THEN              // RELEVANT IF THIS IS ABT ###############################################

    ALM_241	     := FALSE ;	 
    ALM_242	     := FALSE ;
    ALM_243	     := FALSE ;
    ALM_244	     := FALSE ;
    ALM_251	     := FALSE ;
    ALM_252	     := FALSE ;
    ALM_253	     := FALSE ;	
    ALM_254	     := FALSE ;
    TRIP_BUS_EXT := FALSE;
    TRIP_EXT_ALM := FALSE; 

  ELSE                         // RELEVANT IF THIS IS OTHER THEN ABT ###############################################

    // RESET TIMERS FOR DG ONLINE  
    RESET_TIMER := FALSE;
    IF AND(BREAKER, NOT OLD_BREAKER) THEN RESET_TIMER := TRUE; END_IF
    OLD_BREAKER := BREAKER;


    // BUS ABNORMAL ->  SUBSTITUTE OVER BLACK-OUT  
    DELAY241(IN := AND((P0211>FINT#0), (BUSVOLT_PERC>P0211), NOT BLACKOUT, NOT RESET_TIMER), PT := FINT_TO_SEC(P0212)); // <241> BUS HIGH VOLTAGE (ABNORMAL) 
    DELAY242(IN := AND((P0213>FINT#0), (BUSVOLT_PERC<P0213), NOT BLACKOUT, NOT RESET_TIMER), PT := FINT_TO_SEC(P0214)); // <242> BUS LOW VOLTAGE (ABNORMAL) 
    DELAY243(IN := AND((P0215>FINT#0), (BUSFREQ_PERC>P0215), NOT BLACKOUT, NOT RESET_TIMER), PT := FINT_TO_SEC(P0216)); // <243> BUS HIGH FREQUENCY (ABNORMAL) 
    DELAY244(IN := AND((P0217>FINT#0), (BUSFREQ_PERC<P0217), NOT BLACKOUT, NOT RESET_TIMER), PT := FINT_TO_SEC(P0218)); // <244> BUS LOW FREQUENCY (ABNORMAL) 
 
    IND241 := DELAY241.Q;     
    IND242 := DELAY242.Q;    
    IND243 := DELAY243.Q;
    IND244 := DELAY244.Q; 
    
    LATCH241(S1 := AND(DELAY241.Q, BREAKER) , R := RESET);
    LATCH242(S1 := AND(DELAY242.Q, BREAKER) , R := RESET);
    LATCH243(S1 := AND(DELAY243.Q, BREAKER) , R := RESET);
    LATCH244(S1 := AND(DELAY244.Q, BREAKER) , R := RESET);
    
    ALM_241	:= LATCH241.Q1;	
    ALM_242	:= LATCH242.Q1;
    ALM_243	:= LATCH243.Q1;
    ALM_244	:= LATCH244.Q1;
  
    // BUS ALARM -> STANDBY START 

    DELAY251(IN := AND((P0221>FINT#0), (BUSVOLT_PERC>P0221), NOT BLACKOUT, NOT RESET_TIMER),  PT := FINT_TO_SEC(P0222));	// <251> BUS HIGH VOLTAGE (ALARM) 
    DELAY252(IN := AND((P0223>FINT#0), (BUSVOLT_PERC<P0223), NOT BLACKOUT, NOT RESET_TIMER),  PT := FINT_TO_SEC(P0224));	// <252> BUS LOW VOLTAGE (ALARM) 
    DELAY253(IN := AND((P0225>FINT#0), (BUSFREQ_PERC>P0225), NOT BLACKOUT, NOT RESET_TIMER),  PT := FINT_TO_SEC(P0226));	// <253> BUS HIGH FREQUENCY (ALARM) 
    DELAY254(IN := AND((P0227>FINT#0), (BUSFREQ_PERC<P0227), NOT BLACKOUT, NOT RESET_TIMER),  PT := FINT_TO_SEC(P0228));	// <254> BUS LOW FREQUENCY (ALARM) 
    
    IND251:= DELAY251.Q;
    IND252:= DELAY252.Q;    
    IND253:= DELAY253.Q;
    IND254:= DELAY254.Q; 
    
    LATCH251(S1 := AND(DELAY251.Q, BREAKER), R := RESET);
    LATCH252(S1 := AND(DELAY252.Q, BREAKER), R := RESET);
    LATCH253(S1 := AND(DELAY253.Q, BREAKER), R := RESET);
    LATCH254(S1 := AND(DELAY254.Q, BREAKER), R := RESET);
    
    ALM_251	:= LATCH251.Q1;
    ALM_252	:= LATCH252.Q1;
    ALM_253	:= LATCH253.Q1;	
    ALM_254	:= LATCH254.Q1;
                          
    IF OR((FUNC=1), (FUNC=2)) THEN
   
      // TRIP COMMANDS FROM BUS 
      TRIP_BUS_EXT :=  OR(
                          BUS_TRIP,                             // BUS TRIP ALL 
                          _TRIP_ALLCB[ADDRESS],                 // OWN  INPUT (16)  
                          BUS_TRIP_AUTO,                        // BUS TRIP ALL AUTO  
                          AND(_TRIP_ALLAUTOCB[ADDRESS], AUTO)   // OWN INPUT (17)
                          );
      TRIP_EXT_ALM := AND(DI_TRIP_MANCB, MANUAL);               // INPUT TRIP MANUAL (15) 
    ELSE
      TRIP_BUS_EXT := FALSE;
      TRIP_EXT_ALM := FALSE;
    END_IF    

  END_IF
      

  _BUS_ABN[ADDRESS] := OR(ALM_241,  ALM_242, ALM_243, ALM_244);
  BUS_ALM           := OR(ALM_251,  ALM_252, ALM_253, ALM_254);

  // <ALM227> CB ABNORMAL TRIPPED 
  ABN_TRIP_REQ := FALSE; 
  TRIG_ALM227(CLK:= ALM_227);

  IF TRIG_ALM227.Q AND (BUS_DGX <> 0) THEN ABN_TRIP_REQ := TRUE; END_IF         // TRIP WITH TWO OR MORE DG'S ON BUS AND ACTIVATE PREF TRIP AND STBY START

  // <ALM228> CB TRIP EXT. COMMAND 
  TRIP_EXT_ALM :=  TRIP_EXT_ALM OR DI_TRIP_CB ;          // INPUT CB TRIP (14) 

  LATCH228(S1:= TRIP_BUS_EXT OR TRIP_EXT_ALM , R := RESET) ;
  ALM_228 := LATCH228.Q1;

  // <ALM229> CB TRIPPED BY EXTERNAL SHORT-CIRCUIT DEVICE  
  LATCH229(S1:= DI_CB_SC_TRIPPED , R := RESET) ;
  _ALM229[ADDRESS] := LATCH229.Q1;
 

  // TRIPS => OTHER THEN LOCALLY PROCESSED ON IO-BOARD AND NOT CAUSING TRIP ALARM 
  TRIP_EXT     := FALSE ;
  IF (FUNC=1) OR (FUNC=3) OR HARBOUR_MODE THEN      // DG, EM+HARBOUR, SHAFT 
    TRIP_EXT     := TRIP_EXT_ALM OR  TRIP_BUS_EXT ;
  ELSIF (FUNC=4) OR (FUNC=5) THEN     // SHORE, ABT 
    TRIP_EXT     := TRIP_EXT_ALM ;
  END_IF 

  // TRIP COMMAND TO IO-BOARD => ADDITIONAL TO INTERNAL PROTECTIONS 
  IOB_CMD_TRIP_CB := OR(TRIP_EXT, AND(OR(DI_CBTRIPPED, DI_CB_SC_TRIPPED), BREAKER)) ;

  // TRIPPED ANY CAUSE 
  CB_TRIPPED_ANY := OR(TRIP_EXT, DI_CBTRIPPED, DI_CB_SC_TRIPPED, IOB_CB_TRIPPED);  

END_PROGRAM]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="PRG" name="OPERATION_MODE" editor="PAL1131.ST"><![CDATA[PROGRAM OPERATION_MODE
 VAR_EXTERNAL (*$AUTO*) END_VAR
 
 VAR
 
   FORCE_MANUAL : BOOL := FALSE;       // FORCE IN MANUAL MODE 
   AUTO_PLS     : R_TRIG;
   MAN_PLS      : R_TRIG;
   MAN_SR       : SR;
   ALM_PLS      : R_TRIG;
   MENU_PLS     : R_TRIG;

 END_VAR
 
//########################################################################

  FORCE_MANUAL := OR(ALM_502, ALM_503);

  IF PMS_SEL THEN                                         // NOT LOCAL SELECT                                          

    IF NOT(AUTO OR MANUAL) THEN MANUAL := TRUE; END_IF    // DEFAULT 

    AUTO_PLS(CLK := OR(PB_AUTO, MBS_AUTO, MM_AUTO));      // PUSH BUTTONS 
    MAN_PLS(CLK  := OR(PB_MANUAL, MBS_MANUAL, MM_MANUAL));

    IF  OR(MAN_PLS.Q, FORCE_MANUAL) THEN MANUAL := TRUE;   // E.G. ABT
    ELSIF AUTO_PLS.Q THEN                MANUAL := FALSE;              
    END_IF

    IF OR((FUNC=1), (FUNC=2))  THEN           // DG, EM

      HARBOUR_MODE := AND((FUNC=2), DI_HARBOUR);
      IF NOT D_REMOTE OR HARBOUR_MODE THEN MANUAL := TRUE; END_IF

    ELSIF OR((FUNC=3), (FUNC=4)) THEN    // SHAFT, SHORE 

      MANUAL := FALSE;

    END_IF
   
    AUTO  := NOT MANUAL;   
    LOCAL := FALSE;     
                 
  ELSE
 
    LOCAL        := TRUE;
    AUTO         := FALSE;
    MANUAL       := FALSE;
    HARBOUR_MODE := FALSE;
   
  END_IF

  MANUAL_FLC := AND(MANUAL, HARBOUR_MODE);               // MANUAL + FREQ/LOAD CONTROL  

  // OUTPUT MODUS 
  IF NOT PMS_SEL  THEN    _MODUS[ADDRESS] := 0;          // SWBD  
  ELSE
    IF    MANUAL_FLC THEN _MODUS[ADDRESS] := 5;          // MANUAL+FREQ/LOAD CONTROL 
    ELSIF AUTO       THEN _MODUS[ADDRESS] := 4;          // AUTO 
    ELSIF MANUAL     THEN _MODUS[ADDRESS] := 3;          // MANUAL        
    ELSIF D_REMOTE   THEN _MODUS[ADDRESS] := 2;          // D/E REMOTE          
    ELSIF PMS_SEL    THEN _MODUS[ADDRESS] := 1;          // PMS   
    END_IF
  END_IF


  LMP_AUTO := AUTO;     // AUTO LAMP ON PMS PANEL
  IF FORCE_MANUAL THEN
    LMP_MANUAL := FLASH_FAST ;
  ELSE
    IF MANUAL_FLC THEN
      LMP_MANUAL := FLASH_SLOW ;  
    ELSE
      LMP_MANUAL := MANUAL ; 
    END_IF
  END_IF 

END_PROGRAM]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="PRG" name="STANDBY_SEQUENCE" editor="PAL1131.ST"><![CDATA[PROGRAM STANDBY_SEQUENCE
 VAR_EXTERNAL (*$AUTO*) END_VAR
 
 VAR

  XP              : INT ;
  INIT_SEQ        : BOOL := FALSE ;
  AUTOXP          : BOOL ;
  XP_PRIORITY     : SEQ_PRIORITY ;
  XP_1ST          : INT ;
  XP_2ND          : INT ;
  XP_CB_LST       : INT ;
  XP_NR_1         : INT ;
   
  ENA_SET_STARTSQ : BOOL:= FALSE;
  ENA_SET_STOPSQ  : BOOL:= FALSE;
   
  SQ_ENCODE       : SEQ_ENCODE;

  INIT_SEQ_CODEA  : WORD;
  INIT_SEQ_CODEB  : WORD;
  INIT_SEQ_CODEC  : WORD;
  INIT_SEQ_CODED  : WORD;
  OLD_SEQUENCEA   : ARRAY[1..15] OF WORD;    // OLD SEQUENCE CODES NUMBERS
  OLD_SEQUENCEB   : ARRAY[1..15] OF WORD;    // OLD SEQUENCE CODES NUMBERS
  OLD_SEQUENCEC   : ARRAY[1..15] OF WORD;    // OLD SEQUENCE CODES NUMBERS
  OLD_SEQUENCED   : ARRAY[1..15] OF WORD;    // OLD SEQUENCE CODES NUMBERS

  SEQ_RESET       : TON;
  DUPLICATE_RESET : BOOL;

  POWER_UP        : BOOL := TRUE;
  T_POWERUP       : TON ;
  T_INIT          : TIME ;
  ENABLE_STBY     : TON ;

  DLY_BREAKER     : TON;
  BREAKER_DLYD    : BOOL ;
  STB_READY_DLYD  : TON;

  DUMMY           : BOOL;
  OLD_AUTO        : BOOL;
      
  PB_1ST_UP       : R_TRIG;
  PB_2ND_UP       : R_TRIG;
                                                         
  OLD_BREAKER     : BOOL;
  DG_ONLINE       : INT;
  XP_A            : INT;
  TOTAL           : INT;

END_VAR

  IF (FUNC=1) THEN       // DG 

    DLY_BREAKER(IN:= BREAKER , PT:= T#2s );               // WAIT WITH UPDATE 1ST/2ND STANDBY   
    BREAKER_DLYD := DLY_BREAKER.Q;
    
    STB_READY_DLYD(IN:= _STB_READY[ADDRESS] , PT:= T#1s); // PREVENT TIMING ISSUES -E.G. WITH TRIP RECOVERY- WHEN READY -> ON 
    
    
    // USE VARIABLE POWER UP TIME FOR WHEN ALL XP ARE SWITCHED ON SIMULTANEOUS   
    T_INIT := FINT_TO_SEC( FINT#1.5 + (INT_TO_FINT(ADDRESS) * FINT#0.5));       // MIN 2 SEC => XP1 ; MAX 6 SEC => XP9)
    T_POWERUP(IN := POWER_UP, PT := T_INIT);
    
    
    // POWER UP TIME BEFORE ENABLE STANDBY READY => LONGER THEN MAX. INIT TIME 
    ENABLE_STBY(IN:= TRUE , PT:= T#8s) ;
    

    // RESET THE SEQUENCE TO INI STATE      
    SEQ_RESET(IN:= OR( AND(PB_1ST, PB_2ND), DUPLICATE_RESET) , PT:= T#3s) ;
    
    
    // POWER UP 
    
    IF POWER_UP OR (SEQ_RESET.Q) THEN
   
      DUPLICATE_RESET := FALSE;
    
      // EXECUTE ONCE WHEN POWER UP INIT DELAY EXPIRED
       
      IF (T_POWERUP.Q AND POWER_UP)  OR (SEQ_RESET.Q) THEN
    
        INIT_SEQ := FALSE;
        FOR XP := 1 TO  MAXXP DO
          IF XP_VALID[XP] THEN
            IF SEQ_VALID(_SEQ_CODEA[XP],_SEQ_CODEB[XP],_SEQ_CODEC[XP],_SEQ_CODED[XP]) THEN          // USE FIRST VALID CODE OF LOWEST PROCESSOR
              INIT_SEQ_CODEA := _SEQ_CODEA[XP] ;
              INIT_SEQ_CODEB := _SEQ_CODEB[XP] ;
              INIT_SEQ_CODEC := _SEQ_CODEC[XP] ;
              INIT_SEQ_CODED := _SEQ_CODED[XP] ;
              INIT_SEQ := TRUE;
              EXIT ;
            END_IF
          END_IF
        END_FOR
           
        IF NOT INIT_SEQ OR (SEQ_RESET.Q) THEN                            // USE DEFAULT SEQUENCE CODE 
          INIT_SEQ_CODEA := WORD#16#4321 ;
          INIT_SEQ_CODEB := WORD#16#8765 ;
          INIT_SEQ_CODEC := WORD#16#CBA9 ;
          INIT_SEQ_CODED := WORD#16#0FED ;
        END_IF

        DUMMY := SEQ_DECODE(INIT_SEQ_CODEA,INIT_SEQ_CODEB,INIT_SEQ_CODEC,INIT_SEQ_CODED,MAXXP);      // INIT SEQUENCE[XP] ARRAY        
    
      END_IF  // (T_POWERUP.Q AND POWER_UP)  OR (SEQ_RESET.Q) 
         
      IF T_POWERUP.Q THEN POWER_UP := FALSE; END_IF // RESET POWER UP
       
    ELSIF  ENABLE_STBY.Q THEN
              
      //############################################################################################################
      // NORMAL OPERATION AFTER POWERUP + INIT
      //############################################################################################################
      
      //  CHECK FOR DUPLICATE SEQUENCE NUMBERS ON OWN BUS  
      DUPLICATE_RESET := FALSE;
      FOR XP := 1 TO  MAXXP DO
        IF XP_VALID[XP]  THEN
          IF BUSADD(BUS, _BUS[XP]) THEN                                 // CONNECTED BUS
            IF AND(XP<>ADDRESS, (SEQUENCE[XP]=SEQUENCE[ADDRESS])) THEN  // DUPLICATE SEQUENCE NUMBER 
              DUPLICATE_RESET := TRUE;
              EXIT ;
            END_IF
          END_IF
        END_IF
      END_FOR


      // PUSHBUTTONS
      PB_1ST_UP(CLK := OR(PB_1ST, MBS_STB_1ST, MM_STB_1ST));
      PB_2ND_UP(CLK := OR(PB_2ND, MM_STB_2ND));    
        
      // READY FOR STANDBY / AUTO STOP  TO OTHER XP 
      _STB_READY[ADDRESS] := AND(                                 //  STANDBY READY
                                 OR(READY2START ,
                                    RUNNING     ,
                                    STARTING    ,
                                    SYNCHRONIZING,
                                    COOLING_DOWN,
                                    BREAKER),                   //  KEEP READY WHEN BREAKER CLOSED UPTO 'DELAYED' 
                                 P0161,
                                 NOT CRITICAL_ALARM, 
                                 NOT BREAKER_DLYD,
                                 NOT STOPPING,
                                 NOT CB_TRIPPED_ANY,
                                 AUTO);                           // DG IS READY FOR STBY   
                          
      ENA_SET_STARTSQ := OR(
                            AND( NOT BREAKER_DLYD, STB_READY_DLYD.Q, NOT OR(BUS_SYNCHRONIZING, SYNCHRONIZING, BUS_STARTING OR STARTING)),
                            BUS_ALL_MANUAL
                           );
                                             
      ENA_SET_STOPSQ :=  AND(AUTO,
                             BREAKER_DLYD,
                             NOT OR(BUS_STOPPING, STOPPING)
                         );
 
      //******************************************************************************
      // SET 1ST/2ND STANDBY                                                            
      //******************************************************************************           
      IF ENA_SET_STARTSQ THEN                       

        //  GET XP NO OF 1ST, 2ND => THAT ARE STANDBY-READY AND CONNECTED TO OWN BUS 
        FOR XP := 1 TO MAXXP DO                       // SEQ_MASK IS USED TO DETERMINE WHICH XP ARE EVALUTED FOR SEQUNCE NUMBER CHANGE
          IF AND(
                 XP_VALID[XP],                       // XP PRESENT
                 BUSADD(BUS, _BUS[XP]),              // CONNECTED BUS 
                 OR(_STB_READY[XP], BUS_ALL_MANUAL)  // STANDBY READY XP OR ALL IN MANUAL
                 )
          THEN                                  
            SEQ_MASK[XP] := TRUE ;                               
          ELSE   
            SEQ_MASK[XP] := FALSE;
          END_IF
        END_FOR

        XP_PRIORITY(MAX:=MAXXP);
        XP_1ST := XP_PRIORITY.XP_1ST;
        XP_2ND := XP_PRIORITY.XP_2ND;    
        
        // 1ST, 2ND STANDBY 
        STB_1ST   :=   XP_1ST = ADDRESS;
        STB_2ND   :=  (XP_2ND = ADDRESS) AND NOT(XP_2ND = XP_1ST);

            
        // CHANGE SEQUENCE ARRAY WITH PUSHBUTTONS 
        IF PB_1ST_UP.Q THEN
          DUMMY := SEQ_EXCHANGE(ADDRESS,XP_1ST,MAXXP);   // EXCHANGE OWN SEQ# WITH FIRST SEQ# 
        ELSIF PB_2ND_UP.Q THEN
          DUMMY := SEQ_EXCHANGE(ADDRESS,XP_2ND,MAXXP);   // EXCHANGE OWN SEQ# WITH SECOND SEQ#
        END_IF 

      END_IF  // ENA_SET_STARTSQ  
        
      //******************************************************************************
      // SET 1ST TO STOP                                                                
      //******************************************************************************               

      IF ENA_SET_STOPSQ THEN                             
                        
        //  GET XP NO OF LAST => THAT ARE CONNECTED TO OWN BUS      
        FOR XP:= 1 TO MAXXP DO                                           // SEQ_MASK DETERMINES WHICH XP ARE EVALUTED  
          IF XP_VALID[XP] THEN
            IF BUSADD(BUS, _BUS[XP]) THEN                                // CONNECTED BUS
              AUTOXP       := _MODUS[XP] = 4;
              SEQ_MASK[XP] := AND(AUTOXP, _BREAKER[XP]);                // CONNECTED + AUTO XP
            ELSE   
              SEQ_MASK[XP] := FALSE;
            END_IF
          ELSE
            SEQ_MASK[XP] := FALSE;  
          END_IF
        END_FOR    
            
            
        // 1ST TO STOP
        XP_PRIORITY(MAX:=MAXXP);
            
        IF P0164 THEN                                                    // TERASAKI REQUEST OPTION: FIRST START IS FIRST TO STOP
          XP_CB_LST := XP_PRIORITY.XP_1ST; 
        ELSE
          XP_CB_LST := XP_PRIORITY.XP_LST; 
        END_IF
        
        STOP_1ST  :=  (XP_CB_LST = ADDRESS);


        // CHANGE SEQUENCE ARRAY WITH PUSHBUTTONS => CHANGE TO FIRST TO STOP
        IF PB_1ST_UP.Q THEN
          DUMMY := SEQ_EXCHANGE(ADDRESS,XP_CB_LST,MAXXP);                // EXCHANGE OWN SEQ# WITH LAST CONNECTED SEQ#
        END_IF
      END_IF 

      //******************************************************************************
      // LAST DG ON IS FIRST DG OFF                                                    
      //******************************************************************************               
      IF P0163 THEN  // P0163 PARAMETER TO ENABLE THIS FUNCTION
        
        IF BREAKER <> OLD_BREAKER THEN
          DG_ONLINE := 0;
          TOTAL     := 0;
          
          FOR XP:= 1 TO MAXXP DO                                              // SEQ_MASK DETERMINES WHICH XP ARE EVALUTED
            IF XP_VALID[XP] AND (_FUNC[XP]=1) AND BUSADD(BUS, _BUS[XP]) THEN  // CONNECTED BUS
              TOTAL := TOTAL + 1;
              IF  XP<>ADDRESS AND _BREAKER[XP] THEN DG_ONLINE := DG_ONLINE + 1; END_IF
            END_IF
          END_FOR
             
          FOR XP:= 1 TO MAXXP DO                                                 
            IF AND(XP_VALID[XP], (_FUNC[XP]=1), BUSADD(BUS, _BUS[XP])) THEN            // CHECK FOR ALL DGS LOWER SEQUENCE NUMBER        
              IF  AND(XP<>ADDRESS, (SEQUENCE[XP]<SEQUENCE[ADDRESS]), BREAKER) THEN     // DG ONLINE   
			    IF NOT _BREAKER[XP] THEN
                  XP_A         := SEQUENCE[XP] + 1;                                    // INCREASE SEQUENCE NUMBER OF STANDBY GENERATORS
                  SEQUENCE[XP] := XP_A;
                END_IF
              END_IF                                                                    // CHECK FOR ALL DGS HIGHER SEQUENCE NUMBER 
              IF  AND(XP<>ADDRESS, (SEQUENCE[XP]>SEQUENCE[ADDRESS]), NOT BREAKER) THEN  // DG OFFLINE   
			    XP_A := SEQUENCE[XP] - 1;                                               // DECREASE SEQUENCE NUMBER OF STANDBY GENERATORS 
                SEQUENCE[XP] := XP_A;                                            
			  END_IF
            END_IF
          END_FOR       

          IF NOT BREAKER THEN SEQUENCE[ADDRESS] := TOTAL;         END_IF  // DG OFFLINE  -> GENERATORS GET HIGHER SEQUENCE NUMBER
          IF BREAKER     THEN SEQUENCE[ADDRESS] := 1 + DG_ONLINE; END_IF  // DG ONLINE -> GENERATORS GET HIGHER SEQUENCE NUMBER OF ONLINE GENS
                  
        END_IF    // BREAKER <> OLD_BREAKER
          
      END_IF     // P0163
      OLD_BREAKER := BREAKER;         

      //******************************************************************************
      // SEE IF ANY XP CHANGED THE SEQUENCE CODE => THEN PUT THAT IN SEQUENCE ARRAY     
      //******************************************************************************        
      FOR XP :=1 TO MAXXP DO
        IF XP <> ADDRESS THEN                             
          IF OR(
                AND((_SEQ_CODEA[XP] <> OLD_SEQUENCEA[XP]), (OLD_SEQUENCEA[XP] <> WORD#0)),
                AND((_SEQ_CODEB[XP] <> OLD_SEQUENCEB[XP]), (OLD_SEQUENCEB[XP] <> WORD#0)),
                AND((_SEQ_CODEC[XP] <> OLD_SEQUENCEC[XP]), (OLD_SEQUENCEC[XP] <> WORD#0)),
                AND((_SEQ_CODED[XP] <> OLD_SEQUENCED[XP]), (OLD_SEQUENCED[XP] <> WORD#0))
               )
          THEN  
            DUMMY := SEQ_DECODE(_SEQ_CODEA[XP],_SEQ_CODEB[XP],_SEQ_CODEC[XP],_SEQ_CODED[XP],MAXXP); // PUT CHANGED CODE IN SEQUENCE[XP] ARRAY  
            EXIT ;
          END_IF                                                                       
        END_IF
      END_FOR 
    
      SQ_ENCODE(MAX:=MAXXP);
      _SEQ_CODEA[ADDRESS] := SQ_ENCODE.CODE_A;                              // PUT SEQUENCE[XP] ARRAY IN CODE OUTPUT CHANNEL  
      _SEQ_CODEB[ADDRESS] := SQ_ENCODE.CODE_B;                              // PUT SEQUENCE[XP] ARRAY IN CODE OUTPUT CHANNEL  
      _SEQ_CODEC[ADDRESS] := SQ_ENCODE.CODE_C;                              // PUT SEQUENCE[XP] ARRAY IN CODE OUTPUT CHANNEL  
      _SEQ_CODED[ADDRESS] := SQ_ENCODE.CODE_D;                              // PUT SEQUENCE[XP] ARRAY IN CODE OUTPUT CHANNEL  

      // REPAIR SEQUENCY CODE ASYNCHRONITY WITH AUTO -> MANUAL  
      IF AND(NOT(AUTO), OLD_AUTO) THEN
        FOR XP := 1 TO  MAXXP DO
          IF XP_VALID[XP]  THEN
            IF SEQ_VALID(_SEQ_CODEA[XP],_SEQ_CODEB[XP],_SEQ_CODEC[XP],_SEQ_CODED[XP]) THEN            // USE FIRST VALID CODE OF LOWEST PROCESSOR 
              DUMMY := SEQ_DECODE(_SEQ_CODEA[XP],_SEQ_CODEB[XP],_SEQ_CODEC[XP],_SEQ_CODED[XP],MAXXP); // REPAIR ARRAY 
              EXIT ;
            END_IF
          END_IF
        END_FOR
      END_IF
        
      //******************************************************************************
      //  BLOCK 1ST/2ND STATUS                                                    
      //******************************************************************************            
      IF OR(BREAKER_DLYD, NOT AND(STB_READY_DLYD.Q, AUTO)) THEN
        STB_1ST   := FALSE;
        STB_2ND   := FALSE;   
      END_IF
            
      IF NOT AND(BREAKER_DLYD, AUTO) THEN
        STOP_1ST  :=  FALSE;
      END_IF        
           
    END_IF    // END DELAYED ENABLE AFTER POWER UP
    
    // STORE SEQUENCE NUMBERS FOR COMPARE CHANGES  
    FOR XP := 1 TO MAXXP DO
      IF XP_VALID[XP]  THEN 
        OLD_SEQUENCEA[XP] :=  _SEQ_CODEA[XP];
        OLD_SEQUENCEB[XP] :=  _SEQ_CODEB[XP];
        OLD_SEQUENCEC[XP] :=  _SEQ_CODEC[XP];
        OLD_SEQUENCED[XP] :=  _SEQ_CODED[XP];
      ELSE
        OLD_SEQUENCEA[XP] :=  WORD#0;          // MARK AS INVALID
        OLD_SEQUENCEB[XP] :=  WORD#0;          // MARK AS INVALID
        OLD_SEQUENCEC[XP] :=  WORD#0;          // MARK AS INVALID
        OLD_SEQUENCED[XP] :=  WORD#0;          // MARK AS INVALID
      END_IF
    END_FOR
    
    // DISPLAYED SEQUENCE NUMBER 
    STB_SEQUENCE := SEQUENCE[ADDRESS] ; 
    FOR XP := 1 TO MAXXP DO
      IF AND(XP_VALID[XP], (_FUNC[XP]>=2), (SEQUENCE[XP]< SEQUENCE[ADDRESS])) THEN STB_SEQUENCE := STB_SEQUENCE - 1; END_IF
    END_FOR
    
    // OUTPUTS     
    IF AUTO THEN    
      LMP_1ST := STB_1ST;                           // 1st STBY LAMP ON PMS PANEL
      LMP_2ND := STB_2ND;                           // 2nd STBY LAMP ON PMS PANEL
    ELSIF AND(BUS_ALL_MANUAL, ENA_SET_STARTSQ) THEN
      LMP_1ST := PB_1ST_UP.Q;
      LMP_2ND := PB_2ND_UP.Q;
    ELSE
      LMP_1ST := FALSE;
      LMP_2ND := FALSE;       
    END_IF   

    OLD_AUTO := AUTO;     
    
  ELSE          // NOT DG 

    LMP_1ST           := FALSE;
    LMP_2ND           := FALSE;   
    STB_SEQUENCE      := 0; 
    SEQ_MASK[ADDRESS] := FALSE;    

  END_IF        

END_PROGRAM]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="PRG" name="AUT_STOP" editor="PAL1131.ST"><![CDATA[PROGRAM AUT_STOP
VAR_EXTERNAL (*$AUTO*) END_VAR

VAR
  OWN_POWER           : FINT; 

  LOADSTOP            : BOOL;
  I                   : INT; 
  T_LOADSTOP          : TON;
    
  SUBSTITUDE_OFFLOAD  : BOOL;
 
  T_SUBST_OFF         : TOF;
  HOLD_LOAD_SHIFT_REQ : BOOL;

  T_DISC_DGX          : TON;
  DISC_DGX            : BOOL;      
   
END_VAR
 
  MIMIC_BLOCK_LOW_LOAD_STOP := AND(OR(MIMIC_BLOCK_LOW_LOAD_STOP, KEYB_BLOCK_LOW_LOAD_STOP_ON), NOT KEYB_BLOCK_LOW_LOAD_STOP_OFF);
 
//###########  AUTO DISCONNECTING  #########################

//**********************************************************
//                                                          
//                                                          
// P0532	<5.3.2> DISCONNECT AFTER ENG. PRE-ALARM SUBST.  
// P0532	<5.3.2> DISCONNECT AFTER BUS ALARM SUBST.       
//                                                          
// P0732	<7.3.2> AUTO STOP - LOW LOAD AUTO STOP DELAY    
//                                                          
//                                                          
//**********************************************************


  // BLACKOUT PREVENTION CHECK 
  BO_PREVENT_OK:= AND(((FINT#100 - (BUS_KW_LOAD / (BUS_KW_POWER - _KW_POWER[ADDRESS]) * FINT#100 )) >  P0731 ),   // ENOUGH RESERVE POWER TO STOP 
                       (BUS_DGX> 1));                                                                             // NOT LAST GENERATOR 

  // AUTO STOPS 
  IF OR( AND((FUNC=1), BREAKER, AUTO), SUBSTITUDE_OFFLOAD, SUBSTITUTE_TRIP, LOWLOAD_STOP, DISC_DGX)  THEN        // CONNECTED DG IN AUTO 

    // PROJECT SPECIFIC STOP DG IF 1ST-STOP AND BUS_DGX>3 
    T_DISC_DGX(IN := (BUS_DGX>P0167 AND STOP_1ST AND P0167>0), PT := T#3s);
    DISC_DGX := T_DISC_DGX.Q;
   
    //*************************************************
    // AUTO DISCONNECT MYSELF AFTER SUBSTITUDE         
    //*************************************************
    
    // SUBSTITUTING : DISCONNECT VIA OFFLOAD 
    SUBSTITUDE_OFFLOAD  := AND( OR(HOLD_LOAD_SHIFT_REQ,                    // LOAD SHIFT CMD   
                                   AND(ALM_204, P0532)),                   // ENGINE PRE-ALARM    
                                BO_PREVENT_OK, 
                                BREAKER);
                                 
    HOLD_LOAD_SHIFT_REQ := AND( (HOLD_LOAD_SHIFT_REQ OR DI_LOAD_SHIFT),
                                BREAKER,
                                NOT AND((BO_PREVENT_OK = FALSE), SUBSTITUDE_OFFLOAD));  
                            
    // SUBSTITUTING : TRIP WHEN D/G SYNCHRONIZING ON BUS => SUBSTITUDE OVER BLACKOUT 
    SUBSTITUTE_TRIP     := AND(
                               OR(AND(BUS_ALM, P0743, P0533), _BUS_ABN[ADDRESS]), //  BUS ALARM OPTION OR BUS ABNORMAL
                               BUS_SYNCHRONIZING,                                 // TRIP WHEN D/G STARTS SYNCHRONIZING ON BUS             
                               BREAKER
                              );
  
    //*************************************************
    // LOW LOAD STOP                                   
    //*************************************************
    LOWLOAD_STOP  :=  AND(STOP_1ST,                                          // FIST TO STOP       
                          BO_PREVENT_OK,                                     // ENOUGH POWER ON BUS 
                          NOT BUS_INH_LLSTOP,                                // NO AUTO STOP ON BUS ALLOWED - BUS/OWN 
                          NOT BUS_HVY_INH_STOP,                              // NO AUTO STOP ON BUS ALLOWED - HEAVY CONSUMER REQUEST(S) 
                          NOT BUS_OFFLOADING,                                // NO OTHER OFFLOADING 
                          NOT MIMIC_BLOCK_LOW_LOAD_STOP,                     // OPERATOR ACTION                           
                          BREAKER);

    //*************************************************
    // AUTO DISCONNECT AFTER OFFLOAD                   
    //*************************************************    
    AUTO_STOP := OR(T_LOADSTOP.Q, SUBSTITUDE_OFFLOAD, DISC_DGX);  
                                         
  ELSE
    AUTO_STOP       := FALSE;
    SUBSTITUTE_TRIP := FALSE;
    LOWLOAD_STOP    := FALSE;
  END_IF


  T_LOADSTOP(IN:= LOWLOAD_STOP, PT:= FINT_TO_SEC(P0732));     // LOW LOAD STOP DELAY 

  IF LOWLOAD_STOP THEN DISPLAY_TIMER := P0732 - (REAL_TO_FINT(TIME_TO_REAL(T_LOADSTOP.ET)) / FINT#1000); END_IF                                           
 
  // INHIBIT AUTO STOP  => DISTRIBUTED OUTPUT TO OTHER XP 
  T_SUBST_OFF(IN:= SUBSTITUDE_OFFLOAD, PT:= T#3s);
  _INH_AUTOSTOP[ADDRESS] :=      OR(DI_INH_LOWLOADSTOP,          // INHIBIT INPUT 33 
                                    UNBALANCED_MODE,             // UNBALANCED LOAD SHARING 
                                    T_SUBST_OFF.Q);                 // AFTER SUBSTITUTION DELAY 


 
END_PROGRAM]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="PRG" name="AUT_START" editor="PAL1131.ST"><![CDATA[PROGRAM AUT_START
 VAR_EXTERNAL (*$AUTO*) END_VAR
 
VAR
 
  BLOCK_OWN_REQ : BOOL;
  MY_STBY_START : BOOL;
  DELAY_OFF     : TOF;
      
END_VAR
 
//##########################################################


 
  // BLOCK OWN REQUEST WHEN SOMEONE STARTING/SYNCHING ON OWN BUS 
  DELAY_OFF(IN := AND(OR(BUS_STARTING, BUS_SYNCHRONIZING, STARTING, SYNCHRONIZING), NOT STANDBY_REQUEST)  , PT := T#2s);
  BLOCK_OWN_REQ := DELAY_OFF.Q ;

  IF AND(NOT(BREAKER), AUTO) THEN        // BREAKER OFF 
    
    IF OR((FUNC=1), HARBOUR_MODE) THEN          // DG, EM+HARBOUR 
  
      // OWN AUTO START 
    
      IF STB_1ST  THEN
    
        STANDBY_REQUEST := OR( BLACKOUT,           // BLACKOUT 
                               BUS_STBY_REQ,      // STANDBY REQUEST ON BUS 
                               BUS_HVY_STBY_REQ,   // STANDBY REQUEST FOR BUS FROM CONSUMER REQ 
                               BUS_GRP_STBY_REQ    // STANDBY REQUEST FOR BUS FROM NON-PREF TRIP 
                             )
                           AND NOT OR(BLOCK_OWN_REQ,
                                     (BUS_SC_TRIP >=2)) ;    // NOT START AFTER 2x SHORT-CIRCUIT TRIP 

      ELSE

        STANDBY_REQUEST := FALSE ;   

      END_IF
    
      // DETECT FAILED STANDBY START 
      IF STANDBY_REQUEST THEN MY_STBY_START := TRUE; END_IF    // SET 
    
      IF MY_STBY_START THEN
        IF OR(
              ALM_201,      // START FAILURE 
              ALM_211,      // ENERGIZE FAILURE 
              ALM_213,      // SYNCHRONISE FAILURE 
              ALM_214       // CB CLOSE FAILURE
              ) 
        THEN
          STBY_START_FAIL := TRUE;
        ELSE
          STBY_START_FAIL := FALSE;
        END_IF
      END_IF

  
    ELSIF (FUNC=2) THEN            // EM+EM.MODE 
  
      STANDBY_REQUEST  :=   AND(BLACKOUT, NOT BLOCK_OWN_REQ)  ; 
  
    END_IF
  

  ELSE      // BREAKER ON 

    MY_STBY_START   := FALSE;     // RESET STANDBY FAIL DETECT 
    STBY_START_FAIL := FALSE;     // RESET STANDBY START FAIL 
    STANDBY_REQUEST := FALSE;   
  
  END_IF

END_PROGRAM]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="PRG" name="REQUEST_STANDBY" editor="PAL1131.ST"><![CDATA[PROGRAM REQUEST_STANDBY
VAR_EXTERNAL (*$AUTO*) END_VAR
 
VAR
 
  LOAD_START    : BOOL;
  OLD_DGX       : INT;
  RST_LOAD_DLY  : BOOL; 
   
  DELAY1        : TON;
  DELAY2        : TON;
  DELAY3        : TON;
  DELAY4        : TON; 
   
  REQ_NEXT      : BOOL;
  PLS_NEXT_ONE  : TP;
  PLS_STBY_FAIL : TP;
   
END_VAR
 
//##########################################################

//**********************************************************
//                                                          
// P0721	<7.2.1> AUTO START - HIGH LOAD - LEVEL 1        
// P0722	<7.2.2> AUTO START - HIGH LOAD - DELAY 1        
// P0723	<7.2.3> AUTO START - HIGH LOAD - LEVEL 2        
// P0724	<7.2.4> AUTO START - HIGH LOAD - DELAY 2        
// P0725	<7.2.5> AUTO START - HIGH LOAD - LEVEL 3        
// P0726	<7.2.6> AUTO START - HIGH LOAD - DELAY 3        
// P0727	<7.2.7> AUTO START - HIGH CURRENT               
// P0728	<7.2.8> AUTO START - HIGH CURRENT DELAY         
//                                                         
// P0741	<7.4.1> STANDBY START WITH ACB ABNORMAL TRIP    
// P0742	<7.4.2> STANDBY START WITH CB TRIP EXT. COMMAND 
// P0743	<7.4.3> STANDBY START WITH NON-PREF. TRIP       
// P0744	<7.4.4> STANDBY START WITH BUS ALARM            
//                                                          
//**********************************************************

  _STANDBY_REQUEST[ADDRESS] := FALSE ;   // INIT 


  // SEE ALSO STANDBY REQUEST FROM CONSUMER BLOCKS + NON PREFERENT TRIPS 

  IF BREAKER THEN 

     IF OR((FUNC=1), HARBOUR_MODE) THEN      // DG, EM+HARBOUR ####################################
   
       // LOAD/CURRENT DEPENDENT START 
       RST_LOAD_DLY := OLD_DGX < BUS_DGX;       // RESTART LOAD TIMERS WHEN NEW AUTOMATIC GENERATOR IS CONNECTED 
       
       DELAY1(IN := AND(GT(BUS_LS_LOAD_PERC, P0721), GTZ(P0721), NOT RST_LOAD_DLY), PT := FINT_TO_SEC(P0722));       // BUS LOAD LEVEL 1  
       DELAY2(IN := AND(GT(BUS_LS_LOAD_PERC, P0723), GTZ(P0723), NOT RST_LOAD_DLY), PT := FINT_TO_SEC(P0724));       // BUS LOAD LEVEL 2  
       DELAY3(IN := AND(GT(BUS_LS_LOAD_PERC, P0725), GTZ(P0725), NOT RST_LOAD_DLY), PT := FINT_TO_SEC(P0726));       // BUS LOAD LEVEL 3  
       DELAY4(IN := AND(GT(AMP_PERC,         P0727), GTZ(P0727), NOT RST_LOAD_DLY), PT := FINT_TO_SEC(P0728));       // CURRENT LEVEL 
       
       LOAD_START := OR(DELAY1.Q, DELAY2.Q, DELAY3.Q, DELAY4.Q);
      
       // STANDBY REQUEST TO OTHER GENERATORS ON BUS  
       REQ_NEXT :=          OR( DI_FORCE_PREF_TRIP_START_STBY,// PREF TRIP INPUT 36 
                                _BUS_ABN[ADDRESS],            // BUS ABNORMAL ALARM 
                                AND(BUS_ALM, P0743),          // BUS ALARM                          
                                ALM_204,                      // PRE-ALARM   
                                DI_LOAD_SHIFT                 // LOAD SHIFT CMD
                               );   

     ELSIF OR((FUNC=3), (FUNC=4)) THEN            // SHAFT, SHORE #################################

       REQ_NEXT := AND((BUS_DG_POWER < OWNBUS_LOADKW), OR(OFFLOADING, SHAFT_PREUNLOAD));
 
     END_IF

  ELSE

    REQ_NEXT   := FALSE;
    LOAD_START := FALSE;                                             

  END_IF


  PLS_NEXT_ONE(IN  := OR(REQ_NEXT, AND(ABN_TRIP_REQ, P0741), AND(CB_TRIPPED_ANY, P0741)), PT := T#3s );
  PLS_STBY_FAIL(IN := STBY_START_FAIL,                                                    PT := T#3s );

  _STANDBY_REQUEST[ADDRESS] := OR(LOAD_START,               // LOAD/CURRENT DEPENDENT START 
                                  PLS_NEXT_ONE.Q,           // PULSE FROM STATIC CONDITIONS 
                                  PLS_STBY_FAIL.Q);         // START FAILED => FORWARD REQUEST    

  OLD_DGX := BUS_DGX;

END_PROGRAM]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="PRG" name="PRG_ENERGIZING" editor="PAL1131.ST"><![CDATA[PROGRAM PRG_ENERGIZING
VAR_EXTERNAL (*$AUTO*) END_VAR
 
VAR
 
  ENERGIZED_LVL : BOOL := FALSE ; 
  RESET_START   : BOOL := FALSE ; 
  T_ENERGIZE    : TON ;
  FAILURE_ENERG : SR ;
  OLD_START     : BOOL:= FALSE;
           
END_VAR
 
//########################################################

//**********************************************************
//                                                          
// P0431	<4.3.1> VOLTAGE ENERGIZED LEVEL                   
// P0432	<4.3.2> ENERGIZED DETECT DELAY                    
//                                                          
// ALM_211	<211> ENERGIZE FAILURE                          
//                                                          
//**********************************************************

  //*************************************************************************
  // START/ENERGIZE                                                           
  //*************************************************************************

  READY2START := FALSE;     // INIT 
  CMD_START   := FALSE;
  RESET_START := FALSE;
  ENERGIZING  := FALSE; 

  ENERGIZED_LVL := AND((VOLT_PERC > P0431), (FREQ_PERC > P0431));

  IF NOT BREAKER THEN

    IF OR((FUNC=1), (FUNC=2)) THEN      // DG, EM ##################################################################

      RESET_START :=  OR(STOPPING, PB_STOP, MBS_STOP, MM_STOP, ALM_201, ALM_211, LOCAL)  ;         // INTERRUPT START 
      
      READY2START := NOT OR(
                            CRITICAL_ALARM,     // CRITICAL ALARM      
                            NOT READY,          // READY TO START 
                            SHUTDOWN,           // ENGINE SAFETY SHUTDOWN 
                            STOPPING,           // STOP VALVE 
                            RUNNING,
                            STARTING,
                            LOCAL,
                            DI_AVR_ALARM 
                           );
      
      CMD_START :=  AND(
                        OR(
                           PB_START,         // MANUAL START 
                           MBS_START,        // MODBUS
                           MM_START,         //USER
                           STANDBY_REQUEST   // AUTO START                                       
                           ),                   
                        READY2START          // READY
                        );                                    
      
      // STARTING 
      IF CMD_START AND NOT OLD_START THEN 
        STARTING := TRUE;                    
      ELSIF RESET_START   THEN                   // RESET STARTING 
        STARTING := FALSE;
      ELSIF ENERGIZED THEN                       // STARTING FINISHED 
        STARTING := FALSE;
      END_IF
      
      ENERGIZING := AND(STARTING, RUNNING, NOT STOPPING);
      ENERGIZED  := AND(ENERGIZED_LVL, T_ENERGIZE.Q, NOT RESET_START); 
      LMP_RUN    := AND( OR(STARTING, RUNNING), NOT ENERGIZED, NOT STOPPING, FLASH) OR AND(RUNNING, ENERGIZED);
   
    ELSIF OR((FUNC=3), (FUNC=4)) THEN    //SHAFT, SHORE #######################################################

      ENERGIZED := AND(ENERGIZED_LVL, RUNNING);
      LMP_RUN   := ENERGIZED;

    END_IF // DG, EM
   
  ELSE

    ENERGIZING  := FALSE; 
    STARTING    := FALSE;
    ENERGIZED   := AND(ENERGIZED_LVL, RUNNING);
    LMP_RUN    := ENERGIZED;
   
  END_IF  // NOT BREAKER

  // LAMP 
  IF LOCAL THEN LMP_RUN := RUNNING; END_IF    


  // STARTING STATUS TO OTHER XP 
  _STARTING[ADDRESS] := STARTING ;
 

  T_ENERGIZE(IN := AND(RUNNING, NOT STOPPING), PT := FINT_TO_SEC(P0432));                 // DELAY  

  // ALARM 
  FAILURE_ENERG( S1 :=  AND(T_ENERGIZE.Q, NOT ENERGIZED_LVL, STARTING), R := RESET);   // ENERGIZING ALARM     
  ALM_211 := FAILURE_ENERG.Q1;       

  // FOR EDGE DETECT 
  OLD_START := CMD_START ;

END_PROGRAM]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="PRG" name="CONNECTING" editor="PAL1131.ST"><![CDATA[PROGRAM CONNECTING
VAR_EXTERNAL (*$AUTO*) END_VAR
 
VAR
 
  SYNC_FAILURE        : BOOL := FALSE;
  NEXT_AUTO_CONNECT   : BOOL := FALSE; 
  PLS_CLOSE           : R_TRIG;
  PLS_RESET           : R_TRIG;
  END_SYNC            : F_TRIG; 
  T_SYNCCHECK         : TON;
  SIM_SYNCED          : TON;
  FAILURE_SYNC        : SR;
  T_CLOSECB           : TON;
  FAILURE_CLOSE       : SR; 
  SYNC_ALM_CHECK      : BOOL;      
    
  CLOSE_CMD           : BOOL := FALSE;
  OLD_CLOSE           : BOOL;
  CLOSING             : BOOL;
  ENABLE_DIRECT_CLOSE : BOOL;
  BLOCK_CLOSE_CMD     : BOOL;
                       
  T_BUS_OFFLOAD       : TON; 
  BUSOFFLOADING       : BOOL;
  OLD_DGX             : INT;
  BUSTRIP_PLS         : TP;
         
 END_VAR
 
//########################################################

//**********************************************************
//                                                          
// P0517	<5.1.7> SYNC CHECK MAXIMUM SYNC TIME              
// P0518	<5.1.8> IO-BOARD SYNC TEST MODE                   
// P0167  <1.6.7> MAX UMBER OF GEN ON THE BUS               
//                                                          
// ALM_213	<213> SYNCHRONIZE FAILURE                       
// ALM_214	<214> CB CLOSE FAILURE                          
//                                                          
//**********************************************************

  // ENABLE AUTO CLOSE BREAKER (AUTO MODE) 
  IF AND(STARTING, AUTO, P0165, (BUS_DGX<P0167 AND P0167>0)) THEN                     
   
    IF NOT BUS_BLOCKS_SYNC THEN
      NEXT_AUTO_CONNECT := TRUE;           // START + SYNC; NO SHAFT OR SHORE CONNECTED TO THIS BUS
    ELSE
      STARTING := TRUE;                    // START; SHAFT OR SHORE CONNECTED TO THIS BUS
    END_IF
   
  END_IF

  // REMEMBER STANDBY START FOR AUTO CLOSING CB IF NOT YET ENERGIZED 
  IF AND(STARTING, STANDBY_REQUEST) THEN NEXT_AUTO_CONNECT := TRUE;  END_IF
  IF OR(STOPPING, END_SYNC.Q)       THEN NEXT_AUTO_CONNECT := FALSE; END_IF

  //*************************************************************************
  // IO-BOARD SYNCHRONIZER TEST MODES *************************************** 
  //*************************************************************************
  // IOB_P0518 =>  SYNC CHECK TEST/DEBUG MODES 
  // 0 = PMS IO-BOARD TEST MODE OFF 
  // 1 = PMS IO-BOARD TEST MODE ON  =>  DEBUG INDICATIONS + NO CIRCUIT BREAKER CLOSE 
  // 2 = PMS IO-BOARD TEST MODE ON  =>  DEBUG INDICATIONS + CIRCUIT BREAKER CLOSE 

  ALM_501 := IOB_P0518 <> 0;      // IO-BOARD IN TEST MODE 


  //*************************************************************************
  // CLOSE BREAKER   ******************************************************** 
  //*************************************************************************

  // OPERATOR COMMANDS 
  PLS_CLOSE(CLK := OR(PB_CLOSE, MBS_CLOSE, MM_CLOSE, DI_CLOSE_CB));    // CLOSE FROM FRONT OR DIN 
  PLS_RESET(CLK := OR(PB_OPEN, MBS_OPEN, MM_OPEN, DI_OPEN_CB));        // RESET FROM FRONT OR DIN 

  // INIT 
  CLOSE_CMD           := FALSE; 
  ENABLE_DIRECT_CLOSE := FALSE;

  // CLOSE BREAKER COMMAND 

  IF NOT BREAKER THEN

    IF NOT OR(LOCAL, CB_TRIPPED_ANY, CRITICAL_ALARM) THEN
      
      IF (FUNC=5) THEN      // ABT ##################################################################
         
        BLOCK_CLOSE_CMD := OR( ABT_CLOSE_WAIT,                      // NOT ALREADY SYNCING OR OFFLOADING/STARTING ON EITHER SIDE  
                               AND(ABT_NOTSYNC1, ABT_NOTSYNC2));    // NO SYNCING POSSIBLE LEFT & RIGHT 

        IF AUTO THEN BLOCK_CLOSE_CMD := OR(BLOCK_CLOSE_CMD, AND(DEAD_BUS, DEAD_BUS2)); END_IF   
         
        CLOSE_CMD           :=  AND(
                                    OR(
                                       PLS_CLOSE.Q,                    // USER
                                       AND(BLACKOUT, AUTO)             // BLACKOUT CLOSE COMMAND 
                                       ),            
                                    NOT BLOCK_CLOSE_CMD
                                    );        
                            
        ENABLE_DIRECT_CLOSE := OR(DEAD_BUS, DEAD_BUS2, AND(ABT_SERIES, NOT ABT_SERIES_CB));     // "ABT IN SERIES AND OPEN" IS DOUBLE: LEFT HERE TO E.G. USE IN OTHER CONDITIONS 
   
      ELSE
      
        ENABLE_DIRECT_CLOSE := DEAD_BUS;   
        BLOCK_CLOSE_CMD := OR(
                              NOT ENERGIZED,                 // D/G NOT ENERGIZED 
                              PHASE_FAULT,                   // BUS/GEN PHASE PROBLEM 
                              AND(BUS_DGX>= P0167, P0167>0)  // BLOCK CONNECT
                              ); 
                              
        IF OR((FUNC=1), (FUNC=2)) THEN      // DG, EM ########################################################
      
          CLOSE_CMD := AND(
                           OR( 
                              AND(PLS_CLOSE.Q, NOT BUS_SHAFT_SHORE),   // OPERATOR CLOSE COMMAND                        
                              NEXT_AUTO_CONNECT,                       // FOLLOWING STANDBY START REQUEST, OR AUTO MODE PARAMETER P0165 
                              STANDBY_REQUEST                          // STANDBY START REQUEST IF ALREADY ENERGIZED 
                             ),
                         NOT BLOCK_CLOSE_CMD
                         );
         
        ELSE                              // SHAFT, SHORE ##################################################
         
          BLOCK_CLOSE_CMD := OR(BLOCK_CLOSE_CMD,
                                BUS_BLOCKS_SYNC,          // FREQ. CONTROL POSSIBLE 
                                (BUS_KW_LOAD > P0147));   // BUS LOAD BELOW CAPACITY                                    
         
          CLOSE_CMD := AND(PLS_CLOSE.Q,                   // MANUAL CLOSE COMMAND 
                           NOT BLOCK_CLOSE_CMD); 
                                                            
        END_IF  // DG, EM
   
      END_IF  // ABT
        
    END_IF  // NOT OR(LOCAL, CB_TRIPPED_ANY, CRITICAL_ALARM)
   
    // SYNCHRONIZING 
   
    IF AND(CLOSE_CMD, NOT OLD_CLOSE) THEN          // SYNCHRONIZING STARTED 
      SYNCHRONIZING  := TRUE;
      SYNC_ALM_CHECK := TRUE;   
    ELSIF OR(ALM_213, ALM_214, CB_TRIPPED_ANY, AND(PLS_RESET.Q, NOT BREAKER), LOCAL) THEN        // SYNCHRONIZING RESET
      SYNCHRONIZING  := FALSE;
      SYNC_ALM_CHECK := FALSE; 
    END_IF 
   
    BUSOFFLOADING := FALSE;
   
  ELSE             // BREAKER CLOSED 

    SYNCHRONIZING  := FALSE;
    SYNC_ALM_CHECK := FALSE;  

  END_IF

  IF OR((FUNC=3), (FUNC=4)) THEN            // SHAFT, SHORE ##################################################

    // OFFLOAD / TRIP BUS BY SHAFT/SHORE 
    BUSOFFLOADING := AND(NOT OR(SHAFT_PREUNLOAD, OFFLOADING), BREAKER, (BUS_DGX <= OLD_DGX));   // PULSE ON NEXT CB ON BUS 

    T_BUS_OFFLOAD(IN := BUSOFFLOADING ,                                          PT := FINT_TO_SEC(P0523)) ;  // (RE)START MAX. PARALLEL TIME 
    BUSTRIP_PLS(  IN := AND(OR(T_BUS_OFFLOAD.Q, (P0523=FINT#0)), BUSOFFLOADING), PT := T#3s) ;                // GIVE PULSE TO DISCONNECT D/G 

    IF BUSOFFLOADING THEN
      _OFFLOAD_BUSX[ADDRESS] := (BUS * 10) + BOOL_TO_INT(BUSTRIP_PLS.Q);
    ELSE
      _OFFLOAD_BUSX[ADDRESS] := 0; 
    END_IF 
  ELSE

   _OFFLOAD_BUSX[ADDRESS] := 0; 

  END_IF
  OLD_DGX:= BUS_DGX;


  _SYNCHRONIZING[ADDRESS] := SYNCHRONIZING;          // CONNECTING STATUS TO OTHER XP 

  CLOSING          := SYNCHRONIZING;          
  IOB_CLOSE_TPULSE := P0516;                         // CLOSE PULSE LENGTH TO IO-BOARD 


  // SIMULATION 
  IF SIM_ON_SAMES THEN

    SIM_SYNCED(IN := SYNCHRONIZING , PT := T#2s ) ;  // IN SIMULATION MODE ALWAYS TWO SEC SYNC    

    // FAKE IO-BOARD SYNC CHECK FUNCTION 
    ENABLE_DIRECT_CLOSE := OR(
                              AND(
                                  ((BUSFREQ_PERC + FINT#0.2)>= FREQ_PERC ), 
                                  ((BUSFREQ_PERC - FINT#0.2)<= FREQ_PERC ),
                                  SIM_SYNCED.Q                     // FAKE IO-BOARD SYNC 
                                 ),
                              ENABLE_DIRECT_CLOSE
                              );
    CLOSING :=  AND(SYNCHRONIZING, ENABLE_DIRECT_CLOSE);                        
    IOB_CLOSE_TPULSE := FINT#0.5;

  END_IF

  // IO-BOARD COMMANDS TO IO-BOARD => ACTUAL SYNCHRONIZING + CLOSE OUTPUT IS HARD-CODED IN IO-BOARD 
  IOB_CLOSE_SYNC    := AND(CLOSING, NOT ENABLE_DIRECT_CLOSE, NOT BUS_ABNORMAL);   // IF BUS ABNORMAL WAIT FOR BLACKOUT  
  IOB_CLOSE_DEADBUS := AND(CLOSING,     ENABLE_DIRECT_CLOSE);  

  // ALARMS 
  IF DO_CLOSE_CB_READONLY THEN SYNC_ALM_CHECK := FALSE; END_IF                                       // & RESET ON CLOSE BREAKER OUTPUT 
  T_SYNCCHECK(IN := AND(SYNC_ALM_CHECK, (IOB_P0518<>1), NOT BREAKER) , PT := FINT_TO_SEC(P0517)) ;   // SYNC FAILURE; NOT IN TEST MODE 1 
  FAILURE_SYNC(S1 := T_SYNCCHECK.Q , R := RESET);
  ALM_213 := FAILURE_SYNC.Q1; 

  T_CLOSECB(IN := AND(SYNCHRONIZING, NOT SYNC_ALM_CHECK, (IOB_P0518<>1), NOT BREAKER), PT := T#2s) ;  // CLOSE CB FAILURE 
  FAILURE_CLOSE(S1 := T_CLOSECB.Q , R := RESET);
  ALM_214 := FAILURE_CLOSE.Q1; 

  // LAMP 
  IF LOCAL THEN
    LMP_CLOSE := BREAKER; 
  ELSE
    LMP_CLOSE := OR(AND(SYNCHRONIZING, FLASH), BREAKER);    
  END_IF   

  // FOR EDGE DETECT 
  OLD_CLOSE := CLOSE_CMD ;
  END_SYNC(CLK := SYNCHRONIZING);

END_PROGRAM]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="PRG" name="DISCONNECTING" editor="PAL1131.ST"><![CDATA[PROGRAM DISCONNECTING
VAR_EXTERNAL (*$AUTO*) END_VAR
 
VAR
    
  OPEN_CB_CMD     : BOOL := FALSE;
  CMD_USER        : BOOL := FALSE; 
  UNLOAD          : BOOL := FALSE; 
  OFFLOAD_OPENCB  : BOOL := FALSE; 
  CB_OPEN_NO_CMD  : BOOL;
  OLD_OPEN        : BOOL := FALSE;   
  OLD_CB          : BOOL; 
  MANUAL_OPEN     : BOOL;
  BLOCK_OPEN_CMD  : BOOL := TRUE;
        
  OFFLOAD_FAILURE : SR;
  T_OFFLOAD       : TON;
  CB_OPEN_EXT     : TOF;
  PLS_OPEN        : R_TRIG;
  PLS_RESET       : R_TRIG;
  LATCH227        : SR;     
  TRIP_OFFLOAD    : TP;
      
END_VAR
 
//########################################################

//********************************************************
//                                                        
// P0521  <5.2.1> CB OPEN PULSE TIME                    
// P0522	<5.2.2> LOW LOAD LIMIT TO OPEN CB             
// P0523	<5.2.3> MAX. OFFLOAD (PARALLEL) TIME          
// P0531	<5.3.1> DISCONNECT WITH OFFLOAD FAIL          
//                                                        
// P0731	<7.3.1> AUTO STOP - RESERVE AFTER OFFLOAD     
//                                                        
// ALM_212	<212> OFFLOAD FAILURE                         
// ALM_215  <215> CB OPEN FAILURE                         
//                                                        
//********************************************************


  PLS_OPEN(CLK:=  OR(PB_OPEN, MBS_OPEN, MM_OPEN, DI_OPEN_CB));      // OPEN FROM FRONT OR DIN 
  PLS_RESET(CLK:= OR(PB_CLOSE, MBS_CLOSE, MM_CLOSE ,DI_CLOSE_CB));  // RESET FROM FRONT OR DIN 

  //*************************************************************************
  // OPEN BREAKER   ******************************************************** 
  //*************************************************************************
  
  CMD_OPEN := FALSE;      // LIMIT COMMAND TO 1 LOOP 

  // D/G TRIP WHILE/BEFORE OFFLOAD 

  TRIP_OFFLOAD(IN := BUS_OFFLOADTRIP , PT := T#2s);

  IF AND(BREAKER, NOT LOCAL) THEN       // BREAKER CLOSED     

    IF (FUNC=5) THEN                   // ABT ##################################################
        
      BLOCK_OPEN_CMD := OR(                                  // GENERATOR CONNECTED LEFT AND RIGHT BUSSES -> NOT CAUSE BO ON EITHER SIDE 
                           AND(ABT_DGX1 < 1, ABT_DGX2 >= 1), 
                           AND(ABT_DGX2 < 1, ABT_DGX1 >= 1)
                           );

      IF AUTO THEN
        BLOCK_OPEN_CMD := OR(BLOCK_OPEN_CMD, BUS_HVY_INH_STOP);
      ELSE
        BLOCK_OPEN_CMD := AND(BLOCK_OPEN_CMD, P0162); 
      END_IF

      CMD_OPEN := OR(
                     AND(PLS_OPEN.Q, NOT BLOCK_OPEN_CMD),
                     AND(BUS_SC_TRIP > 0, AUTO)
                     );
 
    ELSE
      // COMMAND TO OPEN CB 
      IF OR((FUNC=1), (FUNC=2)) THEN      // DG, EM ##########################################
          
        BLOCK_OPEN_CMD := OR(BUS_OFFLOADING, NOT BO_PREVENT_OK);
          
        IF AND(PLS_OPEN.Q, NOT BLOCK_OPEN_CMD, AUTO) THEN            // SET OPERATOR COMMAND 
          CMD_USER := TRUE;
        ELSIF OR(
                 AND(CMD_USER, PLS_RESET.Q),
                 NOT AND(BREAKER, UNLOAD, AUTO)
                 )
        THEN  // RESET OPERATOR COMMAND 
          CMD_USER := FALSE;
        END_IF
          
        // OFFLOADING    
        UNLOAD := AND(
                      OR(
                         CMD_USER,                                      // OPERATOR COMMAND 
                         AUTO_STOP,                                     // AUTO STOP  
                         BUS_OFFLOAD                                  
                         ),
                       NOT OR(ALM_212, IOB_ALM_215)                     // NOT OFFLOAD/CB OPEN FAILURE
                       );           

        // OPEN CB WHEN OFFLOADED ENOUGH 
        OFFLOAD_OPENCB := AND(OR(KW_PERC < P0522, TRIP_OFFLOAD.Q), UNLOAD);     // LOW GENERATOR LOAD 

      ELSE                              // SHAFT, SHORE ####################################
        
        IF AND(PLS_OPEN.Q, AUTO) THEN            // SET OPERATOR COMMAND 
          CMD_USER := TRUE;
        ELSIF OR(
                 AND(CMD_USER, PLS_RESET.Q),
                 NOT AND(BREAKER, OR(UNLOAD, SHAFT_PREUNLOAD), AUTO)
                 )
        THEN  // RESET OPERATOR COMMAND 
          CMD_USER := FALSE;
        END_IF
          
        // PREPARE OFFLOADING => WAIT OFFLOAD TIME-OUT UNTIL 1 DG PARALLELED 
        SHAFT_PREUNLOAD := AND(BUS_DGX < 2, CMD_USER); 
          
        // OFFLOADING    
        UNLOAD := AND(
                      OR(
                         AND(CMD_USER, NOT SHAFT_PREUNLOAD),  // OPERATOR COMMAND 
                         AUTO_STOP                            // AUTO STOP
                         ),                                          
                      NOT OR(ALM_212, IOB_ALM_215)            // NOT OFFLOAD/CB-OPEN FAILURE               
                     );
                     
        OFFLOAD_OPENCB := AND(OR(KW_PERC<P0522, P0523=FINT#0), UNLOAD, BO_PREVENT_OK);      // LOW GENERATOR LOAD 

      END_IF  // DG, EM

      // OPEN CIRCUIT BREAKER 
      MANUAL_OPEN := AND(PLS_OPEN.Q, OR(BO_PREVENT_OK, NOT P0162), MANUAL)     ;
     
      CMD_OPEN := OR( 
                     MANUAL_OPEN,                 // DISCCONNECT BY MANUAL COMMAND  
                     AND(ALM_212, P0531),         // DISCONNECT WITH OFFLOAD FAILURE 
                     OFFLOAD_OPENCB,              // OFFLOAD ENDED 
                     SHUTDOWN,                    // ENGINE SHUTDOWN 
                     DI_AVR_ALARM,
                     SUBSTITUTE_TRIP              // SUBSTITUTE OVER BLACKOUT 
                     );
    END_IF 
                        
    IF AND(CMD_OPEN, NOT OLD_OPEN) THEN
      OPENING       := TRUE;
    ELSIF  IOB_ALM_215 THEN
      OPENING       := FALSE;
    END_IF       
       
  ELSE                   // BREAKER OPEN 

    UNLOAD          := FALSE;
    OPENING         := FALSE;
    SHAFT_PREUNLOAD := FALSE;

  END_IF

  IF SIM_ON_WIRING THEN
    CMD_OPEN := OR(CMD_OPEN, DI_CBTRIPPED, DI_CB_SC_TRIPPED, AND(NOT BREAKER, OLD_CB));     //  WITH WIRING SIMULATION => OPEN SIMULATOR CB  
  END_IF

  // OFFLOADING STATUS INTERNAL + TO OTHER XP 
  OFFLOADING := UNLOAD OR OPENING;
  _OFFLOADING[ADDRESS] := OFFLOADING;

  // CB OPEN COMMAND TO IO-BOARD  
  IOB_CMD_OPEN_CB := OPENING;

  //  ************************************************************
  // ALARMS ******************************************************
  //  ************************************************************

  // <ALM227> CB ABNORMAL TRIPPED 
  CB_OPEN_EXT(IN := DO_OPEN_CB , PT := T#2s);
  CB_OPEN_NO_CMD := AND(NOT BREAKER, OLD_CB, NOT CB_OPEN_EXT.Q, PMS_SEL);      // CB OPENED NOT BY PMS 

  LATCH227(S1 := OR(DI_CBTRIPPED, CB_OPEN_NO_CMD) , R := RESET);
  ALM_227 := LATCH227.Q1; 

  T_OFFLOAD(IN := AND(UNLOAD, NOT IOB_ALM_215, (P0523<>FINT#0)), PT := FINT_TO_SEC(P0523));       // OFFLOAD FAILURE  
  OFFLOAD_FAILURE(S1:= T_OFFLOAD.Q, R:= RESET );
  ALM_212 := OFFLOAD_FAILURE.Q1; 

  // LAMP 
  LMP_OPEN :=  OR(AND(OR(OFFLOADING, SHAFT_PREUNLOAD), FLASH), NOT BREAKER);  // OPEN LAMP ON PMS PANEL

  // FOR EDGE DETECT 
  OLD_OPEN := CMD_OPEN;
  OLD_CB   := BREAKER;

END_PROGRAM]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="PRG" name="PRG_STOPPING" editor="PAL1131.ST"><![CDATA[PROGRAM PRG_STOPPING
VAR_EXTERNAL (*$AUTO*) END_VAR
 
VAR
 
  DIRECT_STOP     : BOOL := FALSE;
  CMD_STOP        : BOOL := FALSE;      
  COOLDN_FINISHED : BOOL := FALSE; 
  CMD_USER        : BOOL := FALSE;
  STOP_CMD        : BOOL;
            
  STOP_VALVE      : BOOL := FALSE;   
  STOPPED         : BOOL := FALSE; 
        
  OLD_STOP        : BOOL := FALSE; 
    
  T_COOLDOWN      : TON;
  T_STOP          : TON;
  STOP_FAILURE    : RS;
   
  PLS_STOP        : R_TRIG;
  PLS_RESET       : R_TRIG;
  DLY_AFT_START   : TON;

 END_VAR

  MIMIC_BLOCK_IDLE_RUN_STOP := AND(OR(MIMIC_BLOCK_IDLE_RUN_STOP, KEYB_BLOCK_IDLE_RUN_STOP_ON), NOT KEYB_BLOCK_IDLE_RUN_STOP_OFF);
  MIMIC_BLOCK_IDLE_RUN_STOP := FALSE;
 
//########################################################

//********************************************************
//                                                        
// P0421	<4.2.1> STOP PULSE TIME                       
// P0422	<4.2.2> ENGINE COOLDOWN TIME                  
// P0423	<4.2.3> COOLDOWN AFTER PRE-ALARM              
//                                                        
// ALM_202	<202> ENGINE STOP FAILURE                     
// ALM_204  <204> ENGINE PRE-ALARM                        
//********************************************************

  COOLING_DOWN := FALSE ;          // INIT 
  CMD_STOP     := FALSE ;  
  LMP_STOP     := FALSE ; 
  ALM_202      := FALSE ;

  STOP_CMD := OR(PB_STOP, MBS_STOP, MM_STOP); 

  PLS_STOP( CLK := STOP_CMD);                     
  PLS_RESET(CLK := OR(PB_START, MBS_START, MM_START));    // RESET START 

  DLY_AFT_START(IN := ENERGIZED, PT := T#60s);

  IF OR((FUNC=1), (FUNC=2)) THEN      // DG, EM 
 
    // STOP  **************************************************************
    IF AND(OR(RUNNING, COOLING_DOWN, STOPPING), NOT LOCAL) THEN
  
      // USER COMMANDS 
      IF AND(PLS_STOP.Q, AUTO, NOT BREAKER) THEN                                       // SET MANUAL COMMAND 
        CMD_USER := TRUE;
      ELSIF OR((CMD_USER AND PLS_RESET.Q), NOT RUNNING, NOT STOPPING, NOT AUTO) THEN    // RESET MANUAL COMMAND 
        CMD_USER := FALSE;
      END_IF
    
      // COOLING DOWN 
      COOLING_DOWN := AND( 
                           OR( CMD_USER,                           // MANUAL COMMAND IN AUTO 
                               NOT STANDBY_REQUEST),               // NO STANDBY REQUEST  
                           NOT STARTING,                           // NOT BUSY STARTING                      
                           NOT SYNCHRONIZING,                      // NOT BUSY SYNCHRONIZING 
                           NOT BREAKER,                            // BREAKER OPEN                    
                           NOT STOPPING,                           // FINISHED WHEN GOING INTO STOPPING 
                           NOT MIMIC_BLOCK_IDLE_RUN_STOP,          // OPERATOR ACTION                          
                           OR(DLY_AFT_START.Q, T_COOLDOWN.IN),      // WAIT A MINUTE AFTER START 
                           AUTO );
   
      CMD_STOP := AND(
                      OR( 
                         SHUTDOWN,
                         DI_AVR_ALARM,	
                         OR(COOLDN_FINISHED,                      // END OF COOLING DOWN 
                            AND(COOLING_DOWN, STOP_CMD),          // OPERATOR STOP DURING COOLING DOWN 
                            AND(MANUAL, STOP_CMD),                // STOP IN MANUAL 
                            AND(ALM_204, NOT P0423)               // PRE-ALARM OPTION TO STOP WITHOUT COOLDOWN  
                           )  
                        ),
                      NOT BREAKER
                      );

    
      // STOPPING         
      IF AND(CMD_STOP, NOT OLD_STOP) THEN
        STOPPING := TRUE;                                                    
      ELSIF AND(STOPPING, STOPPED) THEN       // FINISHED STOPPING 
        STOPPING := FALSE;         
      END_IF

    END_IF //(RUNNING OR COOLING_DOWN OR STOPPING) AND NOT(LOCAL)

    IF LOCAL THEN
      LMP_STOP := NOT RUNNING; 
    ELSE
      LMP_STOP := (OR(COOLING_DOWN, STOPPING) AND FLASH) OR AND(NOT RUNNING, NOT OR(COOLING_DOWN, STOPPING)); 
    END_IF        

    // ALM_202	<202> ENGINE STOP FAILURE
    STOP_FAILURE(S := AND(STOPPED, RUNNING) , R1 := RESET);  
    ALM_202 := STOP_FAILURE.Q1 ;

  END_IF
    
  // STOPPING STATUS TO OTHER XP 
  _STOPPING[ADDRESS] :=  STOPPING;

  // COOLING DOWN TIME 
  T_COOLDOWN(IN:= COOLING_DOWN, PT:= FINT_TO_SEC(P0422));   
  COOLDN_FINISHED := T_COOLDOWN.Q;

  IF COOLING_DOWN THEN
    DISPLAY_TIMER := P0422 - (REAL_TO_FINT(TIME_TO_REAL(T_COOLDOWN.ET)) / FINT#1000);
  ELSIF NOT LOWLOAD_STOP THEN
    DISPLAY_TIMER := FINT#0;
  END_IF
  
  // STOP TIME 
  T_STOP(IN := STOPPING, PT := FINT_TO_SEC(P0421));
  STOPPED := T_STOP.Q;        // => END STOPPING 
  DO_STOP := STOPPING;        // STOP VALVE 

  // FOR EDGE DETECT 
  OLD_STOP := CMD_STOP;

END_PROGRAM]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="PRG" name="MOTOR" editor="PAL1131.ST"><![CDATA[PROGRAM MOTOR
VAR_EXTERNAL (*$AUTO*) END_VAR
 
VAR
 
  PRE_LUBRICATING : BOOL := FALSE;    
  RE_START        : BOOL := FALSE;
  START_FAILURE   : BOOL := FALSE;
  START_VLV       : BOOL := FALSE;
  N               : INT;

  T_PRELUB        : TP;
  T_START         : TP;
  T_RESTART       : TON;
  VLV_END         : F_TRIG;
  FAILURE         : RS;
  OLD_START       : BOOL := FALSE;
  PRE_ALARM       : SR;

  LATCH203        : SR;         
  LATCH_SHD       : SR;
  SAFETY_SHUTDOWN : BOOL := FALSE;

END_VAR
 
//########################################################

//**********************************************************
//                                                          
// P0411	<4.1.1> MAXIMUM START PULSE                       
// P0412	<4.1.2> NUMBER OF START ATTEMPTS                  
// P0413	<4.1.3> RE-START DELAY                            
// P0414	<4.1.4> PRE-LUBRICATION TIME                      
//                                                          
// ALM_201  <201> ENGINE START FAILURE                      
// ALM_204	<204> ENGINE PRE-ALARM                          
//                                                          
//**********************************************************

  ALM_201         := FALSE ;         // INIT 
  ALM_204         := FALSE ;
  ALM_203         := FALSE; 
  SHUTDOWN        := FALSE ;
  DO_START        := FALSE ;  
  PRE_LUBRICATING := FALSE;
  FUNCOUT[31]     := FALSE;
  START_VLV       := FALSE ;
  
  T_PRELUB(IN:= STARTING , PT:= FINT_TO_SEC(P0414) ); 

  IF OR((FUNC=1), (FUNC=2)) THEN      // DG, EM 

    //**********************************************************************
    // START DIESEL                                                         
    //**********************************************************************

    //  ENGINE PRE-ALARM 
    PRE_ALARM(S1 := DI_PRE_ALM, R := RESET);
    ALM_204 := PRE_ALARM.Q1;
  
    // START INIT AT FIRST ENTRY 
    IF AND(STARTING, NOT OLD_START) THEN         
      N        := 1;                  // INIT START ATTEMPS 
      RE_START := FALSE;
    END_IF

    IF AND(STARTING, NOT OR(RUNNING, START_FAILURE)) THEN 
  
      IF AND(CONF_PRELUB, P0414 > FINT#0)  THEN
        PRE_LUBRICATING := T_PRELUB.Q;         // PRE LUBRICATING 
        FUNCOUT[31]     := PRE_LUBRICATING ;
      END_IF
        
      IF NOT PRE_LUBRICATING THEN                 // PRELUB ENDED OR NOT USED 
  
        START_VLV := NOT RE_START;
         
        IF VLV_END.Q THEN  RE_START := TRUE; END_IF  // SET 
    
        IF T_RESTART.Q THEN
         
          IF OR(N >= P0412, MANUAL) THEN
            START_FAILURE := TRUE;          // START FAILURE 
          ELSE
            N := N + 1;    
          END_IF
         
          RE_START  := FALSE;   
                     
        END_IF  // T_RESTART.Q
  
      END_IF  // NOT PRE_LUBRICATING
 
    ELSE
    
      RE_START  := FALSE;   
                     
    END_IF  // AND(STARTING, NOT OR(RUNNING, START_FAILURE))
  
    DO_START := T_START.Q  AND START_VLV ;         // START VALVE 

    // START FAILURE ALARM 
    IF RESET THEN START_FAILURE := FALSE; END_IF
    FAILURE(S := START_FAILURE, R1 := RESET);
    ALM_201 := FAILURE.Q1; 

    //**********************************************************************
    // STOP DIESEL                                                          
    //**********************************************************************
    
    // EXTERNAL SHUTDOWN  
    LATCH203(S1 := DI_SHUTDOWN, R := RESET) ;
    ALM_203 := LATCH203.Q1;         // <203> ENGINE EXT. SHUTDOWN 
  
    // OPTION: INTEGRATED SAFETY SYSTEM ??? 
    SAFETY_SHUTDOWN := FALSE ;
  
    // SHUTDOWN 
    LATCH_SHD(S1 := OR(ALM_203, SAFETY_SHUTDOWN), R := AND(RESET, NOT RUNNING)) ;
    SHUTDOWN  := LATCH_SHD.Q1 ;

    DO_STOP := OR(STOPPING, SHUTDOWN);               // STOP VALVE 
     
  END_IF   // DG, EM

  // START TIMERS 
  T_START(  IN := START_VLV, PT := FINT_TO_SEC(P0411));
  T_RESTART(IN := RE_START , PT := FINT_TO_SEC(P0413));
  VLV_END(CLK := DO_START) ;

  // FOR EDGE DETECT 
  OLD_START := STARTING;

END_PROGRAM]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="PRG" name="CONTROL_LOAD" editor="PAL1131.ST"><![CDATA[PROGRAM CONTROL_LOAD
VAR_EXTERNAL (*$AUTO*) END_VAR

VAR
 
  FUNC_LC               : BOOL;
  LC_ON                 : BOOL; 
  RESET_UNBALANCED_MODE : TON; 
  UNBALANCED_ALM        : BOOL;
  T_UNBALANCED          : TON;
  PUSHB                 : PB_RATE;
  PB_RESET              : TP;
  DELAY_LC              : TON;
  ENABLE_UNBALANCED     : BOOL;
  OLD_SP                : FINT;
    
END_VAR
 
//#############################################################

//************************************************************
//                                                            
// P0631	<6.3.1> ENABLE UNBALANCED MODE                      
// P0632	<6.3.2> LOW PLANT LOAD TO RESET UNBALANCED MODE     
// P0641	<6.4.1> MAX. UNBALANCE DEVIATION IN BALANCED MODE   
// P0642	<6.4.2> LOAD UNBALANCE DELAY IN BALANCED MODE       
//                                                            
//                                                            
// ALM_216	<216> LOAD UNBALANCE                              
//                                                            
//************************************************************ 

  ENABLE_UNBALANCED := FALSE;
  BUS_LS_LOAD_PERC  := DIV0(BUS_LS_KW_LOAD , BUS_LS_KW_POWER) * FINT#100.0;     
  

// LOAD CONTROL ON/OFF  
  IF OR((FUNC=1), (FUNC=2)) THEN      // DG, EM 

    LC_ON := AND(OR(AUTO, MANUAL_FLC), BREAKER) ;                  // AUTO OR HARBOUR (MANUAL+FREQ/LOAD CONTROL)  
               
    DELAY_LC(IN :=LC_ON, PT := T#1s);                              // DELAY TO MAKE SURE 'SHARED' BUS CALCULATIONS ARE UPDATED 

    LOAD_CONTROL := DELAY_LC.Q  ;   
    
    ENABLE_UNBALANCED := AND(BUS_DGX > 1, LOAD_CONTROL, AUTO, FUNC =1, P0631, NOT BUS_SHAFT_SHORE) ;
    
    IF LOAD_CONTROL THEN          // LOAD CONTROL 
    
      IF OFFLOADING THEN      // OFFLOADING 
        
        LOAD_SP        := FINT#0;
        UNBALANCED_ALM := FALSE;      
        
      ELSE

        IF UNBALANCED_MODE THEN                                  // UNBALANCED MODE 
                                                            
          // PUSHBUTTON RATE  
          PUSHB(PB := PB_INCREASE XOR PB_DECREASE, CYCLE := FINT#0.5, RATE2 := 2, RATE3 := 5);
                
          IF PB_INCREASE THEN
            SP_BASE_LOAD := SP_BASE_LOAD + PUSHB.OUT  ;
          ELSIF PB_DECREASE THEN
            SP_BASE_LOAD := SP_BASE_LOAD - PUSHB.OUT  ;
          ELSIF MIMIC_SP_BASE_LOAD <> OLD_SP THEN
            SP_BASE_LOAD := MIMIC_SP_BASE_LOAD;
          END_IF   
                
          SP_BASE_LOAD := HSS(P0632, LSS(FINT#100, SP_BASE_LOAD));           // L/H LIMIT 
                
          LOAD_SP         := SP_BASE_LOAD ;
          UNBALANCED_ALM  := FALSE;
            
        ELSE                                             // NORMAL BALANCED LOAD SHARING 
                              
          LOAD_SP := BUS_LS_LOAD_PERC;              
          UNBALANCED_ALM := OR(_ABS(LOAD_SP - KW_PERC) > P0641, _ABS(BUS_LS_KVAR_PERC - KVAR_PERC) > P0641);
          SP_BASE_LOAD := FINT#-1;
           
          IF AND(OR(PB_INCREASE XOR PB_DECREASE, MIMIC_ENABLED_UNBALANCED_MODE), NOT PB_RESET.Q, ENABLE_UNBALANCED) THEN          //SET UNBALANCED MODE 
              UNBALANCED_MODE := TRUE;
              SP_BASE_LOAD    := KW_PERC ;        // INITIAL BASE LOAD SETPOINT  
          END_IF                      
               
        END_IF  // UNBALANCED_MODE
        
      END_IF   // OFFLOADING
        
    ELSE

      // SETPOINT FOR BUMPLESS TAKE-OVER OF LOAD CONTROL SETPOINT 
      LOAD_SP        :=  BUS_LS_LOAD_PERC;  
      UNBALANCED_ALM := FALSE ;
      SP_BASE_LOAD   := FINT#-1;        

    END_IF  // LOAD CONTROL 
    
    // RESET UNBALANCED MODE 
    IF OR(
          NOT ENABLE_UNBALANCED, 
          PB_RESET.Q, 
          BUS_LS_LOAD_PERC < P0632, 
          RESET_UNBALANCED_MODE.Q,
          MIMIC_DISABLED_UNBALANCED_MODE
          )
    THEN                                        
                
      UNBALANCED_MODE := FALSE;
      SP_BASE_LOAD    := FINT#-1;
     
    END_IF

    // LAMPS 
    LMP_INCREASE := OR(AND(PUSHB.OUT > FINT#0, PB_INCREASE), DO_INC_RPM);  // INCREASE LAMP ON PMS PANEL
    LMP_DECREASE := OR(AND(PUSHB.OUT > FINT#0, PB_DECREASE), DO_DEC_RPM);  // DECREASE LAMP ON PMS PANEL

  ELSE

    UNBALANCED_ALM  := FALSE;
    UNBALANCED_MODE := FALSE;
    SP_BASE_LOAD    := FINT#-1;   
     
  END_IF   // DG, EM 


  PB_RESET(             IN := AND(PB_INCREASE, PB_DECREASE, UNBALANCED_MODE), PT := T#2s);
  RESET_UNBALANCED_MODE(IN:= AND(UNBALANCED_MODE, P0633<>FINT#0),             PT := FINT_TO_SEC(P0633*FINT#60));

  // ALM_216	<216> LOAD UNBALANCED 
  T_UNBALANCED(IN := UNBALANCED_ALM, PT := FINT_TO_SEC(P0642));  
  ALM_216 := T_UNBALANCED.Q;

  // CREAT HISTORY 
  OLD_SP := MIMIC_SP_BASE_LOAD;

END_PROGRAM]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="PRG" name="CONTROL_VOLT" editor="PAL1131.ST"><![CDATA[PROGRAM CONTROL_VOLT
VAR_EXTERNAL (*$AUTO*) END_VAR
 
VAR
 
  FUNC_VC  : BOOL;
  VC_ON    : BOOL;
  PB_RESET : TP;
  DELAY_VC : TON;

END_VAR
 
//#############################################################

  BUS_LS_KVAR_PERC :=  DIV0(BUS_LS_KVAR_LOAD , BUS_LS_KVAR_POWER) * FINT#100.0; 

  // VOLT CONTROL ON/OFF 
  VC_ON :=   AND((AUTO OR MANUAL_FLC), BREAKER, (P0627<>FINT#0));       // AUTO OR HARBOUR (MANUAL+FREQ/LOAD CONTROL) 
    
  DELAY_VC(IN := VC_ON , PT := T#1s);                                   // DELAY TO MAKE SURE 'SHARED' BUS CALCULATIONS ARE UPDATED
  KVAR_CONTROL := DELAY_VC.Q;   
    
  IF KVAR_CONTROL THEN          // VOLT CONTROL
    KVAR_SP       := BUS_LS_KVAR_PERC;              
    VOLT_SETPOINT := FINT#100;
  END_IF

(*          
  // ALM_217	<216> KVAR UNBALANCED 
  IF AND((FUNC=1) OR (FUNC=2), LOAD_CONTROL, NOT OFFLOADING) THEN        
    UNBALANCED_ALM_KVAR := _ABS(KVAR_SP - KVAR_PERC) > P0643;
  ELSE
    UNBALANCED_ALM_KVAR := FALSE;
  END_IF  
    
  T_UNBALANCED(IN:= UNBALANCED_ALM_KVAR , PT:= FINT_TO_SEC(P0644));  
  ALM_217 := T_UNBALANCED.Q ;
*)          

END_PROGRAM]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="PRG" name="CONTROLLERS" editor="PAL1131.ST"><![CDATA[PROGRAM CONTROLLERS
VAR_EXTERNAL (*$AUTO*) END_VAR
 
VAR
 
  SPEED_CONTROL : BOOL;    
    
  F_SP           : FINT;       // USE FREQUENCY PARAMETERS
  F_FB           : FINT;
  F_PB           : FINT;
  F_DB           : FINT;  
  FREQ_CONTROL   : BOOL;
  V_SP           : FINT;       // USE VOLTAGE PARAMETERS
  V_FB           : FINT;
  V_PB           : FINT;
  V_DB           : FINT;  
  VOLT_CONTROL   : BOOL;
  AUTO_INC       : BOOL;
  AUTO_DEC       : BOOL;
    
  T_RESPONSE     : FINT;         // RESPONCE TIME AS FINT
  CONTROL_FREQ   : P_CONTROL;
  CONTROL_VOLT   : P_CONTROL;
 
  CONTROL_KW     : P_CONTROL;    
  CONTROL_KVAR   : P_CONTROL;    

  CONTROL_SPEED  : TAC_CONTROL;
  CONTROL_VLT    : TAC_CONTROL;
  SP_SPDCONT     : FINT;
  SP_VLTCONT     : FINT;
  SYNC_CONTROL   : TOF;
  CONTROL4SYNC   : BOOL;
  RESET_TAC      : R_TRIG ;
    
  ABT_SYNC1      : BOOL;
  SET_BUS_OFFSET : FINT;
       
END_VAR

//########################################################

//**********************************************************
//                                                         
// P0611	<6.1.1> CONTR.SPEED - FREQUENCY - PROP. BAND     
// P0612	<6.1.2> CONTR.SPEED - FREQUENCY - DEAD BAND      
// P0613	<6.1.3> CONTR.SPEED - ACTIVE LOAD - PROP. BAND   
// P0614	<6.1.4> CONTR.SPEED - ACTIVE LOAD - DEAD BAND    
// P0615	<6.1.5> CONTR.SPEED - MIN. PULSE TIME            
// P0616	<6.1.6> CONTR.SPEED - MAX. PULSE TIME/CYCLE TIME 
//                                                         
// P0621	<6.2.1> CONTR.VOLT - VOLTAGE - PROP. BAND        
// P0622	<6.2.2> CONTR.VOLT - VOLTAGE - DEAD BAND         
// P0623	<6.2.3> CONTR.VOLT - REACTIVE LOAD - PROP. BAND  
// P0624	<6.2.4> CONTR.VOLT - REACTIVE LOAD - DEAD BAND   
// P0625	<6.2.5> CONTR.VOLT - MIN. PULSE TIME             
// P0626	<6.2.6> CONTR.VOLT - MAX. PULSE TIME/CYCLE TIME  
//                                                         
//**********************************************************
 
  SYNC_CONTROL(IN := SYNCHRONIZING, PT := T#1s);   // EXTEND FREQ. CONTROL THEREWITH DELAY LOAD CONTROL 
  RESET_TAC(CLK := BREAKER );                      // RESTART TAC CYCLE TIMER WHEN THE BREAKER CLOSES


  IF OR((FUNC=1), (FUNC=2)) THEN        // DG, EM ############################################################

    _SYNC_BUSX[ADDRESS] := 0 ;

    //***************************************************************
    //  FREQUENCY CONTROL                                           
    //***************************************************************
    
    // FIRST CYCLE WHEN CLOSING BREAKER IS FREQUENCY CONTROL ONLY WITH SETP.=NOMINAL FREQ.                   
    // TO PREVENT WAITING FOR CYCLE TO END THAT WAS BEGUN WITH "OLD" DATA                                    
    //** TAC CYCLE IS RESTARTED WHEN BREAKER IS CLOSED => PREVENT DELAY DUE TO UNFINISHED SYNCHRONIZING CYCLE
    //** SHARED BUS CALCULATIONS WILL BE UPDATED&VALID -AND LOAD CONTROL ON- START OF NEXT CYCLE             
    
    FREQ_CONTROL  :=  (
                        SYNC_CONTROL.Q OR     // SYNCHRONIZING
                        LOAD_CONTROL          // LOAD CONTROL
                      ) AND NOT LOCAL ;       // ENABLE FREQUENCY CONTROL
    
    IF FREQ_CONTROL THEN
    
      //  SETPOINTS:  FREQ / FEEDBACK / DEADBAND
        
      F_FB := FREQ_PERC;       // GEN FREQ IN PERCENT
      F_SP := FINT#100;        // DEFAULT
      F_DB := P0612;          
        
      IF BREAKER THEN
                 
        IF AND(BUS_SYNC, OR(AUTO, MANUAL_FLC)) THEN    // CONTROL ALL DG ON BUS TO SYNC BUS
            
          F_SP := BUS_SYNC_FREQ;                 // BUS FREQ. SETP INCL. OFFSET
          F_DB := FINT#0;                        // NO DEADBAND            

        ELSIF OR(BUS_SHAFT_SHORE, OFFLOADING) THEN                  // NO FREQ. CONTROL WITH SHAFT/SHORE CONNECTED

          F_SP := BUSFREQ_PERC;
          F_DB := FINT#0; 

        END_IF
            
      ELSIF SYNCHRONIZING THEN        // SYNCHRONIZING

        IF LIVE_BUS THEN            
          IF SIM_ON_SAMES THEN
            F_SP := BUSFREQ_PERC;
          ELSE
            F_SP := BUSFREQ_PERC + ((IOB_P0513 - IOB_P0512)/FINT#2);    // +OFFSET
          END_IF
          F_DB := FINT#0;               // NO DEADBAND
        END_IF           

      END_IF
    
        
      //  P-CONTROLLER FREQUENCY  
      CONTROL_FREQ(SP := F_SP, FB := F_FB, DB := F_DB, PB := P0611, ENA := AND(FREQ_CONTROL, NOT OFFLOADING));
      SP_SPDCONT := CONTROL_FREQ.OUT ;
    
      //  P-CONTROLLER ACTIVE (KW) LOAD 
      IF AND(LOAD_CONTROL, NOT OR(SYNC_CONTROL.Q, BUS_SYNC)) THEN
         
        CONTROL_KW(SP := LOAD_SP, FB := KW_PERC, DB := P0614, PB := P0613, ENA := LOAD_CONTROL); 
        SP_SPDCONT := SP_SPDCONT + CONTROL_KW.OUT;
    
      END_IF
      
      //***************************************************************
      //  TAC CONTROLLER SPEED  (Time Adjustable Controller)          
      //***************************************************************
      CONTROL_SPEED(SP  := FINT#0,              // ERROR SP =0
                    FB  := SP_SPDCONT,
                    DB  := FINT#0,
                    MIN := P0615,
                    MAX := P0616,
                    ENA := AND(FREQ_CONTROL, NOT OR(RESET_TAC.Q, AND(BUS_ABNORMAL, NOT BREAKER)))    // NOT SYNCHRO TO ABNORMAL GEN
                    );
      AUTO_INC := CONTROL_SPEED.INC;
      AUTO_DEC := CONTROL_SPEED.DEC;
            
    ELSE

      AUTO_INC := FALSE;
      AUTO_DEC := FALSE;
    
    END_IF // FREQ_CONTROL
    
    IF NOT BREAKER THEN 
      LOAD_SETPOINT := FINT#0;
    ELSIF NOT LOAD_CONTROL THEN
      LOAD_SETPOINT := KW_PERC;
    ELSE
      LOAD_SETPOINT := LOAD_SP;
    END_IF
       

    //***************************************************************
    //  INCREASE/DECREASE PULSE OUTPUTS                             
    //***************************************************************  
    IF FREQ_CONTROL THEN
      DO_INC_RPM := AUTO_INC;
      DO_DEC_RPM := AUTO_DEC;
    ELSIF MANUAL THEN 
      DO_INC_RPM := AND(PB_INCREASE, OR(DISP_LOAD_EU = 0, DISP_LOAD_EU = 3));
      DO_DEC_RPM := AND(PB_DECREASE, OR(DISP_LOAD_EU = 0, DISP_LOAD_EU = 3));    
    ELSE 
      DO_INC_RPM := FALSE;
      DO_DEC_RPM := FALSE;  
    END_IF
    
    _SYNC_BUSX[ADDRESS] := 0;
    
  ELSE

    IF SYNC_CONTROL.Q THEN 
   
      SET_BUS_OFFSET := (IOB_P0512 - IOB_P0513) / FINT#2;       // %

      IF OR((FUNC=3), (FUNC=4)) THEN               // SHAFT, SHORE ################################# 

        _SYNC_BUSX[ADDRESS]      := BUS;
        _SYNC_FREQ_SETP[ADDRESS] := FREQ_PERC + SET_BUS_OFFSET;      // %

      ELSE                                       // ABT #################################
      
        IF NOT AND(ABT_NOTSYNC1, ABT_NOTSYNC2) THEN
        
          IF OR(ABT_NOTSYNC1, AND(ABT_DGX2 < ABT_DGX1, NOT ABT_NOTSYNC2))  THEN       // SYNC RIGHT BUS
               
            IF (BUS=GRID) THEN
              _SYNC_BUSX[ADDRESS]    := 1;
            ELSE
              _SYNC_BUSX[ADDRESS]    := BUS + 1;
            END_IF
            _SYNC_FREQ_SETP[ADDRESS] := BUSFREQ_PERC + SET_BUS_OFFSET;    // FREQUENCY OF LEFT BUS %
           
          ELSE   
            // SYNC LEFT BUS
            _SYNC_BUSX[ADDRESS]      := BUS ;         // LEFT BUS NUMBER
            _SYNC_FREQ_SETP[ADDRESS] := FREQ_PERC + SET_BUS_OFFSET;    // FREQUENCY OF RIGHT BUS %           
           
          END_IF

        END_IF
        
      END_IF
      
    ELSE
    
      _SYNC_BUSX[ADDRESS] := 0 ;
      
    END_IF

  END_IF   


  IF OR((FUNC=1), (FUNC=2)) THEN        // DG, EM ############################################################

    //***************************************************************
    //  VOLTAGE CONTROL                                           
    //***************************************************************
    
    // FIRST CYCLE WHEN CLOSING BREAKER IS VOLTAGE CONTROL ONLY WITH SETP.=NOMINAL FREQ.                   
    // TO PREVENT WAITING FOR CYCLE TO END THAT WAS BEGUN WITH "OLD" DATA                                    
    //** TAC CYCLE IS RESTARTED WHEN BREAKER IS CLOSED => PREVENT DELAY DUE TO UNFINISHED SYNCHRONIZING CYCLE
    //** SHARED BUS CALCULATIONS WILL BE UPDATED&VALID -AND LOAD CONTROL ON- START OF NEXT CYCLE             
    
    // P0621	<6.2.1> CONTR.VOLT - VOLTAGE - PROP. BAND        
    // P0622	<6.2.2> CONTR.VOLT - VOLTAGE - DEAD BAND         
    // P0623	<6.2.3> CONTR.VOLT - REACTIVE LOAD - PROP. BAND  
    // P0624	<6.2.4> CONTR.VOLT - REACTIVE LOAD - DEAD BAND   
    // P0625	<6.2.5> CONTR.VOLT - MIN. PULSE TIME             
    // P0626	<6.2.6> CONTR.VOLT - MAX. PULSE TIME/CYCLE TIME  

    VOLT_CONTROL  :=  AND(
                          OR(
                             SYNC_CONTROL.Q,     // SYNCHRONIZING
                             KVAR_CONTROL        // KVAR CONTROL
                             ),
                          NOT LOCAL             // ENABLE VOLTAGE CONTROL
                          );
 
    IF VOLT_CONTROL THEN
    
      //  SETPOINTS:  VOLT / FEEDBACK / DEADBAND
      V_FB := VOLT_PERC;       // GEN VOLT IN PERCENT
      V_SP := FINT#100;        // DEFAULT
      V_DB := P0622;          
        
      IF BREAKER THEN
                 
        IF AND(BUS_SYNC, OR(AUTO, MANUAL_FLC)) THEN    // CONTROL ALL DG ON BUS TO SYNC BUS
            
          V_SP := BUS_SYNC_VOLT;                       // BUS VOLT. SETP
          V_DB := FINT#0;                              // NO DEADBAND            
                                                  
        ELSIF BUS_SHAFT_SHORE THEN                     // NO VOLT. CONTROL WITH SHAFT/SHORE CONNECTED
      
          V_SP := BUSVOLT_PERC;
          V_DB := FINT#0; 
      
        END_IF
            
      ELSIF SYNCHRONIZING THEN        // SYNCHRONIZING

        IF LIVE_BUS THEN            
          V_SP := BUSVOLT_PERC;    // NO OFFSET
          V_DB := FINT#0;          // NO DEADBAND
        END_IF           

      END_IF  //BREAKER
    
      //  P-CONTROLLER VOLTAGE  
      CONTROL_VOLT(SP := V_SP, FB := V_FB, DB := V_DB, PB := P0621, ENA := VOLT_CONTROL);
      SP_VLTCONT := CONTROL_VOLT.OUT;
    
      //  P-CONTROLLER Re-ACTIVE (KVar) LOAD 
      IF AND(KVAR_CONTROL, NOT OR(SYNC_CONTROL.Q, BUS_SYNC)) THEN
         
        CONTROL_KVAR(SP := KVAR_SP, FB := KVAR_PERC, DB := P0624, PB := P0623, ENA := KVAR_CONTROL); 
        SP_VLTCONT := SP_VLTCONT + CONTROL_KVAR.OUT;
    
      END_IF
            
      //***************************************************************
      //  TAC CONTROLLER VOLTAGE  (Time Adjustable Controller)        
      //***************************************************************
      CONTROL_VLT(SP  := FINT#0 ,              // ERROR SP = 0
                  FB  := SP_VLTCONT ,
                  DB  := FINT#0,
                  MIN := P0625,
                  MAX := P0626,
                  ENA := AND(VOLT_CONTROL, NOT OR(RESET_TAC.Q, AND(BUS_ABNORMAL, NOT BREAKER)))    // NOT SYNCHRO TO ABNORMAL GEN
                  );
     
      AUTO_INC := CONTROL_VLT.INC;
      AUTO_DEC := CONTROL_VLT.DEC;

    ELSE   // NO VOLT_CONTROL

      AUTO_INC := FALSE;
      AUTO_DEC := FALSE;
       
    END_IF

    IF NOT BREAKER THEN 
      KVAR_SETPOINT := FINT#0;
    ELSIF NOT KVAR_CONTROL THEN
      KVAR_SETPOINT := KVAR_PERC;
    ELSE
      KVAR_SETPOINT := KVAR_SP;
    END_IF
       

    //***************************************************************
    //  INCREASE/DECREASE PULSE OUTPUTS                             
    //***************************************************************  
    
    IF VOLT_CONTROL THEN
      DO_INC_VOLT := AUTO_INC;
      DO_DEC_VOLT := AUTO_DEC;
    ELSIF MANUAL THEN 
      DO_INC_VOLT := AND(PB_INCREASE, OR(DISP_LOAD_EU = 1, DISP_LOAD_EU = 2));
      DO_DEC_VOLT := AND(PB_DECREASE, OR(DISP_LOAD_EU = 1, DISP_LOAD_EU = 2));    
    ELSE 
      DO_INC_VOLT := FALSE;
      DO_DEC_VOLT := FALSE;  
    END_IF

  END_IF   // DG, EM


  IF OR((FUNC=1), (FUNC=2)) THEN 
    SET_BUS_OFFSET          := (IOB_P0512 - IOB_P0513)/FINT#2;    // %
   _SYNC_VOLT_SETP[ADDRESS] := VOLT_PERC;                         // %
  END_IF
 
END_PROGRAM]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="PRG" name="CONSUMER_BLOCK" editor="PAL1131.ST"><![CDATA[PROGRAM CONSUMER_BLOCK
VAR_EXTERNAL (*$AUTO*) END_VAR
 
VAR
 
  POWER_UP          : BOOL := FALSE; 
  RESERVE_POWER     : FINT;
  PROCESS           : INT := 0;
  TIMER             : TON;
  WAIT_NEXT_REQUEST : TP;           // DELAY BETWEEN REQUESTS ON THIS CONTROLLER 
  WAIT_NEXT_CONTROL : TP;           // KEEP OTHER CONTROLLER WAITING LITTLE LONGER   
  LOWEST_XP         : INT;
  
  PRE_ACC           : BOOL;
  ACC               : BOOL;
  REQ_STB           : BOOL;
       
  CONSUMER_VALID    : BOOL := FALSE;
  OLD_VALID         : BOOL;
  CONSUMER_WAITING  : BOOL := FALSE;
  REQUESTING        : BOOL;
  MY_TURN           : BOOL;
  OTHER_BUSY        : BOOL;
        
  RELEVANT          : BOOL;             
  C                 : INT;        // USED FOR CONSUMER NUMEBR           
  BB                : INT;        // USED FOR CONSUMER BUS 
  B                 : INT;        // USED FOR CONTROLLER BUS 
  XP                : INT;        
  REQ_BUSY          : BUS_DECODE;
  ALTERNATE_REQ     : TCYCLE;

  HVY1_OFF          : TON; 
  HVY2_OFF          : TON; 
  HVY3_OFF          : TON; 
  HVY4_OFF          : TON;        
 
  REQ_PULSE         : ARRAY[1..4] OF BOOL;
  OLD_FUNCOUT       : ARRAY[1..4] OF BOOL;    

END_VAR
 
//######################################################

//******************************************************
//   *** INPUTS ***                                     
//                                                      
// DI_REQHEAVY[1]	   <41> Consumer block Request 1      
// DI_REQHEAVY[2]	   <42> Consumer block Request 2      
// DI_REQHEAVY[3]	   <43> Consumer block Request 3      
// DI_REQHEAVY[4]	   <44> Consumer block Request 4      
//                                                       
//                                                      
// FUNCOUT[1]	<301> CONSUMER BLOCK ACCEPT 1           
// FUNCOUT[2]	<302> CONSUMER BLOCK ACCEPT 2           
// FUNCOUT[3]	<303> CONSUMER BLOCK ACCEPT 3           
// FUNCOUT[4]	<304> CONSUMER BLOCK ACCEPT 4           
//                                                      
//   *** SETTINGS ***                                   
//                                                      
// P08X1[1..4]		<8.X.1> CONSUMER X REQUIRED LOAD        
// P08X2[1..4]		<8.X.2> CONSUMER X REQUIRED GENERATORS  
//******************************************************



// ONLY ALLOW ON *DG, EM OR SHAFT* BECAUSE BUS-TIES ARE OTHERWISE EVALUATED WITH ABT 
// THEREFORE POWER CALCULATIONS FOR OWN BUS WILL NOT BE CORRECT WITH ABT 


  BB := P0801 ; // BUS RELATING HEAVY CONSUMERS 

  // PROCESS HEAVY CONSUMER REQUESTS/ACCEPTS 

  CONSUMER_VALID := AND(BB > 0, BB <= GRID, CONF_HVYCONS AND OR(FUNC=1, FUNC=2, FUNC=3));       // VALID BUS # AND OUTPUT(S) CONFIGURED 

  IF CONSUMER_VALID THEN 

    // IF HEAVY CONSUMERS HAS PULSE INPUT FOR REQUEST ########################################################### 
    IF REQHEAVY_PLS[1] THEN           // HEAVY REQ INPUT WITH RUN FEEDBACK  
      IF DI_REQHEAVY[1] THEN REQ_PULSE[1] := TRUE;  END_IF  // LATCH PULSE INPUT
      IF HVY1_OFF.Q     THEN REQ_PULSE[1] := FALSE; END_IF 
      DI_REQHEAVY[1] := REQ_PULSE[1];
    END_IF    
            
    IF NOT FUNCOUT[1] THEN
      HVY1_OFF(IN := AND(DI_REQHEAVY[1], NOT FUNCOUT[1]), PT := T#120s);          // OFF TIMER - IF NOT GRANTED IN 120 SEC  
    ELSIF AND(FUNCOUT[1], NOT OLD_FUNCOUT[1]) THEN
      HVY1_OFF(IN := FALSE, PT := T#999s);                                        // DUMMY - 1 CYCLE OFF TO RESET TIMER     
    ELSE                                                                          // OFF - WHEN RUN STOP + NO RUN FEEDBACK  
      HVY1_OFF(IN := AND(DI_REQHEAVY[1], NOT DI_REQHEAVY_RUN[1]), PT := FINT_TO_SEC(P0851)); 
    END_IF
    OLD_FUNCOUT[1]:= FUNCOUT[1];

    IF REQHEAVY_PLS[2] THEN           // HEAVY REQ INPUT WITH RUN FEEDBACK  
      IF DI_REQHEAVY[2] THEN REQ_PULSE[2] := TRUE;  END_IF  // LATCH PULSE INPUT
      IF HVY2_OFF.Q     THEN REQ_PULSE[2] := FALSE; END_IF 
      DI_REQHEAVY[2] := REQ_PULSE[2];
    END_IF    
            
    IF NOT FUNCOUT[2] THEN
      HVY2_OFF(IN := AND(DI_REQHEAVY[2], NOT FUNCOUT[2]), PT := T#120s);         // OFF TIMER - IF NOT GRANTED IN 120 SEC  
    ELSIF AND(FUNCOUT[2], NOT OLD_FUNCOUT[2]) THEN
      HVY2_OFF(IN := FALSE, PT := T#999s);                                       // DUMMY - 1 CYCLE OFF TO RESET TIMER     
    ELSE                                                                         // OFF - WHEN RUN STOP + NO RUN FEEDBACK  
      HVY2_OFF(IN := AND(DI_REQHEAVY[2], NOT DI_REQHEAVY_RUN[2]), PT := FINT_TO_SEC(P0851)); 
    END_IF
    OLD_FUNCOUT[2]:= FUNCOUT[2];
  
    IF REQHEAVY_PLS[3]  THEN            // HEAVY REQ INPUT WITH RUN FEEDBACK  
      IF DI_REQHEAVY[3] THEN REQ_PULSE[3] := TRUE;  END_IF  // LATCH PULSE INPUT             
      IF HVY3_OFF.Q     THEN REQ_PULSE[3] := FALSE; END_IF 
      DI_REQHEAVY[3] := REQ_PULSE[3];
    END_IF     
            
    IF NOT FUNCOUT[3] THEN
      HVY3_OFF(IN := AND(DI_REQHEAVY[3], NOT FUNCOUT[3]), PT := T#120s);         // OFF TIMER - IF NOT GRANTED IN 120 SEC  
    ELSIF AND(FUNCOUT[3], NOT OLD_FUNCOUT[3]) THEN
      HVY3_OFF(IN := FALSE, PT := T#999s);                                       // DUMMY - 1 CYCLE OFF TO RESET TIMER     
    ELSE                                                                         // OFF - WHEN RUN STOP + NO RUN FEEDBACK  
      HVY3_OFF(IN := AND(DI_REQHEAVY[3], NOT DI_REQHEAVY_RUN[3]), PT := FINT_TO_SEC(P0851)); 
    END_IF

    OLD_FUNCOUT[3]:= FUNCOUT[3];
  
    IF REQHEAVY_PLS[4]  THEN            // HEAVY REQ INPUT WITH RUN FEEDBACK  
      IF DI_REQHEAVY[4] THEN REQ_PULSE[4] := TRUE;  END_IF  // LATCH PULSE INPUT
      IF HVY4_OFF.Q     THEN REQ_PULSE[4] := FALSE; END_IF 
      DI_REQHEAVY[4] := REQ_PULSE[4];
    END_IF      
            
    IF NOT FUNCOUT[4] THEN
      HVY4_OFF(IN := AND(DI_REQHEAVY[4], NOT FUNCOUT[4]), PT := T#120s);          // OFF TIMER - IF NOT GRANTED IN 120 SEC  
    ELSIF AND(FUNCOUT[4], NOT OLD_FUNCOUT[4]) THEN
      HVY4_OFF(IN := FALSE, PT := T#999s);                                        // DUMMY - 1 CYCLE OFF TO RESET TIMER     
    ELSE                                                                          // OFF - WHEN RUN STOP + NO RUN FEEDBACK  
      HVY4_OFF(IN := AND(DI_REQHEAVY[4], NOT DI_REQHEAVY_RUN[4]), PT := FINT_TO_SEC(P0851)); 
    END_IF
    OLD_FUNCOUT[4]:= FUNCOUT[4];    

    REQUESTING :=  OR(DI_REQHEAVY[1],  DI_REQHEAVY[2], DI_REQHEAVY[3], DI_REQHEAVY[4]);

    IF REQUESTING THEN

      // CALCULATE LOAD / POWER FOR BUS OF HEAVY CONSUMERS ########################################################### 
      IF  BB = BUS THEN          // ALREADY CALCULATED WITH BUS_CALCULATE 
    
        CONSUMER_DGX   := BUS_DGX;
        CONSUMER_POWER := BUS_KW_POWER;
        CONSUMER_LOAD  := BUS_KW_LOAD;
    
      ELSE                       // OTHER BUS 

        CONSUMER_DGX   := 0;
        CONSUMER_POWER := FINT#0;
        CONSUMER_LOAD  := FINT#0;
    
        FOR XP := 1 TO MAXXP DO
        
          IF XP_VALID[XP]  THEN         // VERIFY THAT XP IS VALID   
        
            // THIS LOOP SIGNALS CAN ONLY COME FROM ... => REDUCE CALCULATIONS  
            IF OR(
                  _FUNC[XP] = 1,         // DIESEL GENERATOR 
                  _FUNC[XP] = 2,         // EMERGENCY GENERATOR 
                  _FUNC[XP] = 3          // SHAFT GENERATOR
                  ) 
            THEN 
            
              B        := _BUS[XP];
              RELEVANT := BUSADD(BB, B);                          // IS THIS RELEVANT BUS OR BT CONNECTED BUS ? 
                    
              IF RELEVANT THEN                                    // ADD THIS CONTROLLER'S VARIABLES TO BUS VARIABLES 
                     
                CONSUMER_DGX   := CONSUMER_DGX   + BOOL_TO_INT(_BREAKER[XP]);    
                CONSUMER_POWER := CONSUMER_POWER + _KW_POWER[XP];
                CONSUMER_LOAD  := CONSUMER_LOAD  + _KW_LOAD[XP];
                  
              END_IF  // RELEVANT
            END_IF // DG OR EG OR SG
          END_IF  // VERIFY THAT XP IS VALID
        END_FOR 
      END_IF  // ALREADY CALCULATED WITH BUS_CALCULATE


      // CHECK IF ANY CONSUMER IS WAITING ON THIS BOARD 
      CONSUMER_WAITING := FALSE;                          
      C                := 1;
      REPEAT
        IF AND(DI_REQHEAVY[C], NOT FUNCOUT[C]) THEN CONSUMER_WAITING := TRUE; END_IF
        C := C + 1 ;
      UNTIL OR(CONSUMER_WAITING, C > 4) END_REPEAT
    
      // CHECK IF OTHER REQUESTS ON SAME BUS ARE WAITING/BUSY 
      IF CONSUMER_WAITING THEN

        LOWEST_XP  := 99;
        OTHER_BUSY := FALSE;
        FOR XP := 1 TO MAXXP DO
          IF XP_VALID[XP] THEN         // VERIFY THAT XP IS VALID   
            REQ_BUSY(CODE:= _HVY_REQ_BUSY[XP]);
            IF AND(REQ_BUSY.BUS = BB, XP <> ADDRESS) THEN                     // OTHER WAITING 
              IF REQ_BUSY.BIT THEN                                            
                IF NOT OTHER_BUSY THEN OTHER_BUSY := TRUE;  END_IF           // SET: OTHER BUSY 
              END_IF
              IF (XP < LOWEST_XP) THEN      
                LOWEST_XP := XP;                                              // ADDRESS OF 'LOWEST' WAITING BOARD 
              END_IF
            END_IF
          END_IF
        END_FOR
    
        MY_TURN := AND(OR(ADDRESS < LOWEST_XP, PROCESS > 0, WAIT_NEXT_CONTROL.Q), NOT OTHER_BUSY);

      
        IF MY_TURN THEN
  
          // PROCESS EACH REQUEST SEQUENTIALLY  ######################################################################### 
          IF AND(PROCESS = 0, NOT WAIT_NEXT_REQUEST.Q) THEN       // FIND NEXT REQUEST WHEN NOT ALREADY BUSY 
        
            PRE_ACC := FALSE;           // INIT 
            ACC     := FALSE;
            REQ_STB := FALSE;
          
            C := 1;
            REPEAT 
              IF DI_REQHEAVY[C] AND NOT FUNCOUT[C] THEN PROCESS := C; END_IF // HIGHEST PRIORITY REQUEST TO PROCESS 
               C := C + 1;
            UNTIL OR(PROCESS > 0, C > 4) END_REPEAT
          END_IF
        
          // SET ACCEPT OUTPUTS 
          IF (PROCESS > 0) THEN                  
        
            RESERVE_POWER    := CONSUMER_POWER - CONSUMER_LOAD;  
          
            PRE_ACC          := AND(RESERVE_POWER > P08X1[PROCESS], CONSUMER_DGX >= P08X2[PROCESS]);        
            ACC              := AND(PRE_ACC, TIMER.Q);
            REQ_STB          := DI_REQHEAVY[PROCESS] AND NOT PRE_ACC;
          
            FUNCOUT[PROCESS] := ACC;  
          
            IF FUNCOUT[PROCESS] THEN     // RESET FOR PROCESSING NEXT REQUEST  
              PROCESS := 0;
              REQ_STB := FALSE;
            END_IF     
        
          END_IF

        END_IF   // END: MY_TURN 
    
      ELSE

        PRE_ACC := FALSE;
        ACC     := FALSE;
        REQ_STB := FALSE;
      
      END_IF   // END: CONSUMER WAITING 

    ELSE

      PRE_ACC                    := FALSE;
      ACC                        := FALSE;
      REQ_STB                    := FALSE;  
      _STBYREQ_HVY_BUSX[ADDRESS] := 0;
      _HVY_REQ_BUSY[ADDRESS]     := 0;
      CONSUMER_WAITING           := FALSE;

    END_IF     // END: REQUESTING/ANY REQUEST 
  
    TIMER(IN := PRE_ACC , PT := FINT_TO_SEC(P0802)); 
  
    // WAIT BETWEEN REQUESTS TO ENSURE THAT ALL POWER CALCULATIONS ARE UP-TO-DATE AFTER CONNECTING GENERATOR 
    // IF NOT WAIT LONG ENOUGH A NEXT GENERATOR WILL UNINTENDED BE STARTED ON THE "PRE-CONNECT" CALCULATIONS (AFTER WHICH IT WILL AUTO STOP AGAIN)  
    // MAKE SURE OTHER CONTROLLERS WAIT LITTLE LONGER TO ENSURE THAT FIRST ALL REQUESTS ON THIS CONTROLLER ARE FINISHED  
    WAIT_NEXT_REQUEST(IN := PROCESS = 0 , PT := T#5s); 
    WAIT_NEXT_CONTROL(IN := PROCESS = 0 , PT := T#8s); 
   
    // STANDBY REQUEST / INH LL-STOP TO OTHER XP   
    ALTERNATE_REQ(START := REQ_STB, PULSE := T#3s, CYCLE := T#5s);
  
    IF REQUESTING THEN 
      _STBYREQ_HVY_BUSX[ADDRESS] := BB * 10;          // BUS X 10 => USED FOR INH LOW LOAD STOP OF THIS BUS  
   
      IF ALTERNATE_REQ.Q THEN
        _STBYREQ_HVY_BUSX[ADDRESS] := _STBYREQ_HVY_BUSX[ADDRESS] + 1;  // ADD 1 => REQUEST STANDBY GENERATOR 
      END_IF

    ELSE

      _STBYREQ_HVY_BUSX[ADDRESS] := 0;

    END_IF
  
    // GIVE REQUESTS WAITING/BUSY TO BUS 
    IF CONSUMER_WAITING THEN
      _HVY_REQ_BUSY[ADDRESS] := BB * 10;
      IF MY_TURN THEN _HVY_REQ_BUSY[ADDRESS] := _HVY_REQ_BUSY[ADDRESS] + 1; END_IF
    ELSE
      _HVY_REQ_BUSY[ADDRESS] := 0;
    END_IF 
  
   // SET / RESET OUTPUTS 
    FOR C := 1 TO 4 DO

      IF OR(NOT DI_REQHEAVY[C], AND(CONSUMER_DGX < P08X2[C], PROCESS<>C)) THEN   // RESET OUTPUTS IF REQUEST OFF OR NUMBER OF GENS BECAME TOO LOW  
        FUNCOUT[C] := FALSE;
        IF C = PROCESS THEN PROCESS := 0; END_IF   // REQUEST INTERRUPTED
      END_IF
  
    END_FOR  

  ELSIF OLD_VALID THEN                // RESET ONCE 

    FOR  C:= 1 TO 4 DO FUNCOUT[C] := FALSE; END_FOR
    _STBYREQ_HVY_BUSX[ADDRESS] := 0;
    _HVY_REQ_BUSY[ADDRESS]     := 0;

  END_IF       // END: CONSUMER VALID     
  
 
  OLD_VALID := CONSUMER_VALID;     
    
END_PROGRAM]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="PRG" name="NONPREF_TRIP" editor="PAL1131.ST"><![CDATA[PROGRAM NONPREF_TRIP
VAR_EXTERNAL (*$AUTO*) END_VAR

VAR
 
  BB           : INT;
  XP           : INT;
  N            : INT;
  B            : INT;
  BUSLOAD      : FINT;
  TRIPALL      : BOOL;
  
  RELEVANT     : BOOL;
  DGX          : INT;             
  POWER        : FINT;
  LOAD         : FINT;  
    
  TRIP1        : BOOL;  
  TRIP2        : BOOL;  
  TRIP3        : BOOL;  
  TRIP4        : BOOL;  
                         
  T1           : TON;
  T2           : TON;
  T3           : TON;
  T4           : TON;
                 
  P1           : TP;
  P2           : TP;
  P3           : TP;
  P4           : TP;
    
  POWER_UP     : BOOL := FALSE;  
  ABN_PREF_REQ : BOOL; 

END_VAR
 
//######################################################

//******************************************************
//                                                      
//   *** GLOBAL ARRAY OF OUTPUTS ***                    
//                                                      
// FUNCOUT[11]	<311> NON-PREFERENTIAL TRIP 1 (OUTP)    
// FUNCOUT[12]	<312> NON-PREFERENTIAL TRIP 2 (OUTP)    
// FUNCOUT[13]	<313> NON-PREFERENTIAL TRIP 3 (OUTP)    
// FUNCOUT[14]	<314> NON-PREFERENTIAL TRIP 4 (OUTP)    
// FUNCOUT[15]	<315> NON-PREFERENTIAL TRIP 5 (OUTP)    
// FUNCOUT[16]	<316> NON-PREFERENTIAL TRIP 6 (OUTP)    
// FUNCOUT[17]	<317> NON-PREFERENTIAL TRIP 7 (OUTP)    
// FUNCOUT[18]	<318> NON-PREFERENTIAL TRIP 8 (OUTP)    
//                                                      
//   *** SETTINGS ***                                   
// P0743  <7.4.3> STANDBY START REQUEST WITH TRIP       
//                                                      
// P0901  <9.0.1> BUS NUMBER OF NON. PREF. TRIPS        
// P0911  <9.1.1> NON.PREF 1 LOAD H-LIMIT TO TRIP       
// P0912  <9.1.2> NON.PREF 1 TRIP DELAY                 
// P0913  <9.1.3> NON.PREF 1 ID NAME (5 CHAR.)          
// P0921  <9.2.1> NON.PREF 2 LOAD H-LIMIT TO TRIP       
// P0922  <9.2.2> NON.PREF 2 TRIP DELAY                 
// P0923  <9.2.3> NON.PREF 2 ID NAME (5 CHAR.)          
// P0931  <9.3.1> NON.PREF 3 LOAD H-LIMIT TO TRIP       
// P0932  <9.3.2> NON.PREF 3 TRIP DELAY                 
// P0933  <9.3.3> NON.PREF 3 ID NAME (5 CHAR.)          
// P0941  <9.4.1> NON.PREF 4 LOAD H-LIMIT TO TRIP       
// P0942  <9.4.2> NON.PREF 4 TRIP DELAY                 
// P0943  <9.4.3> NON.PREF 4 ID NAME (5 CHAR.)          
//                                                      
//******************************************************


  _STBYREQ_TRP_BUSX[ADDRESS] := 0;

  IF OR((FUNC=1), (FUNC=2), (FUNC=3)) THEN        // DG, EM, SHAFT 

    // ONLY ALLOW ON *DG, EM OR SHAFT* BECAUSE BUS-TIES ARE OTHERWISE EVALUATED WITH ABT 
    // THERFORE POWER CALCULATIONS FOR OWN BUS WILL NOT BE CORRECT WITH ABT 


    // DISTRIBUTE => REQUEST TRIP OF ALL NON. PREF GROUPS ON BUS X WITH ANY CB TRIP
    IF AND(CB_TRIPPED_ANY, BUS_DGX <> 0) THEN           // ONLY WITH TRIP WHEN > 1x DG ONLINE
      _TRIP_GRP_BUSX[ADDRESS] := BUS;
    ELSE
      _TRIP_GRP_BUSX[ADDRESS] := 0;
    END_IF
    // REQUEST TERASAKI ONLY LOCAL TRIP >> THEY USE COMMON OUTPUT FOR ALL DG'S     
    
    //*******************************************
    // CALCULATE LOAD FOR BUS OF NON-PREF GROUPS 
    //*******************************************
    BB      := P0901;                    // BUS RELATING NON-PREFERENT TRIPS 
        
    BUSLOAD := FINT#0;
  
    // PROCESS NON-PREFERENT TRIPS 
    IF AND(BB > 0, BB <= GRID, ANY_NONPREF) THEN      // VALID BUS # AND OUTPUT(S) CONFIGURED 
    
      ABN_PREF_REQ := AND(OR(ABN_PREF_REQ, ABN_TRIP_REQ), NOT RESET);                                                      // LATCH TRIP REQUEST WITH ABNORMAL 
      TRIPALL      := OR(_TRIP_GRP_BUSX[ADDRESS] = BB, DI_FORCE_PREF_TRIP, DI_FORCE_PREF_TRIP_START_STBY, ABN_PREF_REQ) ;  // LOCAL TRIP OR FORCE WITH DI
    
      // CHECK ALL XP FOR COMMAND OF TRIP OF NON. PREF 
      IF NOT TRIPALL THEN
        FOR XP := 1 TO MAXXP DO
          IF XP_VALID[XP] THEN         // VERIFY THAT XP IS VALID   
            IF AND(_TRIP_GRP_BUSX[XP] > 0, _TRIP_GRP_BUSX[XP] <= GRID, NOT TRIPALL) THEN    // VALID COMMAND 
              RELEVANT := BUSADD(BUS, _TRIP_GRP_BUSX[XP]);                                // BUS NUMBER OF GROUPS TO TRIP 
              IF RELEVANT THEN TRIPALL := TRUE; EXIT;  END_IF  
            END_IF
          END_IF
        END_FOR     
      END_IF
    
      IF NOT TRIPALL THEN        // SKIP LOAD CALCULATIONS IF TRIPALL 
        
        // CALCULATE LOAD / POWER FOR BUS OF NON-PREFERENT TRIPS 
        IF    BB = BUS THEN            // ALREADY CALCULATED WITH BUS_CALCULATE 
            
          DGX   := BUS_DGX;   
          POWER := BUS_KW_POWER;
          LOAD  := BUS_KW_LOAD;
        
        ELSIF BB = P0801  THEN      // ALREADY CALCULATED WITH HEAVY CONSUMERS 
            
          DGX   := CONSUMER_DGX ;   
          POWER := CONSUMER_POWER;
          LOAD  := CONSUMER_LOAD;    
            
        ELSE                       // OTHER BUS 

          DGX   := 0;
          POWER := FINT#0;
          LOAD  := FINT#0;
            
          FOR XP := 1 TO MAXXP DO
                
            IF XP_VALID[XP]  THEN         // VERIFY THAT XP IS VALID   
              
              // THIS LOOP SIGNALS CAN ONLY COME FROM ... => REDUCE CALCULATIONS  
              IF OR(_FUNC[XP] = 1,         // DIESEL GENERATOR 
                    _FUNC[XP] = 2,         // EMERGENCY GENERATOR 
                    _FUNC[XP] = 3          // SHAFT GENERATOR
                    )
              THEN 
                    
                B := _BUS[XP];
                           
                RELEVANT := BUSADD(BB, B);                          // IS THIS RELEVANT BUS OR BT CONNECTED BUS ? 
                            
                IF RELEVANT THEN                                    // ADD THIS CONTROLLER'S VARIABLES TO BUS VARIABLES 
        
                  DGX   := DGX   + BOOL_TO_INT(_BREAKER[XP]);                        
                  POWER := POWER + _KW_POWER[XP];
                  LOAD  := LOAD  + _KW_LOAD[XP];
                          
                END_IF 
              END_IF
            END_IF
          END_FOR 
        END_IF
           
            
        // LOAD PERCENTAGE 
        BUSLOAD := DIV0(LOAD, POWER) * FINT#100;     // PERCENT LOAD OF NON-PREF. BUS 
    
      END_IF
    END_IF
            
    // NON-PREF TRIP 1 
    
    T1(IN := (BUSLOAD> P0911)AND GTZ(P0911), PT := FINT_TO_SEC(P0912));        // DELAY 
    P1(IN := OR(T1.Q, TRIPALL),              PT := T#5s);                      // PULSE 
    FUNCOUT[11] := AND(OR(T1.Q, P1.Q, AND(P0166, ALM_254)), CONF_NONPREF[1]);  // TRIP OUTPUT 
    ALM_281     := FUNCOUT[11] ;
    
    // NON-PREF TRIP 2 
    
    T2(IN := (BUSLOAD> P0921)AND GTZ(P0921), PT := FINT_TO_SEC(P0922));        // DELAY 
    P2(IN := OR(T2.Q, TRIPALL),              PT := T#5s);                      // PULSE 
    FUNCOUT[12] := AND(OR(T2.Q, P2.Q, AND(P0166, ALM_254)), CONF_NONPREF[2]);  // TRIP OUTPUT 
    ALM_282     := FUNCOUT[12] ;
    
    // NON-PREF TRIP 3 
    
    T3(IN := (BUSLOAD> P0931)AND GTZ(P0931), PT := FINT_TO_SEC(P0932));        // DELAY 
    P3(IN := OR(T3.Q, TRIPALL),              PT := T#5s);                      // PULSE 
    FUNCOUT[13] := AND(OR(T3.Q, P3.Q, AND(P0166, ALM_254)), CONF_NONPREF[3]);  // TRIP OUTPUT 
    ALM_283     := FUNCOUT[13] ;
    
    // NON-PREF TRIP 4 
    
    T4(IN := (BUSLOAD> P0941)AND GTZ(P0941), PT := FINT_TO_SEC(P0942));        // DELAY 
    P4(IN := OR(T4.Q, TRIPALL),              PT := T#5s);                      // PULSE 
    FUNCOUT[14] := AND(OR(T4.Q, P4.Q, AND(P0166, ALM_254)), CONF_NONPREF[4]);  // TRIP OUTPUT 
    ALM_284     := FUNCOUT[14] ;

    // DISTRIBUTE => STANDBY REQUEST ON BUS X BECAUSE TRIP OF NON.PREF. GROUP  
    IF P0742 THEN 
      IF OR(T1.Q, T2.Q, T3.Q, T4.Q) THEN _STBYREQ_TRP_BUSX[ADDRESS] := BB; END_IF
    END_IF

  ELSIF NOT POWER_UP THEN

    FOR N:= 11 TO 14 DO FUNCOUT[N] :=  FALSE; END_FOR
    _TRIP_GRP_BUSX[ADDRESS] := 0;
    POWER_UP                := TRUE;
    
  END_IF

END_PROGRAM]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="PRG" name="GROUP_ALARMS" editor="PAL1131.ST"><![CDATA[PROGRAM GROUP_ALARMS
 VAR_EXTERNAL (*$AUTO*) END_VAR
 
VAR

 
END_VAR
 
//###################################################### 


// GROUPED ALARMS 
GRPOUT[1]   :=   OR( ALM_201,
                     ALM_202,
                     ALM_203,           		
                     ALM_204,
                     ALM_205);              // <101> ENGINE ALARM 

GRPOUT[2]   :=   OR( ALM_211,
                     ALM_212,
                     ALM_213,           		
                     ALM_214,
                     IOB_ALM_215,
                     ALM_216);              // <102> FAILED OPERATION       		
           
GRPOUT[3]   :=   OR( IOB_ALM_221, 
                     IOB_ALM_222,
                     IOB_ALM_223,           		
                     IOB_ALM_224,
                     IOB_ALM_225,
                     IOB_ALM_226,           	
                     ALM_227,
                     ALM_228,           		
                     _ALM229[ADDRESS]);              // <103> CB TRIPPED 
           
GRPOUT[4]   :=   OR( IOB_ALM_221, 
                     IOB_ALM_222);              // <104> VOLTAGE TRIP CB 
           
GRPOUT[5]   :=   OR( IOB_ALM_223, 
                     IOB_ALM_224);	          // <105> FREQUENCY TRIP CB 
       
GRPOUT[6]   :=   OR( ALM_241,
                     ALM_242);	          // <106> BUS VOLTAGE ABNORMAL 
           
GRPOUT[7]   := OR( ALM_243,
                   ALM_244);	          // <107> BUS FREQUENCY ABNORMAL 
           
GRPOUT[8]   :=  OR( ALM_241,
                    ALM_242,
                    ALM_243,
                    ALM_244); 	          // <108> BUS ABNORMAL 
                   
GRPOUT[9]   :=  OR( ALM_251,
                    ALM_252,
                    ALM_253,
                    ALM_254);	          // <109> BUS ALARM  
           
GRPOUT[10]  :=  OR( ALM_261,
                    ALM_262);              // <110> BUS-TIE TRIPPED 
           
GRPOUT[11]  :=  OR( IOB_ALM_271,
                    IOB_ALM_272,
                    IOB_ALM_273,
                    IOB_ALM_274,
                    IOB_ALM_275,
                    IOB_ALM_276);          // <111> PHASE/FREQ ERROR 

GRPOUT[12]  :=  OR( ALM_281, 
                    ALM_282,
                    ALM_283,           		
                    ALM_284);              // <112> NON-PREFERENTIAL TRIP 

GRPOUT[13]  :=  OR( ALM_502, 
                    ALM_503,
                    ALM_504,
                    ALM_505,
                    ALM_506,                    		
                    ALM_507);              // <113> SYSTEM NOT HEALTHY 

// ON SYSTEM FAULT RELAY 
ALM_500 :=  GRPOUT[13];

// CRITICAL ALARM: BLOCKING OPERATOR ACTIONS 
CRITICAL_ALARM :=  OR( GRPOUT[1],
                       GRPOUT[2],
                       GRPOUT[3],
                       GRPOUT[4],
                       GRPOUT[5],
                       GRPOUT[6],
                       GRPOUT[7],
                       GRPOUT[8],
                       GRPOUT[9],
                       GRPOUT[11]);

// ANY ALARM = GRPOUT[0] => CONDITIONS FOR ALARM LAMP STEADY ONLY 

GRPOUT[0]  :=  OR(CRITICAL_ALARM,
                  GRPOUT[10],
                  GRPOUT[12],
                  ALM_231
                  );

// ALARM LAMP ON PMS PANEL

IF GRPOUT[0] THEN 
  LMP_ALARM := TRUE;
ELSIF OR(GRPOUT[13], ALM_501) THEN           // SYSTEM FAULT 
  LMP_ALARM := FLASH_FAST; 
ELSIF ALM_291 THEN                        // BLACKOUT 
  LMP_ALARM := FLASH_SLOW;   
ELSE
  LMP_ALARM := FALSE;  
END_IF  

// ANY ALARM = GRPOUT[0] => REMAINING CONDITIONS 

GRPOUT[0]  :=  OR( GRPOUT[0],
                   GRPOUT[13], 
                   ALM_501,
                   ALM_291);


END_PROGRAM]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="PRG" name="OUTPUTS" editor="PAL1131.ST"><![CDATA[PROGRAM OUTPUTS
VAR_EXTERNAL (*$AUTO*) END_VAR
 
VAR
 
  D      : INT;
  E      : INT;
  N      : INT;
  ALMOUT : ARRAY[1..99] OF BOOL;      // DOUT CODE + 200 

END_VAR

//########################################################

// P032X[1..8] =                 
// <3.2.1> DOUT15 - OUTPUT CODE  
// <3.2.2> DOUT16 - OUTPUT CODE  
// <3.2.3> DOUT17 - OUTPUT CODE  
// <3.2.4> DOUT18 - OUTPUT CODE  
// <3.2.5> DOUT19 - OUTPUT CODE  
// <3.2.6> DOUT20 - OUTPUT CODE  
// <3.2.7> DOUT21 - OUTPUT CODE  
// <3.2.8> DOUT22 - OUTPUT CODE  


  FUNCOUT[33] := BREAKER;


  // MAKE ARRAY OF ALARMS ON OUTPUTS 
  ALMOUT[1]  := ALM_201;
  ALMOUT[2]  := ALM_202;
  ALMOUT[3]  := ALM_203;
  ALMOUT[4]  := ALM_204;
  ALMOUT[11] := ALM_211;
  ALMOUT[12] := ALM_212;
  ALMOUT[13] := ALM_213;
  ALMOUT[14] := ALM_214;
  ALMOUT[15] := IOB_ALM_215;
  ALMOUT[16] := ALM_216;
  ALMOUT[21] := IOB_ALM_221;
  ALMOUT[22] := IOB_ALM_222;
  ALMOUT[23] := IOB_ALM_223;
  ALMOUT[24] := IOB_ALM_224;
  ALMOUT[25] := IOB_ALM_225;
  ALMOUT[26] := IOB_ALM_226;
  ALMOUT[27] := ALM_227;
  ALMOUT[28] := ALM_228;
  ALMOUT[29] := _ALM229[ADDRESS];
  ALMOUT[31] := ALM_231;
  ALMOUT[41] := IND241;      // ALSO ACTIVE IF NOT ONLINE - NON LATCHING 
  ALMOUT[42] := IND242;      // ALSO ACTIVE IF NOT ONLINE - NON LATCHING 
  ALMOUT[43] := IND243;      // ALSO ACTIVE IF NOT ONLINE - NON LATCHING 
  ALMOUT[44] := IND244;      // ALSO ACTIVE IF NOT ONLINE - NON LATCHING 
  ALMOUT[51] := IND251;      // ALSO ACTIVE IF NOT ONLINE - NON LATCHING 
  ALMOUT[52] := IND252;      // ALSO ACTIVE IF NOT ONLINE - NON LATCHING 
  ALMOUT[53] := IND253;      // ALSO ACTIVE IF NOT ONLINE - NON LATCHING 
  ALMOUT[54] := IND254;      // ALSO ACTIVE IF NOT ONLINE - NON LATCHING 
  ALMOUT[61] := ALM_261;
  ALMOUT[62] := ALM_262;
  ALMOUT[71] := IOB_ALM_271;
  ALMOUT[72] := IOB_ALM_272;
  ALMOUT[73] := IOB_ALM_273;
  ALMOUT[74] := IOB_ALM_274;
  ALMOUT[75] := IOB_ALM_275;
  ALMOUT[76] := IOB_ALM_276;
  ALMOUT[81] := ALM_281;
  ALMOUT[82] := ALM_282;
  ALMOUT[83] := ALM_283;
  ALMOUT[84] := ALM_284;
  ALMOUT[91] := ALM_291;


  // INIT 

  CONF_HVYCONS := FALSE;
  CONF_AVR     := FALSE;
  CONF_PRELUB  := FALSE;
  ANY_NONPREF  := FALSE;  
  FOR D:=1 TO 4 DO CONF_NONPREF[D] := FALSE; END_FOR 

  // DECODE OUTPUTS 
  IF P0627<>FINT#0 THEN              // 1..6 OUTPUTS, OUTPUT 7&8 ARE RESERVED FOR KVAR/VOLTAGE CONTROL 
    E:=6;
    OPT_DOUT[7]  := DO_INC_VOLT;     
    OPT_DOUT[8]  := DO_DEC_VOLT;
  ELSE
    E:=8;                         // 1..8 OUTPUTS 
  END_IF

  FOR D:=1 TO E DO                 // 1..8 OUTPUTS 

    IF P032X[D] = 0 THEN                   // DOUT NOT USED 

      OPT_DOUT[D] := FALSE;    
    
    ELSE
   
      IF P032X[D] >= 300 THEN              // FUNCTION OUTPUTS 

        N :=  P032X[D] - 300 ;
        OPT_DOUT[D] :=  FUNCOUT[N];
            
        IF AND(P032X[D] >= 301, P032X[D] <= 304) THEN
          CONF_HVYCONS := TRUE;           // HEAVY CONSUMERS ARE CONFIGURED 
        ELSIF AND(P032X[D] >= 311, P032X[D] <= 314) THEN
          ANY_NONPREF := TRUE; 
          CONF_NONPREF[(P032X[D] - 310)] := TRUE;           // WHICH NON-PREF GROUPS ARE CONFIGURED 
        ELSIF OR(P032X[D] = 321, P032X[D] = 322)  THEN
          CONF_AVR     := TRUE;
        ELSIF (P032X[D] = 331) THEN
          CONF_PRELUB  := TRUE;
        END_IF
         

      ELSIF P032X[D] >= 200  THEN          // ALARM OUTPUTS 

        N :=  P032X[D] - 200 ;
        OPT_DOUT[D] :=  ALMOUT[N] ;

      ELSIF P032X[D] >= 100  THEN                                // GROUPED ALARM OUTPUTS  CODES 1..200 

        N :=  P032X[D] - 100 ;
        OPT_DOUT[D] :=  GRPOUT[N] ;
       
      END_IF

    END_IF

  END_FOR

END_PROGRAM]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="PRG" name="DISPLAY" editor="PAL1131.ST"><![CDATA[PROGRAM DISPLAY
VAR_EXTERNAL (*$AUTO*) END_VAR
 
VAR
 
  SEL_ALM_PAGE  : R_TRIG;
  SEL_ALM_PAGE2 : R_TRIG;
  SEL_MENU_PAGE : R_TRIG;
  SEL_LEFT      : R_TRIG;
  SEL_RIGHT     : R_TRIG;
  TIME_OUT_ALM  : TON;

END_VAR
 
//#################################################################################
//  DISPLAY SELECTIONS                                                             
//#################################################################################

  CASE FUNC OF
  1..3:  PMS_DISPLAY := 0;         // 0 = MAIN PAGE: GENERATOR DISPLAY 
     5:  PMS_DISPLAY := 1;         // 1 = MAIN PAGE: ABT 
     4:  PMS_DISPLAY := 2;         // 2 = MAIN PAGE: SHORE 
  END_CASE

  SEL_ALM_PAGE( CLK := PB_ALARM );                        // UP EDGE 
  SEL_ALM_PAGE2(CLK := NEXT_ALARM);                      // UP EDGE 
  SEL_MENU_PAGE(CLK := PB_MENU);                      // UP EDGE 
  TIME_OUT_ALM(IN:= AND(TYPE_DISPLAY=1, NOT OR(PB_UP, PB_DOWN)) , PT := T#30s);      // TIME-OUT ALARM PAGE 

  IF TYPE_DISPLAY=1 THEN                              // 1 = ALARM PAGE 
    IF OR(SEL_ALM_PAGE.Q, TIME_OUT_ALM.Q) THEN        
      TYPE_DISPLAY := 0 ;                           // 0 = MAIN PAGE 
    END_IF
  ELSIF OR(SEL_ALM_PAGE.Q, SEL_ALM_PAGE2.Q) THEN
    TYPE_DISPLAY := 1 ;
  END_IF    
                                                   
  IF TYPE_DISPLAY=2 THEN                              // 2 = MENU PAGE 
    IF SEL_MENU_PAGE.Q THEN        
      TYPE_DISPLAY := 0 ;                           
    END_IF
  ELSIF SEL_MENU_PAGE.Q THEN
    TYPE_DISPLAY := 2 ;
  END_IF    

  // DISPLAY: STATUS LINE 
  IF     AND(LOWLOAD_STOP, NOT OFFLOADING) THEN
    DISPLAY_STATUS := 7;
  ELSIF  STOPPING THEN
    DISPLAY_STATUS := 6;
  ELSIF  COOLING_DOWN THEN
    DISPLAY_STATUS := 5;
  ELSIF  OFFLOADING THEN
    DISPLAY_STATUS := 4;
  ELSIF  SYNCHRONIZING THEN
    DISPLAY_STATUS := 3;
  ELSIF  STARTING THEN
    DISPLAY_STATUS := 2; 
  ELSIF  READY2START THEN
    DISPLAY_STATUS := 1;   
  ELSE
    DISPLAY_STATUS := 0;
  END_IF

  // DISPLAY: READY ICON 
  DISP_RDY := BOOL_TO_INT(READY2START);

  // DISPLAY: SEQUENCE NUMBER 
  DISP_SEQ := STB_SEQUENCE;

  // DISPLAY LOAD + ENGINEERING UNITS 
  SEL_RIGHT(CLK := PB_RIGHT);
  SEL_LEFT( CLK := PB_LEFT);
  IF SEL_RIGHT.Q THEN
    DISP_LOAD_EU  := DISP_LOAD_EU + 1;
    IF (DISP_LOAD_EU > 3) THEN DISP_LOAD_EU := 0; END_IF
  ELSIF SEL_LEFT.Q THEN
    DISP_LOAD_EU  := DISP_LOAD_EU - 1;
    IF (DISP_LOAD_EU < 0) THEN DISP_LOAD_EU := 3; END_IF 
  END_IF

  // later: DISPLAY LOAD TO BE CHANGED TO CHANNEL 097 SEPERATE FROM IO-BOARD CHANNEL "197 IOB_OUT_GENKW " 
  CASE DISP_LOAD_EU OF
   // => 0:      IOB_OUT_GENKW := IOB_OUT_GENKW ;    // 0= kW    
   1:      IOB_OUT_GENKW := GEN_KVAR;  // 1= kVAr 
   2:      IOB_OUT_GENKW := GEN_KVA;   // 2= kVA 
   3, 13:  IOB_OUT_GENKW := KW_PERC;   // 3, 13 = % 

   // BE AWARE: CH.096 "DISP_LOAD_EU" has additional possibilities  
   // 10= MW 
   // 11= MVAr 
   // 12= MVA 
   
  END_CASE

END_PROGRAM]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="PRG" name="IOB_CB_TRIP" editor="PAL1131.ST"><![CDATA[PROGRAM IOB_CB_TRIP

(* TO BE MOVED TO I/O-BOARD *)

VAR_EXTERNAL (*$AUTO*) END_VAR
 
VAR
 
  DELAY221       : TON;
  DELAY222       : TON;
  DELAY223       : TON;    
  DELAY224       : TON;
  DELAY225       : TON;
  DELAY226       : TON;  
  
  LATCH221       : SR;
  LATCH222       : SR;
  LATCH223       : SR;    
  LATCH224       : SR;
  LATCH225       : SR;
  LATCH226       : SR; 
  
  T_ALM271       : TON;
  T_ALM272       : TON;
  T_ALM273       : TON;
  T_ALM274       : TON;  
  T_ALM275       : TON;  
  T_ALM276       : TON;      
  
  
  TRIP           : BOOL;
  OPEN_CB        : BOOL;
  T_OPENCB       : TON;
  T_CBOPEN       : TP;
  CBOPEN_FAILURE : SR;
  
  BUS_DEAD       : BOOL;
  ENABLE_BUS_ALM : BOOL;
  ENABLE_GEN_ALM : BOOL;
  BUS_VOLT_ON    : BOOL;
  GEN_VOLT_ON    : BOOL;

END_VAR

//********************************************************************************
// ********** INPUT ******
// IOB_RESET              
// IOB_XP_FUNC            
// IOB_CMD_OPEN_CB        
// IOB_CMD_TRIP_CB        
// IOB_NOM_VOLT           
// IOB_NOM_AMP            
// IOB_NOM_FREQ           
// IOB_NOM_KW             
// ********* OUTPUT ******
// IOB_CB_TRIPPED         

//********************************************************************************  


  // PROTECTION => TRIP CB 
  DELAY221(IN := AND( (IOB_P0235 >FINT#0), (VOLT_PERC >IOB_P0235),          IOB_OUT_CB),  PT := FINT_TO_SEC(IOB_P0236));   	// <221> OVER-VOLTAGE TRIP 
  DELAY222(IN := AND( (IOB_P0237 >FINT#0), (VOLT_PERC <IOB_P0237),          IOB_OUT_CB),  PT := FINT_TO_SEC(IOB_P0238));    // <222> UNDER-VOLTAGE TRIP 
  DELAY223(IN := AND( (IOB_P0239 >FINT#0), (FREQ_PERC >IOB_P0239),          IOB_OUT_CB),  PT := FINT_TO_SEC(IOB_P02310));  	// <223> OVER-FREQUENCY TRIP 
  DELAY224(IN := AND( (IOB_P02311>FINT#0), (FREQ_PERC <IOB_P02311),         IOB_OUT_CB),  PT := FINT_TO_SEC(IOB_P02312));  	// <224> UNDER-FREQUENCY TRIP 
  DELAY225(IN := AND( (IOB_P0231 >FINT#0), (AMP_PERC  >IOB_P0231),          IOB_OUT_CB),  PT := FINT_TO_SEC(IOB_P0232));  	// <225> OVER-CURRENT TRIP 
  DELAY226(IN := AND( (IOB_P0233 >FINT#0), ((KW_PERC * FINT#-1)>IOB_P0233), IOB_OUT_CB),  PT := FINT_TO_SEC(IOB_P0234));    // <226> REVERSE POWER TRIP 

  LATCH221(S1 := DELAY221.Q, R := RESET);
  LATCH222(S1 := DELAY222.Q, R := RESET);
  LATCH223(S1 := DELAY223.Q, R := RESET);
  LATCH224(S1 := DELAY224.Q, R := RESET);
  LATCH225(S1 := DELAY225.Q, R := RESET);
  LATCH226(S1 := DELAY226.Q, R := RESET);
                          
  IOB_ALM_221 := LATCH221.Q1;
  IOB_ALM_222 := LATCH222.Q1;	
  IOB_ALM_223 := LATCH223.Q1;	
  IOB_ALM_224 := LATCH224.Q1;	
  IOB_ALM_225 := LATCH225.Q1;	
  IOB_ALM_226 := LATCH226.Q1;

  // DIFFERENT FUNCTIONS - DIFFERENT TRIP CONDITIONS 
  IF OR(
        IOB_XP_FUNC=1,      // D/G 
        IOB_XP_FUNC=3,      // SHAFT 
        IOB_XP_FUNC=4,      // SHORE    
        IOB_XP_FUNC=6       // EM+HARBOUR
        )
  THEN 
     
    TRIP := OR(IOB_ALM_221, IOB_ALM_222, IOB_ALM_223, IOB_ALM_224, IOB_ALM_225, IOB_ALM_226);

  ELSIF (IOB_XP_FUNC = 2) THEN     // EM+EM.MODE 
    IOB_ALM_221	:= FALSE;         
    IOB_ALM_222	:= FALSE;	
    IOB_ALM_223	:= FALSE;	
    IOB_ALM_224	:= FALSE;	    
    TRIP        := IOB_ALM_225 OR IOB_ALM_226;               // OVER-CURRENT / REVERSE POWER 

  ELSIF (IOB_XP_FUNC = 5) THEN     // ABT 

    IOB_ALM_221	:= FALSE;         // DISABLE ALARMS/TRIP FOR ABT 
    IOB_ALM_222	:= FALSE;	
    IOB_ALM_223	:= FALSE;	
    IOB_ALM_224	:= FALSE;	
    IOB_ALM_225	:= FALSE;	
    IOB_ALM_226	:= FALSE;    
    TRIP        := FALSE;               

  END_IF

  OPEN_CB        := OR(TRIP, IOB_CMD_TRIP_CB, IOB_CMD_OPEN_CB);
  IOB_CB_TRIPPED := OR(TRIP, IOB_CMD_TRIP_CB);  

  // CB OPEN PULSE (DOUT)  
  T_CBOPEN(IN := OPEN_CB , PT := FINT_TO_SEC(IOB_P0521));
  DO_OPEN_CB := T_CBOPEN.Q;   

  // CB OPEN FAILURE 
  T_OPENCB(IN:= AND(OPEN_CB, IOB_OUT_CB, NOT LOCAL), PT:= T#2s);                       
  CBOPEN_FAILURE(S1 := T_OPENCB.Q, R := IOB_RESET );
  IOB_ALM_215 := CBOPEN_FAILURE.Q1; 


  //*****************************************************************************
  //  IO-BOARD CONNECTION FAILURES & LEDs   
  //*****************************************************************************
  BUS_VOLT_ON := BUSVOLT_PERC > IOB_LEVEL_ENERGIZED;     // BUS-SIDE VOLTAGE   
  GEN_VOLT_ON := VOLT_PERC    > IOB_LEVEL_ENERGIZED;     // GEN-SIDE VOLTAGE  


  BUS_DEAD := AND(BUSVOLT_PERC < FINT#20,    // LOW BUS VOLTAGE 
                  BUSFREQ_PERC < FINT#20     // LOW BUS FREQUENCY 
                 );
  // MEASUREMENT ERRORS / ALARMS 
  IF (IOB_XP_FUNC < 5) THEN      // DG, EM, SHAFT, SHORE 

    ENABLE_BUS_ALM := NOT BUS_DEAD;       
    ENABLE_GEN_ALM := AND(DI_RUN, NOT STOPPING);

  ELSIF (IOB_XP_FUNC = 5) THEN                           // ABT 

    ENABLE_BUS_ALM := BUS_VOLT_ON; 
    ENABLE_GEN_ALM := GEN_VOLT_ON;     

  END_IF


  T_ALM271(IN := AND((IOBINT_GEN_PHASE_ERROR <> 0),   ENABLE_GEN_ALM, ENERGIZED) , PT := T#10s) ;           // GENERATOR PHASE ERROR 
  T_ALM272(IN := AND((IOBINT_GEN_MISSING_PHASE <> 0), ENABLE_GEN_ALM           ) , PT := T#10s) ;           // GENERATOR MISSING PHASE 
  T_ALM273(IN := AND((FREQ_PERC < FINT#70) ,          ENABLE_GEN_ALM           ) , PT := T#15s)  ;          // GENERATOR FREQ FAIL  

  IOB_ALM_271 := T_ALM271.Q ;             // <271> GEN PHASE ERROR 
  IOB_ALM_272 := T_ALM272.Q ;		      // <272> GEN MISSING PHASE 
  IOB_ALM_273 := T_ALM273.Q ;		      // <273> GEN FREQUENCY FAIL 

  T_ALM274(IN:= AND(IOBINT_BUS_PHASE_ERROR   <> 0, ENABLE_BUS_ALM), PT:= T#3s);		          // BUS PHASE ERROR 
  T_ALM275(IN:= AND(IOBINT_BUS_MISSING_PHASE <> 0, ENABLE_BUS_ALM), PT:= T#3s);		          // BUS MISSING PHASE 
  T_ALM276(IN:= AND(BUSFREQ_PERC < FINT#70       , ENABLE_BUS_ALM), PT:= T#3s);               // BUS FREQ FAIL  

  IOB_ALM_274 := T_ALM274.Q ;	            // <274> BUS PHASE ERROR 
  IOB_ALM_275 := T_ALM275.Q ;	            // <275> BUS MISSING PHASE 
  IOB_ALM_276 := T_ALM276.Q ;		        // <276> BUS FREQUENCY FAIL 

  IF (IOB_SIM_MODE >= 1) THEN   // DISABLE ALARMS IN SAMES SIMULATION  
    IOB_ALM_271	:= FALSE;
    IOB_ALM_272	:= FALSE;
    IOB_ALM_273	:= FALSE;
    IOB_ALM_274	:= FALSE;
    IOB_ALM_275	:= FALSE;
    IOB_ALM_276	:= FALSE;
  END_IF


  // IO BOARD BUS/GEN LEDS 
  IF GEN_VOLT_ON THEN                 // GEN ENERGIZED 
    IF OR(IOB_ALM_271, IOB_ALM_272, IOB_ALM_273) THEN
      LED_GEN := NOT LED_GEN;       // FLASH 
    ELSE
      LED_GEN := TRUE;
    END_IF    
  ELSE
    LED_GEN := FALSE;
  END_IF

  IF BUS_VOLT_ON THEN                 // BUS ENERGIZED 
    IF OR(IOB_ALM_274, IOB_ALM_275, IOB_ALM_276) THEN
      LED_BUS := NOT LED_BUS;       // FLASH 
    ELSE
      LED_BUS := TRUE;
    END_IF    
  ELSE
    LED_BUS := FALSE;
  END_IF

END_PROGRAM]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="FUN" name="DIV0" editor="PAL1131.ST"><![CDATA[FUNCTION DIV0 : FINT (*RET_TYPE*)
VAR_INPUT
 
  X : FINT;
  Y : FINT;
 
END_VAR
 
  IF Y = FINT#0 THEN
    DIV0 :=  FINT#0 ;
  ELSE 
    DIV0 :=  X / Y    ;
  END_IF

END_FUNCTION]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="FUN" name="FINT_TO_SEC" editor="PAL1131.ST"><![CDATA[FUNCTION FINT_TO_SEC : TIME (*RET_TYPE*)
VAR_INPUT
  IN : FINT;
END_VAR

  FINT_TO_SEC := REAL_TO_TIME(FINT_TO_REAL(IN* FINT#1000));
 
END_FUNCTION]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="FBLK" name="P_CONTROL" editor="PAL1131.ST"><![CDATA[FUNCTION_BLOCK P_CONTROL

//***************************************************************
//  PROPORTIONAL CONTROLLER                                      
//***************************************************************

VAR_INPUT 

  SP  : FINT;         // SETPOINT 
  FB  : FINT;         // FEEDBACK 
  DB  : FINT;         // DEADBAND 
  PB  : FINT;         // PROP BAND (%) =>  100/PB = GAIN   
  ENA : BOOL;         // ENABLE 
   
END_VAR
VAR_OUTPUT

  OUT : FINT;         // OUTPUT 
  ERR : FINT;         // ERROR  

END_VAR

VAR

  ERROR : FINT;

END_VAR

//**********************************************************

  ERROR := FB - SP;

  IF    ERROR >  DB THEN ERR := HSS(FINT#0, ERROR - DB);      // ONLY POSITIVE 
  ELSIF ERROR < -DB THEN ERR := LSS(FINT#0, ERROR + DB);      // ONLY NEGATIVE 
  ELSE                   ERR := FINT#0;
  END_IF
   
  OUT := (FINT#100 / PB) * ERR;   

  IF NOT ENA THEN OUT := FINT#0; END_IF   

END_FUNCTION_BLOCK]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="FBLK" name="TAC_CONTROL" editor="PAL1131.ST"><![CDATA[FUNCTION_BLOCK TAC_CONTROL

//***************************************************************
//  TIME-ADJUSTABLE-CONTROLLER                                   
//***************************************************************


VAR_INPUT 

  SP  : FINT;       // SETPOINT 
  FB  : FINT;       // FEEDBACK 
  DB  : FINT;       // DEADBAND                                             
  MIN : FINT;       // MIN. PULSE TIME 
  MAX : FINT;       // MAX. PULSE TIME 
  ENA : BOOL;       // ENABLE OUTPUTS 
   
END_VAR
VAR_OUTPUT

   INC : BOOL;       // TIME PROPORTIONAL INCREASE PULSE 
   DEC : BOOL;       // TIME PROPORTIONAL DECREASE PULSE        
   ERR : FINT;
   
END_VAR

VAR

  ERROR      : FINT;
  PULSE      : FINT;
  TIMER      : TCYCLE;
  CONTROL    : BOOL;
  CONTINUOUS : BOOL;
  PLS        : BOOL;
  I          : BOOL;
  D          : BOOL;
  OLD_PLS    : BOOL := FALSE;
  
END_VAR

//**********************************************************

  ERROR := FB - SP; 

  IF    ERROR >  DB THEN ERR := HSS(FINT#0, ERROR - DB);     // ONLY POSITIVE 
  ELSIF ERROR < -DB THEN ERR := LSS(FINT#0, ERROR + DB);     // ONLY NEGATIVE 
  ELSE                   ERR := FINT#0 ;
  END_IF
 
  PULSE := CURVE(_ABS(ERR), FINT#0, MIN, FINT#100, MAX);      // 0-100% => MIN-MAX PULSE    

  TIMER(START := ENA, PULSE := FINT_TO_SEC(PULSE), CYCLE := FINT_TO_SEC(MAX)); 
  PLS := TIMER.Q   ; 
    
  // INC / DEC 

  IF OR(AND(PLS, NOT OLD_PLS), TIMER.RESET) THEN
    I := FALSE;       
    D := FALSE;         
    IF    ERR < FINT#0 THEN I := TRUE;
    ELSIF ERR > FINT#0 THEN D := TRUE;
    END_IF
  END_IF 

  // OUTPUT PULSES  
  INC := I AND PLS;
  DEC := D AND PLS;  
 
  IF NOT ENA THEN
    INC := FALSE;
    DEC := FALSE;    
  END_IF  
    
  OLD_PLS := PLS;

//**********************************************************

END_FUNCTION_BLOCK]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="FUN" name="CURVE" editor="PAL1131.ST"><![CDATA[FUNCTION CURVE : FINT (*RET_TYPE*)

//*******************************************************
//  X - Y CURVE                                          
//                                                       
//*******************************************************

VAR_INPUT
 
  IN: FINT;
  X1: FINT;
  Y1: FINT;
  X2: FINT;
  Y2: FINT;
 
END_VAR
 
CURVE:=	((IN-X1) / (X2-X1)) * (Y2-Y1) + Y1;	 
 
END_FUNCTION]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="FUN" name="HSS" editor="PAL1131.ST"><![CDATA[FUNCTION HSS : FINT (*RET_TYPE*)

//*******************************************************
//  HIGH SIGNAL SELECTOR                                 
//  => low limiting                                      
//*******************************************************

VAR_INPUT
 
 IN1 : FINT;
 IN2 : FINT;                                                 
 
END_VAR
 
  IF IN1>=IN2 THEN HSS:= IN1; ELSE HSS:=IN2; END_IF 

END_FUNCTION]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="FUN" name="LSS" editor="PAL1131.ST"><![CDATA[FUNCTION LSS : FINT (*RET_TYPE*)
//******************************************************
//  LOW SIGNAL SELECTOR                                 
//  => high limiting                                     
//*******************************************************

VAR_INPUT
 
 IN1 : FINT;
 IN2 : FINT;                                                 
 
END_VAR
 
  IF IN1<=IN2 THEN LSS:= IN1; ELSE LSS:=IN2; END_IF

END_FUNCTION]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="FBLK" name="PB_RATE" editor="PAL1131.ST"><![CDATA[FUNCTION_BLOCK PB_RATE

//*******************************************************
//  INTENDED USE IS TO INCREASE OUTPUT THE LONGER        
//  THE PUSHBUTTON IS PRESSED                            
//                                                       
//  FUNCTION GIVES AN "OUTPUT VALUE" EVERY "CYCLE"       
//  "OUTPUT VALUE" INCREASES IN 3 STEPS DEPENDING THE    
//  CONFIGURED "RATES"                                   
//  E.G. RATE2=3 THEN AFTER 3xCYCLE THE OUTPUT           
//  BECOMES #3 WITH EVERY CYCLE                          
//*******************************************************

VAR_INPUT 

    PB    : BOOL;
    CYCLE : FINT;
    RATE2 : INT;
    RATE3 : INT;

END_VAR
VAR_OUTPUT

    OUT  : FINT;

END_VAR

VAR

   PLS   : TCYCLE;
   DELAY : TON;
   COUNT : INT;
   EDGE  : R_TRIG;
   VALUE : INT;
   
END_VAR

  //#######################################################

  PLS(START := PB ,PULSE := T#100ms , CYCLE := FINT_TO_SEC(HSS(FINT#0.2, CYCLE)));
  EDGE(CLK:= PLS.Q) ;

  IF PB THEN
    IF EDGE.Q THEN COUNT := COUNT + 1; END_IF
  ELSE
    COUNT := 0;
  END_IF

  IF COUNT >= RATE3 THEN
    VALUE := RATE3;
  ELSIF COUNT >= RATE2 THEN
    VALUE := RATE2;
  ELSE
    VALUE := 1; 
  END_IF

  IF EDGE.Q THEN
    OUT := INT_TO_FINT(VALUE);
  ELSE
    OUT := FINT#0 ;
  END_IF

END_FUNCTION_BLOCK]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="FUN" name="FINT_TO_INT" editor="PAL1131.ST"><![CDATA[FUNCTION FINT_TO_INT : INT (*RET_TYPE*)
VAR_INPUT
 
  IN : FINT;
   
END_VAR
 
 FINT_TO_INT := REAL_TO_INT(FINT_TO_REAL(IN ));

END_FUNCTION]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="FUN" name="_ABS" editor="PAL1131.ST"><![CDATA[FUNCTION _ABS : FINT (*RET_TYPE*)

// FIX FOR LACKING ABS|| SUPPORT FOR FINT 

VAR_INPUT
 
  IN : FINT;
 
END_VAR
 
  IF IN < FINT#0 THEN _ABS := -IN; ELSE _ABS := IN; END_IF

END_FUNCTION]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="FUN" name="BUSADD" editor="PAL1131.ST"><![CDATA[FUNCTION BUSADD : BOOL (*RET_TYPE*)

(* BUSADD = TRUE WHEN BUS1 AND BUS2 ARE CONNECTED *)
(* USING PRELOADED ARRAYS FROM BT'S EVALUATION *)

 VAR_INPUT
    
    BUS1 : INT;
    BUS2 : INT;
    
 END_VAR

  BUSADD := FALSE;
  IF AND(BUS1 >= 1, BUS1 <=5, BUS2 >= 1, BUS2 <=5) THEN
    IF (BUS1 = BUS2) THEN
      BUSADD := TRUE;
    ELSE
      CASE BUS1 OF 
         1:   BUSADD :=  BUS1ADD[BUS2];   (* VIRTUAL "TWO" DIMENSIONAL ARRAY *)
         2:   BUSADD :=  BUS2ADD[BUS2];   (* CONCERNING CONNECTED BUS ?? *)
         3:   BUSADD :=  BUS3ADD[BUS2];
         4:   BUSADD :=  BUS4ADD[BUS2]; 
         5:   BUSADD :=  BUS5ADD[BUS2];
      END_CASE
   END_IF 
END_IF  

END_FUNCTION]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="FBLK" name="TCYCLE" editor="PAL1131.ST"><![CDATA[FUNCTION_BLOCK TCYCLE

VAR_INPUT                                                                                                                       
   START : BOOL ;
   PULSE : TIME ;
   CYCLE : TIME ;
END_VAR
VAR_OUTPUT
   Q :    BOOL;
   ET:    TIME ;

END_VAR
VAR
   RESET    : BOOL := TRUE;
   TIMER    : TON;
    
   USED_PULSE  : TIME;
   USED_CYCLE  : TIME;  
   
END_VAR  

  //##############################################

  IF RESET THEN
    USED_CYCLE := CYCLE ;     // UPDATE ONCE PER CYCLE 
    USED_PULSE := PULSE ;     // UPDATE ONCE PER CYCLE 
  ELSIF PULSE < USED_PULSE THEN
    USED_PULSE := PULSE ;     // ALLOW DECREASING OF PULSE TIME TO PREVENT OVERSHOOT 
  END_IF
    
  TIMER(IN := AND(START, NOT RESET) , PT :=  USED_CYCLE);

  ET:= TIMER.ET;
  Q := AND(OR(ET < USED_PULSE, USED_PULSE >= USED_CYCLE), START);
   
  RESET := TIMER.Q;    
    
  IF NOT START THEN RESET := TRUE; END_IF

END_FUNCTION_BLOCK]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="FUN" name="MSEC_TO_FINT" editor="PAL1131.ST"><![CDATA[FUNCTION MSEC_TO_FINT : FINT (*RET_TYPE*)
VAR_INPUT
  IN : TIME;      
END_VAR
 
  MSEC_TO_FINT  := REAL_TO_FINT(TIME_TO_REAL(IN));

END_FUNCTION]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="FUN" name="_SQRT" editor="PAL1131.ST"><![CDATA[FUNCTION _SQRT : FINT (*RET_TYPE*)
VAR_INPUT
  IN : FINT ;
END_VAR
 
  _SQRT := REAL_TO_FINT(SQRT(FINT_TO_REAL(IN))); 

END_FUNCTION]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="FBLK" name="SEQ_ENCODE" editor="PAL1131.ST"><![CDATA[FUNCTION_BLOCK SEQ_ENCODE
// FUNTION PUTS THE LOCAL ARRAY IN A SINGLE CHANNEL VALUE (SEQUENCE CODE) 
// FOR DISTRIBUTION TO OTHER BOARDS 
//
// INPUT : GLOBAL ARRAY SEQUENCE[XP] 
// OUTPUT: SEQUENCE CODE_A~D TO CHANNELS  

VAR_INPUT
  MAX     : INT;
   // GLOBAL ARRAY 
END_VAR
VAR_OUTPUT
  CODE_A : WORD;
  CODE_B : WORD;
  CODE_C : WORD;
  CODE_D : WORD;
END_VAR
VAR
  X      : INT;
  FACTOR : WORD;
END_VAR
 
  CODE_A := WORD#0;
  FOR X := 1 TO 4 DO
    CASE X OF 
       1: FACTOR := WORD#16#1;
       2: FACTOR := WORD#16#10;
       3: FACTOR := WORD#16#100;   
       4: FACTOR := WORD#16#1000;
    END_CASE
    CODE_A := CODE_A + INT_TO_WORD(SEQUENCE[X]) * FACTOR;
  END_FOR

  CODE_B := WORD#0;
  FOR X := 5 TO 8 DO
    CASE X OF 
       5: FACTOR := WORD#16#1;
       6: FACTOR := WORD#16#10;
       7: FACTOR := WORD#16#100;   
       8: FACTOR := WORD#16#1000;
    END_CASE
    CODE_B := CODE_B + INT_TO_WORD(SEQUENCE[X]) * FACTOR;
  END_FOR

  CODE_C := WORD#0;
  FOR X := 9 TO 12 DO
    CASE X OF 
       9: FACTOR := WORD#16#1;
      10: FACTOR := WORD#16#10;
      11: FACTOR := WORD#16#100;   
      12: FACTOR := WORD#16#1000;
    END_CASE
    CODE_C := CODE_C + INT_TO_WORD(SEQUENCE[X]) * FACTOR;
  END_FOR

  CODE_D := WORD#0;
  FOR X := 13 TO MAX DO
    CASE X OF 
      13: FACTOR := WORD#16#1;
      14: FACTOR := WORD#16#10;
      15: FACTOR := WORD#16#100;   
    END_CASE
    CODE_D := CODE_D + INT_TO_WORD(SEQUENCE[X]) * FACTOR;
  END_FOR

END_FUNCTION_BLOCK]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="FUN" name="SEQ_DECODE" editor="PAL1131.ST"><![CDATA[FUNCTION SEQ_DECODE : BOOL (*RET_TYPE*)


// FUNTION PUTS A SINGLE CHANNEL VALUE (SEQUENCE CODE) IN THE LOCAL ARRAY  
//
// INPUT : SEQUENCE CODE              
// OUTPUT: GLOBAL ARRAY SEQUENCE[XP]  
// RETURN: TRUE IF VALID CODE        

                                                                
VAR_INPUT
  CODEA  : WORD;       // CODE INPUT 
  CODEB  : WORD;       // CODE INPUT 
  CODEC  : WORD;       // CODE INPUT 
  CODED  : WORD;       // CODE INPUT 
  MAX    : INT;
END_VAR
 
VAR
   X     : INT;
   SEQ   : WORD;
END_VAR

  IF OR(CODEA > WORD#0, CODEB > WORD#0, CODEC > WORD#0, CODED > WORD#0) THEN
 
    SEQ_DECODE := TRUE;
    
    FOR X := 1 TO MAX DO
    
       CASE X OF 
           1: SEQ :=      AND(CODEA, WORD#16#000F);
           2: SEQ :=  SHR(AND(CODEA, WORD#16#00F0),4);
           3: SEQ :=  SHR(AND(CODEA, WORD#16#0F00),8);
           4: SEQ :=  SHR(AND(CODEA, WORD#16#F000),12);
           5: SEQ :=      AND(CODEB, WORD#16#000F);
           6: SEQ :=  SHR(AND(CODEB, WORD#16#00F0),4);
           7: SEQ :=  SHR(AND(CODEB, WORD#16#0F00),8);
           8: SEQ :=  SHR(AND(CODEB, WORD#16#F000),12);
           9: SEQ :=      AND(CODEC, WORD#16#000F);
          10: SEQ :=  SHR(AND(CODEC, WORD#16#00F0),4);
          11: SEQ :=  SHR(AND(CODEC, WORD#16#0F00),8);
          12: SEQ :=  SHR(AND(CODEC, WORD#16#F000),12);
          13: SEQ :=      AND(CODED, WORD#16#000F);
          14: SEQ :=  SHR(AND(CODED, WORD#16#00F0),4);
          15: SEQ :=  SHR(AND(CODED, WORD#16#0F00),8);
     END_CASE
       
     SEQUENCE[X] := WORD_TO_INT(SEQ);
   
    END_FOR

  ELSE
  
    SEQ_DECODE := FALSE;

  END_IF

END_FUNCTION]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="FBLK" name="SEQ_PRIORITY" editor="PAL1131.ST"><![CDATA[FUNCTION_BLOCK SEQ_PRIORITY


// FUNTION FINDS XP NO. OF 1ST, 2ND AND LAST IN SEQ_CODE[XP] ARRAY 
// ONLY UNMASKED XP'S WITH SEQ_MASK[XP]=TRUE ARE EVALUATED 

// INPUT : GLOBAL ARRAY SEQUENCE[XP] 
// INPUT : GLOBAL ARRAY SEQ_MASK[XP] 

// OUTPUT: XP_1ST  (XP OF LOWEST SEQ)    
// OUTPUT: XP_2ND  (XP OF 2ND LOWEST SEQ 
// OUTPUT: XP_LST  (XP OF HIGHEST SEQ    


VAR_INPUT 
   MAX    :  INT;
   // GLOBAL ARRAYS 
END_VAR

VAR_OUTPUT
   XP_1ST :  INT;
   XP_2ND :  INT;
   XP_LST :  INT;
END_VAR

VAR
   X              : INT;
   LOWEST         : INT;
   SEC_LOWEST     : INT;
   HIGHEST        : INT;
   MASK_NOT_EMPTY : BOOL;  
END_VAR

 
  XP_1ST         := MAX;
  LOWEST         := MAX + 1;

  XP_LST         := 1;
  HIGHEST        := 0;
  MASK_NOT_EMPTY := FALSE;

  FOR X := 1 TO MAX DO                // FIND 1ST AND LAST 
 
    IF SEQ_MASK[X] THEN
    
      IF SEQUENCE[X] < LOWEST THEN
        LOWEST := SEQUENCE[X];
        XP_1ST := X ;
      END_IF
       
      IF SEQUENCE[X] > HIGHEST THEN
        HIGHEST := SEQUENCE[X];
        XP_LST  := X;
      END_IF
       
      MASK_NOT_EMPTY := TRUE ;

    END_IF
     
  END_FOR
  
  SEC_LOWEST := MAX+1;
 
  FOR X := 1 TO MAX DO
 
    IF SEQ_MASK[X] THEN
    
      IF AND(SEQUENCE[X] > LOWEST, SEQUENCE[X] < SEC_LOWEST) THEN
        SEC_LOWEST := SEQUENCE[X];
        XP_2ND     := X;
      END_IF

    END_IF

  END_FOR   

  IF SEC_LOWEST > HIGHEST THEN
    SEC_LOWEST := HIGHEST;
    XP_2ND     := XP_LST ;
  END_IF

  IF NOT MASK_NOT_EMPTY THEN
    LOWEST       := 0;
    XP_1ST       := 0;
    SEC_LOWEST   := 0;
    XP_2ND       := 0;
    HIGHEST      := 0;
    XP_LST       := 0;
  END_IF
 
END_FUNCTION_BLOCK]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="FUN" name="SEQ_EXCHANGE" editor="PAL1131.ST"><![CDATA[FUNCTION SEQ_EXCHANGE : BOOL (*RET_TYPE*)

// FUNTION EXCHANGES SEQUENCE NUMBERS IN SEQ_CODE[XP] ARRAY OF GIVEN XP'S 
// INPUT : GLOBAL ARRAY SEQUENCE[XP] 
// INPUT : XP1 
// INPUT : XP2 

// OUTPUT: GLOBAL ARRAY SEQUENCE[XP]   


// RETURN: TRUE WITH VALID SELECTION   

VAR_INPUT
    XP1    : INT;
    XP2    : INT;
    MAX    : INT;
END_VAR
 
VAR
   OLD_2ND : INT;
END_VAR
 
  SEQ_EXCHANGE := AND(
                      XP1 >= 1, XP1 <= MAX, 
                      XP2 >= 1, XP2 <= MAX,
                      XP1 <> XP2
                     );

  IF SEQ_EXCHANGE THEN
 
    OLD_2ND       := SEQUENCE[XP2];
    SEQUENCE[XP2] := SEQUENCE[XP1];
    SEQUENCE[XP1] := OLD_2ND; 
  
  END_IF

END_FUNCTION]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="FUN" name="SEQ_VALID" editor="PAL1131.ST"><![CDATA[FUNCTION SEQ_VALID : BOOL (*RET_TYPE*)

 
// FUNTION EXCHANGES SEQUENCE NUMBERS IN SEQ_CODE[XP] ARRAY OF GIVEN XP'S 

// INPUT : GLOBAL ARRAY SEQUENCE[XP] 

// RETURN: TRUE WITH VALID SEQUNCE CODE   

 VAR_INPUT
    CODEA : WORD;
    CODEB : WORD;
    CODEC : WORD;
    CODED : WORD;
 END_VAR

 SEQ_VALID := AND(CODEA >= WORD#16#1234, CODEB >= WORD#16#1234, CODEC >= WORD#16#1234, CODED >= WORD#16#123);       // MAYBE TO SIMPLE CHECK
 
END_FUNCTION]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="FUN" name="INT_TO_FINT" editor="PAL1131.ST"><![CDATA[FUNCTION INT_TO_FINT : FINT (*RET_TYPE*)
VAR_INPUT
  IN : INT;
END_VAR
 
  INT_TO_FINT := REAL_TO_FINT(INT_TO_REAL(IN ));
 
END_FUNCTION]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="FUN" name="GTZ" editor="PAL1131.ST"><![CDATA[FUNCTION GTZ : BOOL (*RET_TYPE*)

// GREATER THEN ZERO

VAR_INPUT
  IN : FINT ;
END_VAR

  GTZ := GT(IN, FINT#0 );
 
END_FUNCTION]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="FUN" name="WINDOW" editor="PAL1131.ST"><![CDATA[FUNCTION WINDOW : BOOL (*RET_TYPE*)

// WINDOW COMPARATOR

VAR_INPUT
  IN   : FINT;
  LOW  : FINT;
  HIGH : FINT;
END_VAR
 
  WINDOW := AND(GE(IN, LOW), LE(IN, HIGH));

END_FUNCTION]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="FBLK" name="BUS_DECODE" editor="PAL1131.ST"><![CDATA[FUNCTION_BLOCK BUS_DECODE
VAR_INPUT 
   CODE : INT;
END_VAR
VAR_OUTPUT
   BUS : INT;
   BIT : BOOL;
END_VAR
VAR
  LSD : INT;
END_VAR

  LSD := MOD(CODE, 10);                 // LEAST SIGNIFICANT DIGIT 
  BUS := (CODE - LSD) / 10;             // MOST SIGNIFICANT DIGIT 
  BIT := NOT(LSD = 0 );                 // LEAST SIGNIFICANT BIT = LSD <> 0  

END_FUNCTION_BLOCK]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="FBLK" name="FLASHER" editor="PAL1131.ST"><![CDATA[FUNCTION_BLOCK FLASHER

VAR_INPUT                                                                                                                       
  START : BOOL;
  PULSE : TIME;
  CYCLE : TIME;
END_VAR
VAR_OUTPUT
  Q     : BOOL;
  ET    : TIME;
END_VAR
VAR
  TIMER : TON;
END_VAR  


//##############################################

  TIMER(IN := AND(START, NOT TIMER.Q), PT :=  CYCLE);

  ET:= TIMER.ET;
  Q := OR(ET <= PULSE, PULSE >= CYCLE);
   
END_FUNCTION_BLOCK]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="FBLK" name="TOGGLE" editor="PAL1131.ST"><![CDATA[FUNCTION_BLOCK TOGGLE
VAR_INPUT 
  IN     : BOOL;
END_VAR
VAR_OUTPUT
  OUT    : BOOL;      
END_VAR
VAR
  OLD_IN : BOOL;
END_VAR

  OUT    := OUT XOR AND(IN, NOT OLD_IN);
  OLD_IN := IN;

END_FUNCTION_BLOCK]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="FBLK" name="DECODE_INT" editor="PAL1131.ST"><![CDATA[FUNCTION_BLOCK DECODE_INT
VAR_INPUT 
   IN : INT;
END_VAR
VAR_OUTPUT
   B1 : BOOL;
   B2 : BOOL;          
   B3 : BOOL;
   B4 : BOOL;
   B5 : BOOL;          
   B6 : BOOL;   
END_VAR
VAR 
   V  : INT;
END_VAR

  V  := IN;
  B6 := INT_TO_BOOL(V/64);
  V  := V - (BOOL_TO_INT(B6)*64);
  B5 := INT_TO_BOOL(V/32);
  V  := V - (BOOL_TO_INT(B5)*32);
  B4 := INT_TO_BOOL(V/16);
  V  := V - (BOOL_TO_INT(B4)*16);
  B3 := INT_TO_BOOL(V/8);
  V  := V - (BOOL_TO_INT(B3)*8);
  B2 := INT_TO_BOOL(V/4);
  V  := V - (BOOL_TO_INT(B2)*4);
  B1 := INT_TO_BOOL(V/2);

END_FUNCTION_BLOCK]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="FBLK" name="SET_1OF5" editor="PAL1131.ST"><![CDATA[FUNCTION_BLOCK SET_1OF5

// SELECT ONE OUT OF 5 SELECTIONS BASED ON LAST CHANGED SETTING  
VAR_IN_OUT
    IO1     : BOOL;                            // AWAITING ARRAY INPUT POSSIBILITY 
    IO2     : BOOL;    
    IO3     : BOOL;
    IO4     : BOOL;
    IO5     : BOOL;    
END_VAR
VAR_INPUT
    NEW     : INT;
END_VAR
VAR_OUTPUT
    SELECT  : INT;     
END_VAR
VAR 
    N       : INT;
    I       : INT; 
    IO      : ARRAY[1..5] OF BOOL;    
    OLD     : ARRAY[1..5] OF BOOL; 
    RECOVER : TON;
    
END_VAR

  //*******************
  IO[1] := IO1;        
  IO[2] := IO2;
  IO[3] := IO3;
  IO[4] := IO4;
  IO[5] := IO5;

// CHECK ILLEGAL SETTING TO RECOVER & SET DEFAULT
  I := 0;
  FOR N:=1 TO 5 DO I := I + BOOL_TO_INT(IO[N]); END_FOR
  RECOVER(IN := (I<>1) , PT := T#1000); 

  // CHECK WHICH INPUTS CHANGED 
  FOR N := 1 TO 5 DO
    IF OR(
          AND(IO[N], NOT OLD[N]),         // 1 OF 5 SETTING CHANGED 
          AND(RECOVER.Q, (N = 1)),        // RECOVER TO 1 
          (NEW = N)                       // TAKE OVER SETTING FROM OTHER
          ) 
    THEN 
      FOR I:=1 TO 5 DO IO[I] := FALSE; END_FOR  // RESET ALL 
      IO[N] := TRUE;
      SELECT := N;
      EXIT;
    END_IF
  END_FOR

  FOR N := 1 TO 5 DO OLD[N] := IO[N]; END_FOR  // REMEMBER 

  IO1 := IO[1];        
  IO2 := IO[2];
  IO3 := IO[3];
  IO4 := IO[4];
  IO5 := IO[5];

END_FUNCTION_BLOCK]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="FBLK" name="HW_XP" editor="PAL1131.ST"><![CDATA[FUNCTION_BLOCK HW_XP

(*$HARDWARE_BODY_CALL ID:0010; Align:2*)

(*$COMMENT The block is implemented in C (see native_blocks.c *)

VAR_INPUT

 

END_VAR

VAR_OUTPUT

IP : INT;

END_VAR

END_FUNCTION_BLOCK]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
      <ITEM lang="ST" type="FUN" name="XP_SEQ" editor="PAL1131.ST"><![CDATA[FUNCTION XP_SEQ : INT (*RET_TYPE*)
// FUNCTION RETURNS THE XP NUMBER OF THE GIVEN SEQUENCE
// IF NOT FOUND IT WILL RETURN 0
 
VAR_INPUT
  SEQ : INT;
  MAX : INT;
  //GLOBAL SEQUENCE ARRAY
END_VAR
VAR
  XP  : INT;
END_VAR

  XP_SEQ := 0; // RET_VALUE
  FOR XP := 1 TO MAX DO IF SEQUENCE[XP]=SEQ THEN XP_SEQ := XP; END_IF END_FOR
 
END_FUNCTION]]><EDITOR><![CDATA[]]></EDITOR></ITEM>
    </POU>
    <GLOBAL>
      <ITEM type="VAR" name="ALM_201" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_201 (*$COMMENT 70247 ENGINE START FAILURE*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ALM_202" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_202 (*$COMMENT 70248 ENGINE STOP FAILURE*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ALM_203" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_203 (*$COMMENT 70249 ENGINE EXT. SHUTDOWN*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ALM_204" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_204 (*$COMMENT 70250 ENGINE PRE-ALARM*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ALM_205" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_205 (*$COMMENT 70251 ENGINE NOT READY*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ALM_211" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_211 (*$COMMENT 70252 ENERGIZE FAILURE*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ALM_212" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_212 (*$COMMENT 70253 OFFLOAD FAILURE*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ALM_213" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_213 (*$COMMENT 70254 SYNCHRONIZE FAILURE*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ALM_214" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_214 (*$COMMENT 70255 CB CLOSE FAILURE*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ALM_216" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_216 (*$COMMENT 70257 LOAD TOO HIGH DEVIATION (KW or KVAR)*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ALM_227" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_227 (*$COMMENT 70265 CB ABNORMAL TRIPPED*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ALM_228" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_228 (*$COMMENT 70266 CB TRIP EXT. COMMAND*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ALM_231" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_231 (*$COMMENT 70272 GEN OVER-LOAD (ALARM)*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ALM_241" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_241 (*$COMMENT 70268 BUS HIGH VOLTAGE (ABNORMAL)*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ALM_242" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_242 (*$COMMENT 70269 BUS LOW VOLTAGE (ABNORMAL)*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ALM_243" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_243 (*$COMMENT 70270 BUS HIGH FREQUENCY (ABNORMAL)*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ALM_244" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_244 (*$COMMENT 70271 BUS LOW FREQUENCY (ABNORMAL)*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ALM_251" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_251 (*$COMMENT 70273 BUS HIGH VOLTAGE (ALARM)*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ALM_252" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_252 (*$COMMENT 70274 BUS LOW VOLTAGE (ALARM)*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ALM_253" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_253 (*$COMMENT 70275 BUS HIGH FREQUENCY (ALARM)*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ALM_254" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_254 (*$COMMENT 70276 BUS LOW FREQUENCY (ALARM)*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ALM_261" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_261 (*$COMMENT 70277 BUS-TIE #A TRIPPED*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ALM_262" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_262 (*$COMMENT 70278 BUS-TIE #B TRIPPED*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ALM_281" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_281 (*$COMMENT 70287 NON-PREFERENTIAL TRIP 1*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ALM_282" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_282 (*$COMMENT 70288 NON-PREFERENTIAL TRIP 2*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ALM_283" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_283 (*$COMMENT 70289 NON-PREFERENTIAL TRIP 3*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ALM_284" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_284 (*$COMMENT 70290 NON-PREFERENTIAL TRIP 4*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ALM_291" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_291 (*$COMMENT 70286 BLACKOUT*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ALM_500" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_500 (*$COMMENT 70299 SYSTEM ALARM*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ALM_501" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_501 (*$COMMENT 70291 IO-BOARD IN TEST MODE*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ALM_502" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_502 (*$COMMENT 70292 WRONG *GRID* SETTINGS*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ALM_503" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_503 (*$COMMENT 70293 WRONG *ADDRESS* SETTINGS*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ALM_504" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_504 (*$COMMENT 70294 NETWORK PORT A FAULT*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ALM_505" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_505 (*$COMMENT 70295 NETWORK PORT B FAULT*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ALM_506" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_506 (*$COMMENT 70296 PROGRAM NOT RUNNING*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ALM_507" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_507 (*$COMMENT 70297 IO-BOARD NOT PRESENT*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ALM_508" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ALM_508 (*$COMMENT 70298 spare alarm in alarm group ch. 200 *) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="AMP_PERC" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 AMP_PERC (*$COMMENT 70075 GENERATOR CURRENT (%)*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="BLACKOUT" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 BLACKOUT (*$COMMENT 70085 BLACKOUT DETECT*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="BUZZER" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 BUZZER (*$COMMENT 70020 BUZZER*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="CB_TRIPPED_ANY" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 CB_TRIPPED_ANY (*$COMMENT 70049 CB TRIPPED (ANY/ALL CAUSE)*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="COOLING_DOWN" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 COOLING_DOWN (*$COMMENT 70082 GENERATOR COOLING DOWN*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="DISPLAY_KVAR" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 DISPLAY_KVAR (*$COMMENT 70091 GENERATOR KVAR (ACTUAL/SIM)*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="DISPLAY_KVA" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 DISPLAY_KVA (*$COMMENT 70090 GENERATOR KVA (ACTUAL/SIM)*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="DISPLAY_STATUS" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 DISPLAY_STATUS (*$COMMENT 70000 DISPLAY STATUS LINE*) : INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="DISPLAY_TIMER" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 DISPLAY_TIMER (*$COMMENT 70097 DISPLAY TIMERS COOLDOWN AND LOWLOAD*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="DISP_COSPHI" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 DISP_COSPHI (*$COMMENT 70198 DISPLAY - GENERATOR COSPHI*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="DISP_LOAD_EU" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 DISP_LOAD_EU (*$COMMENT 70096 DISPLAY LOAD EU SELECT*) : INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="DISP_RDY" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 DISP_RDY (*$COMMENT 70095 DISPLAY READY TO START*) : INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="DISP_SEQ" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 DISP_SEQ (*$COMMENT 70094 DISPLAY SEQUENCE NUMBER*) : INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="DI_CBCLOSED" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 DI_CBCLOSED (*$COMMENT 70109 DIN9 - CB CLOSED STATUS*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="DI_PMS_SEL" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 DI_PMS_SEL (*$COMMENT 70113 DIN13 - SWBD/PMS SELECT*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="DI_READY" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 DI_READY (*$COMMENT 70112 DIN12 - READY TO START*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="DI_REMOTE" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 DI_REMOTE (*$COMMENT 70114 DIN14 - ENGINE REMOTE CTRL*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="DI_RUN" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 DI_RUN (*$COMMENT 70110 DIN10 - ENGINE RUNNING*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="DI_START_FL" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 DI_START_FL (*$COMMENT 70111 DIN11 - ENGINE START FAIL*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="DO_CLOSE_CB_READONLY" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 DO_CLOSE_CB_READONLY (*$COMMENT 70123 DOUT23 - CB CLOSE*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="DO_DEC_RPM" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 DO_DEC_RPM (*$COMMENT 70126 DOUT26 - ENGINE DEC. SPEED*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="DO_INC_RPM" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 DO_INC_RPM (*$COMMENT 70125 DOUT25 - ENGINE INC. SPEED*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="DO_OPEN_CB" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 DO_OPEN_CB (*$COMMENT 70124 DOUT24 - CB OPEN*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="DO_START" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 DO_START (*$COMMENT 70127 DOUT27 - ENGINE START*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="DO_STOP" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 DO_STOP (*$COMMENT 70128 DOUT28 - ENGINE STOP*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="ENERGIZED" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 ENERGIZED (*$COMMENT 70087 GENERATOR ENERGIZED*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="FREQ_PERC" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 FREQ_PERC (*$COMMENT 70074 GENERATOR FREQUENCY (%)*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOBINT_BUS_MISSING_PHASE" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOBINT_BUS_MISSING_PHASE (*$COMMENT 70137 (SAMES) BUS_MISSING_PHASE (CODE)*) : INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOBINT_BUS_PHASE_ERROR" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOBINT_BUS_PHASE_ERROR (*$COMMENT 70136 (SAMES) BUS_PHASE_ERROR (CODE)*) : INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOBINT_GEN_MISSING_PHASE" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOBINT_GEN_MISSING_PHASE (*$COMMENT 70149 (SAMES) GEN_MISSING_PHASE (CODE)*) : INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOBINT_GEN_PHASE_ERROR" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOBINT_GEN_PHASE_ERROR (*$COMMENT 70148 (SAMES) GEN_PHASE_ERROR (CODE)*) : INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOBINT_SY_DELTA_FREQ_NEG" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOBINT_SY_DELTA_FREQ_NEG (*$COMMENT 70173 (SYNC CHK) DELTA FREQUENCY NEGATIVE*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOBINT_SY_DELTA_FREQ_POS" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOBINT_SY_DELTA_FREQ_POS (*$COMMENT 70174 (SYNC CHK) DELTA FREQUENCY POSITIVE*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOBINT_SY_DELTA_VOLT" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOBINT_SY_DELTA_VOLT (*$COMMENT 70172 (SYNC CHK) DELTA VOLTAGE*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_ALM_215" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_ALM_215 (*$COMMENT 70256 CB OPEN FAILURE*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_ALM_221" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_ALM_221 (*$COMMENT 70259 OVER-VOLTAGE TRIP*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_ALM_222" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_ALM_222 (*$COMMENT 70260 UNDER-VOLTAGE TRIP*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_ALM_223" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_ALM_223 (*$COMMENT 70261 OVER-FREQUENCY TRIP*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_ALM_224" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_ALM_224 (*$COMMENT 70262 UNDER-FREQUENCY TRIP*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_ALM_225" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_ALM_225 (*$COMMENT 70263 OVER-CURRENT TRIP*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_ALM_226" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_ALM_226 (*$COMMENT 70264 REVERSE POWER TRIP*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_ALM_271" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_ALM_271 (*$COMMENT 70280 GEN PHASE ERROR*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_ALM_272" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_ALM_272 (*$COMMENT 70281 GEN MISSING PHASE*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_ALM_273" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_ALM_273 (*$COMMENT 70282 GEN FREQUENCY FAIL*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_ALM_274" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_ALM_274 (*$COMMENT 70283 BUS PHASE ERROR*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_ALM_275" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_ALM_275 (*$COMMENT 70284 BUS MISSING PHASE*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_ALM_276" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_ALM_276 (*$COMMENT 70285 BUS FREQUENCY FAIL*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_CB_TRIPPED" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_CB_TRIPPED (*$COMMENT 70168 IOBOARD -CB TRIPPED*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_CLOSE_DEADBUS" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_CLOSE_DEADBUS (*$COMMENT 70170 (SYNC CHK) CMD CLOSE CB DEAD BUS*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_CLOSE_SYNC" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_CLOSE_SYNC (*$COMMENT 70169 (SYNC CHK) CMD SYNC. CHECK *) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_CLOSE_TPULSE" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_CLOSE_TPULSE (*$COMMENT 70171 (SAMES SP) CLOSE CB PULSE LENGTH*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_CMD_OPEN_CB" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_CMD_OPEN_CB (*$COMMENT 70531 IOBOARD -CMD OPEN CB*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_CMD_TRIP_CB" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_CMD_TRIP_CB (*$COMMENT 70163 IOBOARD -CMD TRIP CB*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_LEVEL_ENERGIZED" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_LEVEL_ENERGIZED (*$COMMENT 70159 IOBOARD - LEVEL ENERGIZED*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_NOM_AMP" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_NOM_AMP (*$COMMENT 70195 IOBOARD -RATED CURRENT [100%]*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_NOM_FREQ" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_NOM_FREQ (*$COMMENT 70532 IOBOARD -RATED FREQUENCY (100%)*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_NOM_KW" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_NOM_KW (*$COMMENT 70533 IOBOARD -RATED KW POWER [100%]*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_NOM_VOLT" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_NOM_VOLT (*$COMMENT 70194 IOBOARD -RATED VOLTAGE [100%]*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_OUT_BUSFREQ" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_OUT_BUSFREQ (*$COMMENT 70187 IOBOARD/DISPLAY -OUT BUS FREQ*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_OUT_BUSVOLT" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_OUT_BUSVOLT (*$COMMENT 70186 IOBOARD/DISPLAY -OUT BUS VOLT*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_OUT_CB" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_OUT_CB (*$COMMENT 70188 IOBOARD/DISPLAY -OUT GEN CB*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_OUT_COSPHI" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_OUT_COSPHI (*$COMMENT 70196 IOBOARD -OUT GEN COSPHI (ACTUAL)*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_OUT_GENAMP" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_OUT_GENAMP (*$COMMENT 70199 IOBOARD/DISPLAY -OUT GEN AMP*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_OUT_GENFREQ" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_OUT_GENFREQ (*$COMMENT 70185 IOBOARD/DISPLAY -OUT GEN FREQ*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_OUT_GENKVAR" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_OUT_GENKVAR (*$COMMENT 70193 IOBOARD -OUT GEN KVAR (ACTUAL)*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_OUT_GENKVA" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_OUT_GENKVA (*$COMMENT 70192 IOBOARD -OUT GEN KVA (ACTUAL)*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_OUT_GENKW" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_OUT_GENKW (*$COMMENT 70197 IOBOARD/DISPLAY -OUT LOAD*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_OUT_GENVOLT" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_OUT_GENVOLT (*$COMMENT 70184 IOBOARD/DISPLAY -OUT GEN VOLT*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_P02310" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_P02310 (*$COMMENT 70365 OVER-FREQUENCY TRIP DELAY*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_P02311" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_P02311 (*$COMMENT 70366 UNDER-FREQUENCY TRIP CB*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_P02312" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_P02312 (*$COMMENT 70367 UNDER-FREQUENCY TRIP DELAY*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_P0231" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_P0231 (*$COMMENT 70356 OVER-CURRENT TRIP CB*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_P0232" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_P0232 (*$COMMENT 70357 OVER-CURRENT TRIP DELAY*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_P0233" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_P0233 (*$COMMENT 70358 REVERSE POWER TRIP CB*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_P0234" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_P0234 (*$COMMENT 70359 REVERSE POWER DELAY*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_P0235" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_P0235 (*$COMMENT 70360 OVER-VOLTAGE TRIP CB*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_P0236" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_P0236 (*$COMMENT 70361 OVER-VOLTAGE TRIP DELAY*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_P0237" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_P0237 (*$COMMENT 70362 UNDER-VOLTAGE TRIP CB*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_P0238" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_P0238 (*$COMMENT 70363 UNDER-VOLTAGE TRIP DELAY*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_P0239" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_P0239 (*$COMMENT 70364 OVER-FREQUENCY TRIP CB*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_P0511" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_P0511 (*$COMMENT 70381 DELTA VOLTAGE*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_P0512" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_P0512 (*$COMMENT 70382 DELTA FREQUENCY NEGATIVE*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_P0513" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_P0513 (*$COMMENT 70383 DELTA FREQUENCY POSITIVE*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_P0514" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_P0514 (*$COMMENT 70175 DELTA PHASE ANGLE NEGATIVE*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_P0515" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_P0515 (*$COMMENT 70176 DELTA PHASE ANGLE POSITIVE*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_P0518" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_P0518 (*$COMMENT 70177 IOBOARD TEST MODE (0=OFF/1=NO CB/2=CB)*) : INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_P0521" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_P0521 (*$COMMENT 70389 CB OPEN PULSE TIME*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_RESET" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_RESET (*$COMMENT 70191 IOBOARD - ALARM RESET*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_SAMES_BUS_FREQ" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_SAMES_BUS_FREQ (*$COMMENT 70131 (SAMES) BUS_FREQ*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_SAMES_BUS_VOLT" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_SAMES_BUS_VOLT (*$COMMENT 70135 (SAMES) BUS_PHASEVOLT_AVG*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_SAMES_GEN_AMP" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_SAMES_GEN_AMP (*$COMMENT 70146 (SAMES) GEN_IMAX *) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_SAMES_GEN_COSPHI" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_SAMES_GEN_COSPHI (*$COMMENT 70147 (SAMES) GEN_COSPHI*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_SAMES_GEN_FREQ" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_SAMES_GEN_FREQ (*$COMMENT 70138 (SAMES) GEN_FREQ*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_SAMES_GEN_KVA" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_SAMES_GEN_KVA (*$COMMENT 70158 (SAMES) GEN_APPARENT_P_TOTAL*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_SAMES_GEN_KVAR" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_SAMES_GEN_KVAR (*$COMMENT 70157 (SAMES) GEN_REACTIVE_P_TOTAL*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_SAMES_GEN_KW" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_SAMES_GEN_KW (*$COMMENT 70156 (SAMES) GEN_ACTIVE_P_TOTAL*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_SAMES_GEN_VOLT" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_SAMES_GEN_VOLT (*$COMMENT 70145 (SAMES) GEN_PHASEVOLT_AVG*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_SIM_BUSFREQ" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_SIM_BUSFREQ (*$COMMENT 70542 IOBOARD -SIM -> BUS FREQ*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_SIM_BUSVOLT" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_SIM_BUSVOLT (*$COMMENT 70541 IOBOARD -SIM -> BUS VOLT*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_SIM_CB" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_SIM_CB (*$COMMENT 70540 IOBOARD -SIM -> CIRCUIT-BREAKER*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_SIM_ENABLE" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_SIM_ENABLE (*$COMMENT 70543 IOBOARD -SIM <- SAFE/ENABLE*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_SIM_GENAMP" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_SIM_GENAMP (*$COMMENT 70537 IOBOARD -SIM -> GEN CURRENT*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_SIM_GENFREQ" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_SIM_GENFREQ (*$COMMENT 70536 IOBOARD -SIM -> GEN FREQUENCY*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_SIM_GENKW" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_SIM_GENKW (*$COMMENT 70538 IOBOARD -SIM -> GEN ACTIVE LOAD *) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_SIM_GENVOLT" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_SIM_GENVOLT (*$COMMENT 70535 IOBOARD -SIM -> GEN VOLT*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_SIM_MODE" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_SIM_MODE (*$COMMENT 70539 IOBOARD -SIM -> MODE*) : INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="IOB_XP_FUNC" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 IOB_XP_FUNC (*$COMMENT 70181 IOBOARD -CONTROLLER FUNCTION*) : INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="KEYB_BLOCK_IDLE_RUN_STOP_OFF" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 KEYB_BLOCK_IDLE_RUN_STOP_OFF (*$COMMENT 70524 KEYB -  BLOCK IDLE RUN STOP OFF*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="KEYB_BLOCK_IDLE_RUN_STOP_ON" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 KEYB_BLOCK_IDLE_RUN_STOP_ON (*$COMMENT 70523 KEYB -  BLOCK IDLE RUN STOP ON*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="KEYB_BLOCK_LOW_LOAD_STOP_OFF" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 KEYB_BLOCK_LOW_LOAD_STOP_OFF (*$COMMENT 70522 KEYB -  BLOCK LOW LOAD STOP OFF*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="KEYB_BLOCK_LOW_LOAD_STOP_ON" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 KEYB_BLOCK_LOW_LOAD_STOP_ON (*$COMMENT 70521 KEYB -  BLOCK LOW LOAD STOP ON*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="KVAR_PERC" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 KVAR_PERC (*$COMMENT 70072 GENERATOR KVAR LOAD (%)*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="KVAR_SETPOINT" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 KVAR_SETPOINT (*$COMMENT 70478 LOAD SETPOINT KVAR*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="KW_PERC" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 KW_PERC (*$COMMENT 70071 GENERATOR KW LOAD (%)*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="LAMP_TEST" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 LAMP_TEST (*$COMMENT 70099 LAMP TEST*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="LED_BUS" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 LED_BUS (*$COMMENT 70130 LED BUS VOLTAGE*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="LED_GEN" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 LED_GEN (*$COMMENT 70129 LED GENERATOR VOLTAGE*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="LMP_1ST" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 LMP_1ST (*$COMMENT 70027 LAMP - (05) 1ST*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="LMP_2ND" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 LMP_2ND (*$COMMENT 70033 LAMP - (11) 2ND*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="LMP_ALARM" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 LMP_ALARM (*$COMMENT 70034 LAMP - (12) ALARM*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="LMP_AUTO" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 LMP_AUTO (*$COMMENT 70023 LAMP - (01) AUTO *) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="LMP_CLOSE" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 LMP_CLOSE (*$COMMENT 70025 LAMP - (03) CLOSE*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="LMP_DECREASE" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 LMP_DECREASE (*$COMMENT 70032 LAMP - (10) DECREASE*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="LMP_FAULT" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 LMP_FAULT (*$COMMENT 70022 LAMP - FAULT*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="LMP_INCREASE" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 LMP_INCREASE (*$COMMENT 70026 LAMP - (04) INCREASE*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="LMP_MANUAL" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 LMP_MANUAL (*$COMMENT 70029 LAMP - (07) MANUAL*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="LMP_MENU" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 LMP_MENU (*$COMMENT 70028 LAMP - (06) MENU*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="LMP_OPEN" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 LMP_OPEN (*$COMMENT 70031 LAMP - (09) OPEN*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="LMP_RUN" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 LMP_RUN (*$COMMENT 70024 LAMP - (02) START/RUN*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="LMP_STOP" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 LMP_STOP (*$COMMENT 70030 LAMP - (08) STOP*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="LMP_SYSTEM" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 LMP_SYSTEM (*$COMMENT 70021 LAMP - SYSTEM ON*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="LOAD_SETPOINT" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 LOAD_SETPOINT (*$COMMENT 70479 LOAD SETPOINT KW*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="MBS_ACKSTOP" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 MBS_ACKSTOP (*$COMMENT 70476 MBS - PB STOP HORN+ACK*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="MBS_AUTO" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 MBS_AUTO (*$COMMENT 70466 MBS - PB AUTO *) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="MBS_CLOSE" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 MBS_CLOSE (*$COMMENT 70468 MBS - PB CLOSE*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="MBS_MANUAL" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 MBS_MANUAL (*$COMMENT 70469 MBS - PB MANUAL*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="MBS_OPEN" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 MBS_OPEN (*$COMMENT 70471 MBS - PB OPEN*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="MBS_START" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 MBS_START (*$COMMENT 70467 MBS - PB START*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="MBS_STB_1ST" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 MBS_STB_1ST (*$COMMENT 70472 MBS - PB 1ST STANDBY*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="MBS_STOP" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 MBS_STOP (*$COMMENT 70470 MBS - PB STOP*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="MIMIC_BLOCK_IDLE_RUN_STOP" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 MIMIC_BLOCK_IDLE_RUN_STOP (*$COMMENT 70484 MIMIC - PB BLOCK IDLE RUN STOP *) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="MIMIC_BLOCK_LOW_LOAD_STOP" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 MIMIC_BLOCK_LOW_LOAD_STOP (*$COMMENT 70483 MIMIC - PB BLOCK LOW LOAD STOP*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="MIMIC_DISABLED_UNBALANCED_MODE" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 MIMIC_DISABLED_UNBALANCED_MODE (*$COMMENT 70526 KEYB -  DISABLED UNBALANCED MODE*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="MIMIC_ENABLED_UNBALANCED_MODE" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 MIMIC_ENABLED_UNBALANCED_MODE (*$COMMENT 70525 KEYB -  ENABLED UNBALANCED MODE*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="MIMIC_SP_BASE_LOAD" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 MIMIC_SP_BASE_LOAD (*$COMMENT 70481 DISPLAY - SETPOINT BASELOAD*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="MM_ACKN" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 MM_ACKN (*$COMMENT 70494 MIMIC - PB ACK (RESET)*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="MM_ACKSTOP" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 MM_ACKSTOP (*$COMMENT 70496 MIMIC - PB STOP HORN+ACK*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="MM_AUTO" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 MM_AUTO (*$COMMENT 70486 MIMIC - PB AUTO *) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="MM_CLOSE" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 MM_CLOSE (*$COMMENT 70488 MIMIC - PB CLOSE*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="MM_MANUAL" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 MM_MANUAL (*$COMMENT 70489 MIMIC - PB MANUAL*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="MM_OPEN" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 MM_OPEN (*$COMMENT 70491 MIMIC - PB OPEN*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="MM_START" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 MM_START (*$COMMENT 70487 MIMIC - PB START*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="MM_STB_1ST" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 MM_STB_1ST (*$COMMENT 70492 MIMIC - PB 1ST STANDBY*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="MM_STB_2ND" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 MM_STB_2ND (*$COMMENT 70493 MIMIC - PB 2ND STANDBY*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="MM_STOPHORN" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 MM_STOPHORN (*$COMMENT 70495 MIMIC - PB STOP HORN*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="MM_STOP" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 MM_STOP (*$COMMENT 70490 MIMIC - PB STOP*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="MODE_INPUT" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 MODE_INPUT (*$COMMENT 70400 MODE INPUT*) : INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="NEXT_ALARM" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 NEXT_ALARM (*$COMMENT 70200 PULSE ON NEXT ALARM*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="OPT_DIN" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 OPT_DIN (*$COMMENT 70101 DIN1 - OPTION*) : ARRAY[1..8] OF BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="OPT_DOUT" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 OPT_DOUT (*$COMMENT 70115 DOUT15 - OPTION*) : ARRAY[1..8] OF BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="OWNBUS_AVAILKW" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 OWNBUS_AVAILKW (*$COMMENT 70098 OWN BUS: KW AVAILABLE*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="OWNBUS_LOADKW" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 OWNBUS_LOADKW (*$COMMENT 70093 OWN BUS: KW LOAD*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="OWNBUS_POWERKW" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 OWNBUS_POWERKW (*$COMMENT 70092 OWN BUS: KW CAPABILITY *) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0111" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0111 (*$COMMENT 70301 PMS CONTROLLER NO.*) : INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0112" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0112 (*$COMMENT 70302 PMS APPLICATION VERSION*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0121" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0121 (*$COMMENT 70309 TYPE 1 - 1X BUS (1)*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0122" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0122 (*$COMMENT 70310 TYPE 2 - 2X BUS (1 / 2)*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0123" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0123 (*$COMMENT 70311 TYPE 3 - 3X BUS (1 / 2 / 3)*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0124" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0124 (*$COMMENT 70312 TYPE 4 - 4X BUS (1 / 2 / 3 / 4 / 1)*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0125" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0125 (*$COMMENT 70313 TYPE 5 - 5X BUS (1 / 2 / 3 / 4 / 5 / 1)*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0131" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0131 (*$COMMENT 70317 DIESEL / TURBINE GENERATOR*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0132" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0132 (*$COMMENT 70318 EMERGENCY GENERATOR*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0133" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0133 (*$COMMENT 70319 SHAFT GENERATOR*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0134" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0134 (*$COMMENT 70320 SHORE SUPPLY*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0135" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0135 (*$COMMENT 70321 AUTOMATIC BUS-TIE*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0141" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0141 (*$COMMENT 70323 CONNECTED TO BUS NO.*) : INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0142" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0142 (*$COMMENT 70324 GENERATOR NOMINAL VOLTAGE*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0143" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0143 (*$COMMENT 70325 GENERATOR NOMINAL FREQUENCY*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0144" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0144 (*$COMMENT 70326 GENERATOR CAPACITY*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0145" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0145 (*$COMMENT 70327 GENERATOR POWER FACTOR*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0146" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0146 (*$COMMENT 70328 GENERATOR RATED CURRENT*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0147" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0147 (*$COMMENT 70329 (ENGINE) CAPACITY*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0161" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0161 (*$COMMENT 70331 ENABLE STANDBY START*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0162" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0162 (*$COMMENT 70332 BLACKOUT PREVENT IN MANUAL*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0163" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0163 (*$COMMENT 70333 LAST ON = FIRST OFF (dynamic sequence)*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0164" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0164 (*$COMMENT 70334 FIRST START = FIRST TO STOP*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0165" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0165 (*$COMMENT 70330 ENABLE AUTO CLOSE BREAKER (AUTO MODE)*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0166" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0166 (*$COMMENT 70335 PREFERENTIAL TRIP ON LOW FREQUENCY ALARM*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0167" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0167 (*$COMMENT 70384 MAXIMUM NUMBER OF GENERATORS ON THE BUS*) : INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0211" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0211 (*$COMMENT 70338 HIGH VOLTAGE ALARM*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0212" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0212 (*$COMMENT 70339 HIGH VOLTAGE DELAY*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0213" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0213 (*$COMMENT 70340 LOW VOLTAGE ALARM*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0214" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0214 (*$COMMENT 70341 LOW VOLTAGE DELAY*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0215" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0215 (*$COMMENT 70342 HIGH FREQUENCY ALARM*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0216" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0216 (*$COMMENT 70343 HIGH FREQUENCY DELAY*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0217" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0217 (*$COMMENT 70344 LOW FREQUENCY ALARM*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0218" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0218 (*$COMMENT 70345 LOW FREQUENCY DELAY*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0221" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0221 (*$COMMENT 70347 HIGH VOLTAGE ALARM*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0222" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0222 (*$COMMENT 70348 HIGH VOLTAGE DELAY*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0223" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0223 (*$COMMENT 70349 LOW VOLTAGE ALARM*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0224" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0224 (*$COMMENT 70350 LOW VOLTAGE DELAY*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0225" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0225 (*$COMMENT 70351 HIGH FREQUENCY ALARM*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0226" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0226 (*$COMMENT 70352 HIGH FREQUENCY DELAY*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0227" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0227 (*$COMMENT 70353 LOW FREQUENCY ALARM*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0228" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0228 (*$COMMENT 70354 LOW FREQUENCY DELAY*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0241" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0241 (*$COMMENT 70336 OVER-LOAD ALARM*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0242" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0242 (*$COMMENT 70337 OVER-LOAD DELAY*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P031X" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P031X (*$COMMENT 70501 DIN1 - INPUT CODE*) : ARRAY[1..8] OF INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P032X" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P032X (*$COMMENT 70509 DOUT15 - OUTPUT CODE*) : ARRAY[1..8] OF INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0411" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0411 (*$COMMENT 70369 MAXIMUM START PULSE*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0412" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0412 (*$COMMENT 70370 NUMBER OF START ATTEMPTS*) : INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0413" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0413 (*$COMMENT 70371 RE-START DELAY*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0414" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0414 (*$COMMENT 70372 PRE-LUBRICATION TIME*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0421" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0421 (*$COMMENT 70374 STOP PULSE TIME*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0422" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0422 (*$COMMENT 70375 ENGINE COOLDOWN TIME*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0423" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0423 (*$COMMENT 70376 COOLDOWN AFTER PRE-ALARM*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0431" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0431 (*$COMMENT 70378 VOLTAGE ENERGIZED LEVEL*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0432" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0432 (*$COMMENT 70379 ENERGIZED DETECT DELAY*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0441" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0441 (*$COMMENT 70373 READY TO START OFF DELAY (WHEN STARTING)*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0516" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0516 (*$COMMENT 70386 CB CLOSE PULSE TIME*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0517" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0517 (*$COMMENT 70387 MAXIMUM SYNC TIME*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0522" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0522 (*$COMMENT 70390 LOW LOAD LIMIT TO OPEN CB*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0523" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0523 (*$COMMENT 70391 MAX. OFFLOAD (PARALLEL) TIME*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0531" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0531 (*$COMMENT 70393 WITH OFFLOAD FAIL*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0532" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0532 (*$COMMENT 70394 AFTER ENGINE PRE-ALARM SUBST.*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0533" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0533 (*$COMMENT 70395 AFTER BUS ALARM SUBST.*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0611" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0611 (*$COMMENT 70397 FREQUENCY - PROP. BAND*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0612" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0612 (*$COMMENT 70398 FREQUENCY - DEAD BAND*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0613" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0613 (*$COMMENT 70399 ACTIVE LOAD - PROP. BAND*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0614" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0614 (*$COMMENT 70401 ACTIVE LOAD - DEAD BAND*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0615" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0615 (*$COMMENT 70402 MIN. PULSE TIME*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0616" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0616 (*$COMMENT 70403 MAX. PULSE TIME/CYCLE TIME*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0621" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0621 (*$COMMENT 70405 VOLTAGE - PROP. BAND*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0622" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0622 (*$COMMENT 70406 VOLTAGE - DEAD BAND*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0623" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0623 (*$COMMENT 70407 REACTIVE LOAD - PROP. BAND*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0624" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0624 (*$COMMENT 70408 REACTIVE LOAD - DEAD BAND*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0625" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0625 (*$COMMENT 70409 MIN. PULSE TIME*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0626" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0626 (*$COMMENT 70410 MAX. PULSE TIME/CYCLE TIME*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0627" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0627 (*$COMMENT 70404 VOLTAGE CONTROL*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0631" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0631 (*$COMMENT 70411 ENABLE UNBALANCED MODE*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0632" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0632 (*$COMMENT 70412 LOW BUS LOAD TO RESET*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0633" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0633 (*$COMMENT 70413 TIME TO RESET*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0641" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0641 (*$COMMENT 70414 MAX. UNBALANCE DEVIATION*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0642" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0642 (*$COMMENT 70415 LOAD UNBALANCE DELAY*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0711" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0711 (*$COMMENT 70417 BLACKOUT RECOVERY DELAY*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0721" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0721 (*$COMMENT 70419 HIGH LOAD - LEVEL 1*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0722" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0722 (*$COMMENT 70420 HIGH LOAD - DELAY 1*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0723" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0723 (*$COMMENT 70421 HIGH LOAD - LEVEL 2*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0724" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0724 (*$COMMENT 70422 HIGH LOAD - DELAY 2*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0725" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0725 (*$COMMENT 70423 HIGH LOAD - LEVEL 3*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0726" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0726 (*$COMMENT 70424 HIGH LOAD - DELAY 3*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0727" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0727 (*$COMMENT 70425 HIGH CURRENT*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0728" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0728 (*$COMMENT 70426 HIGH CURRENT DELAY*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0731" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0731 (*$COMMENT 70428 BUS RESERVE TO PREVENT B/O*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0732" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0732 (*$COMMENT 70429 AUTO STOP DELAY*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0741" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0741 (*$COMMENT 70432 WITH CB TRIP*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0742" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0742 (*$COMMENT 70433 WITH NON-PREF. (LOAD) TRIP*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0743" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0743 (*$COMMENT 70434 WITH BUS ALARM*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0801" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0801 (*$COMMENT 70436 BUS NUMBER CONSUMER BLOCKS*) : INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0802" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0802 (*$COMMENT 70437 CONSUMER ACCEPT DELAY*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0851" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0851 (*$COMMENT 70435 RUNNING FEEDBACK DELAY*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P08X1" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P08X1 (*$COMMENT 70438 REQUIRED LOAD CONS 1*) : ARRAY[1..4] OF FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P08X2" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P08X2 (*$COMMENT 70439 REQUIRED GENERATORS CONS 1*) : ARRAY[1..4] OF INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0901" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0901 (*$COMMENT 70447  BUS NUMBER NON-PREF TRIPS*) : INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0911" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0911 (*$COMMENT 70448 LOAD H-LIMIT TO TRIP NON-PREF 1*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0912" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0912 (*$COMMENT 70449 TRIP DELAY NON-PREF 1*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0921" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0921 (*$COMMENT 70451 LOAD H-LIMIT TO TRIP NON-PREF 2*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0922" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0922 (*$COMMENT 70452 TRIP DELAY NON-PREF 2*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0931" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0931 (*$COMMENT 70454 LOAD H-LIMIT TO TRIP NON-PREF 3*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0932" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0932 (*$COMMENT 70455 TRIP DELAY NON-PREF 3*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0941" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0941 (*$COMMENT 70457 LOAD H-LIMIT TO TRIP NON-PREF 4*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="P0942" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 P0942 (*$COMMENT 70458 TRIP DELAY NON-PREF 4*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="PB_1ST" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 PB_1ST (*$COMMENT 70011 PUSHBUTTON - (05) 1ST*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="PB_2ND" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 PB_2ND (*$COMMENT 70017 PUSHBUTTON - (11) 2ND*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="PB_ACKN" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 PB_ACKN (*$COMMENT 70001 PUSHBUTTON - ACKN*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="PB_ALARM" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 PB_ALARM (*$COMMENT 70018 PUSHBUTTON - (12) ALARM*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="PB_AUTO" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 PB_AUTO (*$COMMENT 70007 PUSHBUTTON - (01) AUTO *) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="PB_CLOSE" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 PB_CLOSE (*$COMMENT 70009 PUSHBUTTON - (03) CLOSE*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="PB_DECREASE" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 PB_DECREASE (*$COMMENT 70016 PUSHBUTTON - (10) DECREASE*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="PB_DOWN" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 PB_DOWN (*$COMMENT 70006 PUSHBUTTON - DOWN*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="PB_INCREASE" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 PB_INCREASE (*$COMMENT 70010 PUSHBUTTON - (04) INCREASE*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="PB_LEFT" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 PB_LEFT (*$COMMENT 70002 PUSHBUTTON - LEFT*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="PB_MANUAL" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 PB_MANUAL (*$COMMENT 70013 PUSHBUTTON - (07) MANUAL*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="PB_MENU" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 PB_MENU (*$COMMENT 70012 PUSHBUTTON - (06) MENU*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="PB_OPEN" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 PB_OPEN (*$COMMENT 70015 PUSHBUTTON - (09) OPEN*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="PB_RIGHT" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 PB_RIGHT (*$COMMENT 70003 PUSHBUTTON - RIGHT*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="PB_START" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 PB_START (*$COMMENT 70008 PUSHBUTTON - (02) START/RUN*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="PB_STH" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 PB_STH (*$COMMENT 70004 PUSHBUTTON - STOP HORN*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="PB_STOP" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 PB_STOP (*$COMMENT 70014 PUSHBUTTON - (08) STOP*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="PB_UP" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 PB_UP (*$COMMENT 70005 PUSHBUTTON - UP*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="PMS_DISPLAY" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 PMS_DISPLAY (*$COMMENT 70190 DISPLAY SELECTION: DG / BT / SHORE*) : INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="READY2START" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 READY2START (*$COMMENT 70078 GENERATOR READY TO START*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="RUNNING" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 RUNNING (*$COMMENT 70083 GENERATOR RUNNING*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="SHUTDOWN" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 SHUTDOWN (*$COMMENT 70086 GENERATOR SHUTDOWN*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="SIM_AMP_DG" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 SIM_AMP_DG (*$COMMENT 95145 DG1 - CURRENT*) : ARRAY[1..15] OF FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="SIM_BT" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 SIM_BT (*$COMMENT 95068 BT1/2 - BREAKER CLOSED (A)*) : ARRAY[1..6] OF BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="SIM_BUSFREQ_DG" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 SIM_BUSFREQ_DG (*$COMMENT 95142 DG1 - BUS FREQUENCY*) : ARRAY[1..15] OF FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="SIM_BUSVOLT_DG" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 SIM_BUSVOLT_DG (*$COMMENT 95141 DG1 - BUS VOLTAGE*) : ARRAY[1..15] OF FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="SIM_FREQ_DG" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 SIM_FREQ_DG (*$COMMENT 95144 DG1 - FREQUENCY*) : ARRAY[1..15] OF FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="SIM_IN_CODE" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 SIM_IN_CODE (*$COMMENT 95151 DG1 - SIMULATION OUTPUT CODE*) : ARRAY[1..15] OF INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="SIM_KVAR_DG" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 SIM_KVAR_DG (*$COMMENT 95147 DG1 - REACTIVE LOAD*) : ARRAY[1..15] OF FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="SIM_KW_DG" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 SIM_KW_DG (*$COMMENT 95146 DG1 - ACTIVE LOAD*) : ARRAY[1..15] OF FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="SIM_MODE" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 SIM_MODE (*$COMMENT 95026 PMS SIMULATOR MODE*) : INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="SIM_VOLT_DG" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 SIM_VOLT_DG (*$COMMENT 95143 DG1 - VOLTAGE*) : ARRAY[1..15] OF FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="SP_BASE_LOAD" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 SP_BASE_LOAD (*$COMMENT 70182 DISPLAY - SETPOINT BASELOAD*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="STB_1ST" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 STB_1ST (*$COMMENT 70076 GENERATOR FIRST STANDBY*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="STB_2ND" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 STB_2ND (*$COMMENT 70077 GENERATOR SECOND STANDBY*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="STB_SEQUENCE" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 STB_SEQUENCE (*$COMMENT 70089 STANDBY SEQUENCE NO*) : INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="STOP_1ST" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 STOP_1ST (*$COMMENT 70088 GENERATOR FIRST TO STOP*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="TYPE_DISPLAY" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 TYPE_DISPLAY (*$COMMENT 70189 DISPLAY SELECTION: PMS / ALARM / MENU*) : INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="UNBALANCED_MODE" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 UNBALANCED_MODE (*$COMMENT 70482 UNBALANCED MODE ACTIVE*) : BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="VOLT_PERC" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 VOLT_PERC (*$COMMENT 70073 GENERATOR VOLTAGE (%)*) : FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_ADDRESS" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _ADDRESS (*$COMMENT 61041 CONTROLLER ADDRESS*) : ARRAY[1..15] OF INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_ALM229" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _ALM229 (*$COMMENT 61267 SHORT-CIRCUIT DEVICE TRIPPED CB*) : ARRAY[1..15] OF BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_BREAKER" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _BREAKER (*$COMMENT 61048 BREAKER CLOSED*) : ARRAY[1..15] OF BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_BT_A" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _BT_A (*$COMMENT 61067 BUS-TIE #A STATUS (TO LOWER)*) : ARRAY[1..15] OF BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_BT_B" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _BT_B (*$COMMENT 61068 BUS-TIE #B STATUS (TO HIGHER)*) : ARRAY[1..15] OF BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_BUS" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _BUS (*$COMMENT 61043 BUS NUMBER*) : ARRAY[1..15] OF INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_BUS_ABN" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _BUS_ABN (*$COMMENT 61500 DG1 ANY BUS ABNORMAL*) : ARRAY[1..15] OF BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_FUNC" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _FUNC (*$COMMENT 61042 CONTROLLER FUNCTION*) : ARRAY[1..15] OF INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_GRID" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _GRID (*$COMMENT 61039 CONTROLLER GRID*) : ARRAY[1..15] OF INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_HVY_REQ_BUSY" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _HVY_REQ_BUSY (*$COMMENT 61058 HEAVY CONSUMER REQUEST BUSY*) : ARRAY[1..15] OF INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_INH_AUTOSTOP" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _INH_AUTOSTOP (*$COMMENT 61069 INHIBIT AUTO STOP*) : ARRAY[1..15] OF BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_KVAR_LOAD" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _KVAR_LOAD (*$COMMENT 61047 ACTUAL KVAR LOAD*) : ARRAY[1..15] OF FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_KVAR_POWER" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _KVAR_POWER (*$COMMENT 61046 AVAILABLE KVAR CAPABILITY*) : ARRAY[1..15] OF FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_KW_LOAD" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _KW_LOAD (*$COMMENT 61045 ACTUAL KW LOAD*) : ARRAY[1..15] OF FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_KW_POWER" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _KW_POWER (*$COMMENT 61044 AVAILABLE KW CAPABILITY*) : ARRAY[1..15] OF FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_LIVE_CHECK" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _LIVE_CHECK (*$COMMENT 61051 LIVE CHECK*) : ARRAY[1..15] OF INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_MODUS" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _MODUS (*$COMMENT 61040 CONTROLLER MODE*) : ARRAY[1..15] OF INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_OFFLOADING" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _OFFLOADING (*$COMMENT 61081 GENERATOR OFFLOADING*) : ARRAY[1..15] OF BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_OFFLOAD_BUSX" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _OFFLOAD_BUSX (*$COMMENT 61059 OFFLOAD BUS X*) : ARRAY[1..15] OF INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_SEQ_CODEA" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _SEQ_CODEA (*$COMMENT 61056 STANDBY SEQUENCE CODE GEN 1 - 4*) : ARRAY[1..15] OF WORD;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_SEQ_CODEB" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _SEQ_CODEB (*$COMMENT 61057 STANDBY SEQUENCE CODE GEN 5-8*) : ARRAY[1..15] OF WORD;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_SEQ_CODEC" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _SEQ_CODEC (*$COMMENT 61063 STANDBY SEQUENCE CODE GEN 9 - 12*) : ARRAY[1..15] OF WORD;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_SEQ_CODED" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _SEQ_CODED (*$COMMENT 61064 STANDBY SEQUENCE CODE GEN 13 -15*) : ARRAY[1..15] OF WORD;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_SHARED" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _SHARED (*$COMMENT 61050 INCLUDED IN LOAD SHARING*) : ARRAY[1..15] OF BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_STANDBY_REQUEST" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _STANDBY_REQUEST (*$COMMENT 61053 STANDBY REQUEST*) : ARRAY[1..15] OF BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_STARTING" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _STARTING (*$COMMENT 61079 GENERATOR STARTING*) : ARRAY[1..15] OF BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_STBYREQ_HVY_BUSX" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _STBYREQ_HVY_BUSX (*$COMMENT 61054 BUS # OF STANDBY REQ. BY CONSUMERS*) : ARRAY[1..15] OF INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_STBYREQ_TRP_BUSX" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _STBYREQ_TRP_BUSX (*$COMMENT 61055 BUS # OF STANDBY REQ. BY NON-PREF. TRIP*) : ARRAY[1..15] OF INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_STB_READY" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _STB_READY (*$COMMENT 61070 STANDBY READY*) : ARRAY[1..15] OF BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_STOPPING" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _STOPPING (*$COMMENT 61084 GENERATOR STOPPING*) : ARRAY[1..15] OF BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_STOP_HORN" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _STOP_HORN (*$COMMENT 61019 STOP HORN OUT*) : ARRAY[1..15] OF BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_SYNCHRONIZING" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _SYNCHRONIZING (*$COMMENT 61080 GENERATOR SYNCHRONIZING*) : ARRAY[1..15] OF BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_SYNC_BUSX" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _SYNC_BUSX (*$COMMENT 61060 SYNC BUS X*) : ARRAY[1..15] OF INT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_SYNC_FREQ_SETP" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _SYNC_FREQ_SETP (*$COMMENT 61061 SYNC BUS X FREQUENCY SETPOINT*) : ARRAY[1..15] OF FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_SYNC_VOLT_SETP" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _SYNC_VOLT_SETP (*$COMMENT 61062 SYNC BUS X VOLTAGE SETPOINT*) : ARRAY[1..15] OF FINT;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_TRIP_ALLAUTOCB" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _TRIP_ALLAUTOCB (*$COMMENT 61066 CB TRIP ALL AUTO CMND*) : ARRAY[1..15] OF BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_TRIP_ALLCB" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _TRIP_ALLCB (*$COMMENT 61065 CB TRIP ALL COMMAND*) : ARRAY[1..15] OF BOOL;
END_VAR]]></ITEM>
      <ITEM type="VAR" name="_TRIP_GRP_BUSX" flags="00804000"><![CDATA[VAR_GLOBAL (*$CHANNEL*) 
 _TRIP_GRP_BUSX (*$COMMENT 61052 BUS # OF NON-PREF. GROUPS TO BE TRIPPED *) : ARRAY[1..15] OF INT;
END_VAR]]></ITEM>
    </GLOBAL>
    <TASK>
      <ITEM type="TSK" name="TASK" loop_kind="0" interval="100"><![CDATA[GLOB_VAR
CHECK_SETTINGS
GENERAL
INPUTS
IOB_MEASURE
GEN_CALCULATE
BUS_TIES
BUS_CALCULATE
BUS_ALARMS
OPERATION_MODE
STANDBY_SEQUENCE
AUT_STOP
AUT_START
REQUEST_STANDBY
PRG_ENERGIZING
CONNECTING
DISCONNECTING
PRG_STOPPING
MOTOR
CONTROL_LOAD
CONTROL_VOLT
CONTROLLERS
CONSUMER_BLOCK
NONPREF_TRIP
GROUP_ALARMS
OUTPUTS
DISPLAY
IOB_CB_TRIP
]]></ITEM>
    </TASK>
  </PROJECT>
</PAL1131>

