(*$LIBRARY XP76*)
(*$IMPORT IEC_61131
filename: 'Libraries\IEC 61131-3.lcp'
version: '0.2.0.0'
timestamp: '2020-10-05-13:27:27.810'
fblks: CTD, CTU, CTUD, F_TRIG, R_TRIG, RS, SEMA, SR, TOF, TON, TP
*)
(*$IMPORT Praxis_FUNC
filename: 'Libraries\Praxis_FUNC.lcp'
version: '0.2.0.0'
timestamp: '2020-10-05-13:27:28.087'
funs: FINT_TO_TIME, TIME_TO_FINT, FINT_TO_INT, INT_TO_FINT, DIV0, ABS_FINT, SQRT_FINT, HZ_TO_RPM, MAX_FINT, MIN_FINT, ANGLE180, ANGLE360, ATAN2, DEG_TO_RAD, RAD_TO_DEG, SET_BIT, GET_BIT, RESET_BIT
*)
(*$IMPORT PRAXIS_HW
filename: 'Libraries\Praxis_HW.lcp'
version: '0.2.0.0'
timestamp: '2020-10-05-13:27:28.018'
fblks: HW_LOAD, HW_XP, HW_TIMING, HW_VERSIONS, HW_SCROLL_UP, HW_SCROLL_DOWN, HW_ACCEPT, HW_BUTTON_ID, HW_TOUCH_GET_THR, HW_TOUCH_SET_THR, HW_SET_ALT_LANG, HW_GET_ALT_LANG, HW_GET_ALARM_PULSE_ON_NEXT, HW_GET_UNACCEPT, HW_GET_UNACCEPT_ALM, HW_SET_TFT_PAGE, HW_GET_TFT_PAGE, HW_SET_TFT_FLASH, HW_DETACH_ELVR, HW_GETSTATUS_ELVR, HW_GETSTATUS_IOW24, HW_SPEED_ELVR, HW_STEER_ELVR, HW_MENU_PUBLIC_KEY, HW_MENU_FIRST_PAGE, HW_MENU_AFTER_LOGIN_PULSE, HW_MENU_PW_CHANGE, HW_GET_TFT_FLASH, HW_SET_RD_ACTIVE, HW_SET_WOODS_JIS, RETAIN_TO_FACTORY, FACTORY_TO_RETAIN, HW_GET_ALARM_PULSE_ON_NEXT_V02, HW_GET_UNACCEPT_V02, HW_GET_UNACCEPT_ALM_V02, HW_SET_TFT_ALM_SUM_DAY_WEEK_MON, SET_ORIENTATION, HW_SET_RD_COMPORT, LONG_FOLLOWUP, HW_MENU_TOUCH_FUNCTION, HW_MENU_TOUCH_BUTTON_PRESS, HW_GET_EAS_RESET_SIGNAL, HW_SET_TFT_GROUP_NR_PAGE, HW_ORD_PRN_SET_ON_OFF, HW_ORD_PRN_PERIODIC_PRINT, HW_ORD_PRN_PERIODIC_HOURS, HW_ORD_PRN_PRINT_STATUS, HW_SHOW_MENU_SET_DATE, HW_SHOW_MENU_SET_TIME, HW_FORCE_REDRAW_DISPLAY, HW_ORD_PRN_GET_STATUS_INFO, HW_TFT_EAS_SEND_STOP_HORN, HW_TFT_EAS_SEND_ACK
*)
(* GLOBAL VARIABLES *)
VAR_GLOBAL (*$CHANNEL*) 
 BUTTON_1 (*$COMMENT 76001 BUTTON 1*) : BOOL;
END_VAR

VAR_GLOBAL (*$CHANNEL*) 
 BUTTON_2 (*$COMMENT 76002 BUTTON 2*) : BOOL;
END_VAR

VAR_GLOBAL (*$CHANNEL*) 
 BUTTON_3 (*$COMMENT 76003 BUTTON 3*) : BOOL;
END_VAR

VAR_GLOBAL (*$CHANNEL*) 
 BUTTON_4 (*$COMMENT 76004 BUTTON 4*) : BOOL;
END_VAR

VAR_GLOBAL (*$CHANNEL*) 
 BUTTON_5 (*$COMMENT 76005 BUTTON 5*) : BOOL;
END_VAR

VAR_GLOBAL (*$CHANNEL*) 
 BUTTON_6 (*$COMMENT 76006 BUTTON 6*) : BOOL;
END_VAR

VAR_GLOBAL (*$CHANNEL*) 
 EXT_DIM (*$COMMENT 76017 OUTPUT - PWM*) : FINT;
END_VAR

VAR_GLOBAL (*$CHANNEL*) 
 TFT_DIM (*$COMMENT 76018 OUTPUT - DIMMING TFT BACKLIGHT*) : FINT;
END_VAR

VAR_GLOBAL (*$CHANNEL*) 
 HORN_RELAIS_OUTPUT (*$COMMENT 76021 HORN RELAIS OUTPUT FOLLOW CHANNEL*) : BOOL;
END_VAR

VAR_GLOBAL (*$CHANNEL*) 
 LOCAL_BUZZER (*$COMMENT 76022 LOCAL BUZZER FOLLOW CHANNEL*) : BOOL;
END_VAR

VAR_GLOBAL (*$CHANNEL*) 
 STOP_HORN_INPUT (*$COMMENT 76023 STOP HORN INPUT*) : BOOL;
END_VAR

(* USER POUs *)
FUNCTION_BLOCK FLASHER
(***************************************************************************************************************
flasher with settable pulse & duty cycle

****************************************************************************************************************
SOURCE:            PCS_LIB

FUNCTION VERSION:  1
UPDATE:            library version creation
***************************************************************************************************************)

VAR_INPUT                                                                                                                       
   START : BOOL ;
   PULSE : FINT ; // PULSE TIME [MSEC] 
   CYCLE : FINT ; // CYCLE TIME [MSEC] 
   TSCAN : FINT ; // PROGRAM LOOP TIME [MSEC] 
END_VAR
VAR_OUTPUT
   Q :    BOOL;

END_VAR
VAR
 
  ET: FINT;
  
END_VAR  


// ##############################################

IF START THEN
   ET := ET + TSCAN ;
   IF ET>=CYCLE THEN
      ET:= FINT#0;
   END_IF
   Q:=  ET<=PULSE ;   
ELSE
   ET:= FINT#0 ;
END_IF

   

END_FUNCTION_BLOCK

FUNCTION_BLOCK HW_READ_GROUP_DESC
(*$HARDWARE_BODY_CALL ID:0059; Align:1*)
(*$COMMENT HW_READ_GROUP_DESC*)

VAR_INPUT 
iGroupNr   (*$COMMENT 1..255*) :INT;
iAlt       (*$COMMENT 0..1*)   :INT;
END_VAR
VAR_OUTPUT
szText :STRING[40];
END_VAR

END_FUNCTION_BLOCK

FUNCTION_BLOCK HW_READ_EAS_DESC
(*$HARDWARE_BODY_CALL ID:0057; Align:2*)
(*$COMMENT HW_SET_GROUP_DESC*)

VAR_INPUT 
iIndex   (*$COMMENT 1..255*) :INT;
iAlt     (*$COMMENT 0..1*)   :INT;
END_VAR

VAR_OUTPUT
szResult :STRING[24];
END_VAR 

END_FUNCTION_BLOCK

FUNCTION_BLOCK HW_SET_CHANNEL_NR
(*$HARDWARE_BODY_CALL ID:0077; Align:2*)
(*$COMMENT HW_SET_CHANNEL_NR*)

VAR_INPUT 
iNumber   (*$COMMENT 1001..109499*) :DINT;
END_VAR

VAR_OUTPUT
END_VAR 

END_FUNCTION_BLOCK

PROGRAM GLOBALS
 VAR_EXTERNAL (*$AUTO*) END_VAR
 

 // APPLICATION REVISIONS ------------------------------------------------------------- 
 // ----------------------------------------------------------------------------------- 
 // USE FOLLOWING APPLICATION REVISION NUMBER TEMPLATE :                                
 // *****   YYXXXS.SSX   *******    
 // WHERE:  YYXXX       = PROJECT SPECIAL FOR PROJECT NPYY-XXX   
 //              S.SS   = STANDARD EAS APPLICATION NUMBER        
 //                  X  = SPECIAL                                
 
 //**********************************
 // REVISION :    1.00               
 // DATE     :    2018, AUGUST-24     
 // AUTHOR   :    DO                 
 // ADDED    :    INITIAL VERSION 5.7' TFT TOUCH EAS Cabins and Mess     
 // UPDATED POU:  ALL  
 // TESTED WITH:  Release: 2018-08-04 (6.0.1.7) Update 01            

 //**********************************
 // REVISION :    1.01               
 // DATE     :    2018, NOVEMBER-2     
 // AUTHOR   :    DO                 
 // ADDED    :    NO SERVER CONNECTION + BMP / STOPHORN MESS PANEL RECEIVED CABIN PANEL      
 // UPDATED POU:  MAIN  
 // TESTED WITH:  Release: 2018-08-04 (6.0.1.7) Update 02             

 //**********************************
 // REVISION :    1.02               
 // DATE     :    2018, DECEMBER 11     
 // AUTHOR   :    DO                 
 // ADDED    :    Return To Default Dimming when alarm at on duty panel when max dimmed
 // ADDED    :    Remove HORN2ISON variable 
 // UPDATED POU:  MAIN, DIMMING    
 // TESTED WITH:  Release: 2018-08-04 (6.0.1.7) Update 03  
 // SYSTEM SOFTWARE: IOSEVER + TFT_EAS_FW  
 // ESIO-77 Fix: IOServer at EASServer for EAS TFT add handling when TFT becomes not present.  
 // ESTT-70  Add: having a EAS TFT if there is no connection to ioserver anymore the alarm list becomes empty 
 // ESTT-71  EAS TFT change PAL1131 program for dimming when a new alarm is triggered and panel is on duty, 
 //          the dimming should go back to at least readible percentage like 35%. 
 //**********************************

 //**********************************
 // REVISION :    1.03               
 // DATE     :    2019, June 25     
 // AUTHOR   :    DO                 
 // ADDED    :    
 // ADDED    :     
 // UPDATED POU:      
 // TESTED WITH:  Release: 2019-04-27 (6.0.1.9) Update 02  
 // SYSTEM SOFTWARE: IOSEVER + TFT_EAS_FW  
 // ESIO-91   Add: Group Overview and group page  
 // ESIO-102  Add: Group panel fix 
 // ESIO-103  Add: Alarm panel fix  
 //**********************************

 //**********************************
 // REVISION :    1.04               
 // DATE     :    2022, January 27     
 // AUTHOR   :    DO                 
 // ADDED    :    
 // ADDED    :     
 // UPDATED POU:      
 // TESTED WITH:  Release 2021-10-16 (6.0.1.19) Update 0  
 // SYSTEM SOFTWARE: IOSEVER + TFT_EAS_FW  
 // ESTT-xx   Add: Retrigger horn when alarm on same group  
 //**********************************
 
 VAR
 END_VAR
 
 VAR_GLOBAL
  
   DISPLAY_NUMBER: INT:=0;
   
   BUTTON_TEXT_NR_1: STRING[40];
   BUTTON_TEXT_NR_2: STRING[40];
   BUTTON_TEXT_NR_3: STRING[40];
   BUTTON_TEXT_NR_4: STRING[40];
   BUTTON_TEXT_NR_5: STRING[40];
   BUTTON_TEXT_NR_6: STRING[40];
   BUTTON_TEXT_NR_7: STRING[40];
   BUTTON_TEXT_NR_8: STRING[40];
   BUTTON_TEXT_NR_9: STRING[40];
   BUTTON_TEXT_NR_10: STRING[40];
   BUTTON_TEXT_NR_11: STRING[40];
   BUTTON_TEXT_NR_12: STRING[40];
   BUTTON_TEXT_NR_13: STRING[24];   
   EAS_TEXT_ENG_SEL: STRING[24];
      
   ENGONDUTY:   INT;
   PREWARNING:  INT;
   ATTENDED:    BOOL;
   UNATTENDED:  BOOL;
   TIMEROFF:    BOOL;
   ACKUNATTENDEDENABLED:  BOOL;
   ACKCABINPENDING:  BOOL;
   REQUESTUNATTENDED:  BOOL;
   ALONGSIDE:   BOOL;
   HORN1ISON:   BOOL;
   HORN2ISON:   BOOL;
   DISPLAYLOCALTIME:  BOOL;
   PATROLTIMER: INT;
   
   CALL:       BOOL;   
   CALL_ENG:    INT;
   CALL_ALL:   BOOL;
   CALLER_ID:  BYTE;
   DATE_TEXT:  STRING[11]; //05-12-2018
   TIME_TEXT:  STRING[9]; //05:16:78   

   GEAON:      BYTE;
   DEADMANON:  BYTE;
   EXT_HORN_ACTIVE:  BYTE;
   HORN_STATUS: BYTE;
   
   TYPE_PANEL: BYTE;
   HORN_MODE: BYTE;
   HORN_RESET: BYTE;
   DIMMING_IOS: BYTE;
       
   GROUP_NR:            ARRAY[0..255] OF BYTE; 
   NR_OF_ALARMS:        ARRAY[0..255] OF BYTE;
   NR_OF_NOTACK_ALARMS: ARRAY[0..255] OF BYTE;  
   GROUP_HORN_CFG:      ARRAY[0..64] OF BYTE;
      
   CFG_TURN_HORN_ON: BYTE;
   CFG_ACCEPT: BYTE;
   CFG_RESET_HORN_1: BYTE;
   CFG_RESET_HORN_2: BYTE;
   
   USE_GROUP_ZERO: BOOL;
   ENGONSTANDBY:   INT; //eng active 0 or 1 show on page
   STANDBYON: BYTE;     //timer enlapsed turn horn on
   CFG_ACCEPT_UNATT: BOOL;
              
    //BUTTON_TEXT_NR_1:ARRAY[0..32] OF BYTE;       
   BUTTON_ACTIVE_NR_1: BOOL;
   BUTTON_ACTIVE_NR_2: BOOL;
   BUTTON_ACTIVE_NR_3: BOOL;
   BUTTON_ACTIVE_NR_4: BOOL;
   BUTTON_ACTIVE_NR_5: BOOL;
   BUTTON_ACTIVE_NR_6: BOOL;
   BUTTON_ACTIVE_NR_7: BOOL;
   BUTTON_ACTIVE_NR_8: BOOL;
   BUTTON_ACTIVE_NR_9: BOOL;
   BUTTON_ACTIVE_NR_10: BOOL;
   BUTTON_ACTIVE_NR_11: BOOL;
   BUTTON_ACTIVE_NR_12: BOOL;
   BUTTON_ACTIVE_NR_13: BOOL;
   
   STARTUP_MAIN: BOOL := TRUE;
   STARTUP_BACK: BOOL := FALSE;
    
   BUTTON_NR1_STATE : INT;
   BUTTON_NR2_STATE : INT;  
   BUTTON_NR3_STATE : INT;
   BUTTON_NR4_STATE : INT;  
   BUTTON_NR5_STATE : INT;
   BUTTON_NR6_STATE : INT;  
   BUTTON_NR7_STATE : INT;
   BUTTON_NR8_STATE : INT;  
   BUTTON_NR9_STATE : INT;
   BUTTON_NR10_STATE : INT;  
   BUTTON_NR11_STATE : INT;
   BUTTON_NR12_STATE : INT;
   BUTTON_NR13_STATE : INT;  
    
   BUTTON_NR1_FLASH : BOOL := FALSE;
   BUTTON_NR2_FLASH : BOOL := FALSE;  
   BUTTON_NR3_FLASH : BOOL := FALSE;
   BUTTON_NR4_FLASH : BOOL := FALSE;    
   BUTTON_NR5_FLASH : BOOL := FALSE;
   BUTTON_NR6_FLASH : BOOL := FALSE;  
   BUTTON_NR7_FLASH : BOOL := FALSE;
   BUTTON_NR8_FLASH : BOOL := FALSE; 
   BUTTON_NR9_FLASH : BOOL := FALSE;
   BUTTON_NR10_FLASH : BOOL := FALSE;  
   BUTTON_NR11_FLASH : BOOL := FALSE;
   BUTTON_NR12_FLASH : BOOL := FALSE;
   BUTTON_NR13_FLASH : BOOL := FALSE;
      
   BUTTON_NR1_BORDER_W : INT;
   BUTTON_NR2_BORDER_W : INT;  
   BUTTON_NR3_BORDER_W : INT;
   BUTTON_NR4_BORDER_W : INT;  
   BUTTON_NR5_BORDER_W : INT;
   BUTTON_NR6_BORDER_W : INT;  
   BUTTON_NR7_BORDER_W : INT;
   BUTTON_NR8_BORDER_W : INT;  
   BUTTON_NR9_BORDER_W : INT;
   BUTTON_NR10_BORDER_W : INT;  
   BUTTON_NR11_BORDER_W : INT;
   BUTTON_NR12_BORDER_W : INT;
   BUTTON_NR13_BORDER_W : INT;  
    
   BUTTON_NR1_BORDER_L : INT;
   BUTTON_NR2_BORDER_L : INT;  
   BUTTON_NR3_BORDER_L : INT;
   BUTTON_NR4_BORDER_L : INT;  
   BUTTON_NR5_BORDER_L : INT;
   BUTTON_NR6_BORDER_L : INT;  
   BUTTON_NR7_BORDER_L : INT;
   BUTTON_NR8_BORDER_L : INT;  
   BUTTON_NR9_BORDER_L : INT;
   BUTTON_NR10_BORDER_L : INT;  
   BUTTON_NR11_BORDER_L : INT;
   BUTTON_NR12_BORDER_L : INT;
   BUTTON_NR13_BORDER_L : INT;  
   
   BUTTON_NR1_GROUP : INT;
   BUTTON_NR2_GROUP : INT;
   BUTTON_NR3_GROUP : INT;
   BUTTON_NR4_GROUP : INT;
   BUTTON_NR5_GROUP : INT;
   BUTTON_NR6_GROUP : INT;
   BUTTON_NR7_GROUP : INT;
   BUTTON_NR8_GROUP : INT;
   BUTTON_NR9_GROUP : INT;
   BUTTON_NR10_GROUP : INT;
   BUTTON_NR11_GROUP : INT;
   BUTTON_NR12_GROUP : INT;
   BUTTON_NR13_GROUP : INT;
   
   BUTTON_NR1_INVERT : BOOL := FALSE;
   BUTTON_NR2_INVERT : BOOL := FALSE;  
   BUTTON_NR3_INVERT : BOOL := FALSE;
   BUTTON_NR4_INVERT : BOOL := FALSE;    
   BUTTON_NR5_INVERT : BOOL := FALSE;
   BUTTON_NR6_INVERT : BOOL := FALSE;  
   BUTTON_NR7_INVERT : BOOL := FALSE;
   BUTTON_NR8_INVERT : BOOL := FALSE; 
   BUTTON_NR9_INVERT : BOOL := FALSE;
   BUTTON_NR10_INVERT : BOOL := FALSE;  
   BUTTON_NR11_INVERT : BOOL := FALSE;
   BUTTON_NR12_INVERT : BOOL := FALSE;
   BUTTON_NR13_INVERT : BOOL := FALSE;
      
   LOOP_MSEC   : FINT ;  
   UNACC_ALARM : BOOL;
   ANY_ALARM   : BOOL;
   FLASH       : BOOL;
   FLASH_SLOW  : BOOL;
   FLASH_RET   : BOOL;
   
   TIME_REDRAW_STATE : INT;
   DATE_REDRAW_STATE : INT; 
   EAS_BMP_1_STATE : INT;
   EAS_BMP_2_STATE : INT;
   EAS_BMP_3_STATE : INT;
   
   RESET_PANEL : BOOL;
   STATE_ARROW_LEFT:INT;
   STATE_ARROW_RIGHT:INT;
   STATE_BUTTON_LEFT:INT;
   STATE_BUTTON_RIGHT:INT;
   
   STATE_SELECT_ENGINEER:INT;
   CUR_ENGONDUTY:   INT;
   ENG_TEXT_FRAME: INT; 
   
   BOT_BUTTON_1 : BOOL;
   BOT_BUTTON_2 : BOOL;
   BOT_BUTTON_3 : BOOL;
   BOT_BUTTON_4 : BOOL;
   BOT_BUTTON_5 : BOOL;
   BOT_BUTTON_6 : BOOL;
   
   TBUTTON_NR_1: BOOL;
   TBUTTON_NR_2: BOOL;
   TBUTTON_NR_3: BOOL;
   TBUTTON_NR_4: BOOL;
   TBUTTON_NR_5: BOOL;
   TBUTTON_NR_6: BOOL;
   TBUTTON_NR_7: BOOL;
   TBUTTON_NR_8: BOOL;
   TBUTTON_NR_9: BOOL;
   TBUTTON_NR_10: BOOL;
   TBUTTON_NR_11: BOOL;
   TBUTTON_NR_12: BOOL;
   TBUTTON_NR_13: BOOL;
   
   BUTTON_ARROW_LEFT : BOOL;
   BUTTON_ARROW_RIGHT : BOOL;
   GROUP_BUTTON_START_CNT :INT;
   GROUP_BUTTON_CNT_MAX : INT;   
   
   TBUTTON_SCROLL_UP: BOOL;
   TBUTTON_SCROLL_DOWN: BOOL;
   TBUTTON_ACK: BOOL;
   TBUTTON_STOP_HORN: BOOL;
   
   SET_GROUP_ACTIVE : BOOL;
   TBUTTON_NR:BOOL;
   IGROUPNR:INT;
   
   LOCAL_HORN_RESET       : BOOL; 
   HORN_PULSE             : BOOL;
   ALLOW_LOCAL_HORN_RESET : BOOL;
   HANDLE_GROUPS_ACT      : INT;
   SET_HORN_FROM_GROUP_ALARM : BOOL;   
   SET_HORN_FROM_GROUP_ALARM_TWO : BOOL;   
   CURRENT_GROUP_CNT      :INT;
   
   BUTTON_STATE_ACK     : INT;
   DIMMING_STEP         : FINT;
   BUTTON_STATE_STOPHORN: INT;
      
    TB_0   : BOOL;
    TB_1   : BOOL;
    TB_2   : BOOL;
    TB_3   : BOOL;
    TB_4   : BOOL;
    TB_5   : BOOL;
    TB_6   : BOOL;
    TB_7   : BOOL;
    TB_8   : BOOL;
    TB_9   : BOOL;
    TB_DOT : BOOL;
    TB_DEL : BOOL;
    TB_MIN : BOOL; 
    
    TB_EDIT_VALUE     : FINT := FINT#0;
    TB_EDIT_CH_VALUE  : FINT := FINT#0;   
    TBUTTON_CHANNEL   : BOOL;     
    TBUTTON_CH_ACCEPT : BOOL;    
    USE_GROUP_ZERO_INDEX  : BOOL;   
    FLASH_UNATTENDED : BOOL;      
   
    CUR_ENG_CALL:   INT;
    ENG_CALL_TEXT_FRAME: INT;  
    EAS_TEXT_ENG_CALL: STRING[24];                 
   
   //CFG_GROUP_NR:         ARRAY[0..31] OF BYTE; 
  // CFG_GROUP_MODE:       ARRAY[0..31] OF BYTE;
  // CFG_GROUP_HORN_MODE:  ARRAY[0..31] OF BYTE;    
  // CFG_GROUP_HORN_TYPE:  ARRAY[0..31] OF BYTE;
  // CFG_GROUP_HORN_RESET: ARRAY[0..31] OF BYTE;
  // CFG_GROUP_INDEX_MAX:  INT;      
                       
 END_VAR

END_PROGRAM

PROGRAM MAIN
 VAR_EXTERNAL (*$AUTO*) END_VAR
 
 VAR

 IBUTTON : INT;
  
 FLASH_S     : FLASHER ;     
 TLOOP       : HW_TIMING  ; 
 GET_RESET   : HW_GET_EAS_RESET_SIGNAL;
 READ_EAS    : HW_READ_EAS_DESC;  
 SET_GROUPNR : HW_SET_TFT_GROUP_NR_PAGE;
 
   ACCEPT    : HW_ACCEPT ; 
   UP        : HW_SCROLL_UP ;
   DN        : HW_SCROLL_DOWN ;
   PB_UP     : R_TRIG ;
   PB_DN     : R_TRIG ;
   PB_ACC    : R_TRIG ;
   PB_STOPHORN : R_TRIG ;      
      
 TON_ON      : TON ;
 N : INT;   
 IRESET_CNT: INT;   
     
 IFLASH      : INT ;      
 IRETURN     : INT ;
 IPAGE_BUTTON : INT:=0;
 INDEX : INT; 
 INDEX_START:INT;
 INDEX_MAX:INT;
 INDEX_CNT:INT;
 
 INDEX_CNT_NO_NOTACK:INT;
 INDEX_CNT_NOTACK:INT;
 INDEX_CNT_NOTACK_STORE:INT := 0;
 
 ITEST:INT;
 GROUP_CNT:INT;
 NOT_ACK_CNT:INT;
 CLUSTER_RET:INT;
 IRESET_STOPHORN:INT:=0;
 
        
 SET_TFT_FLASH         : HW_SET_TFT_FLASH;
    
 GET_TFT_ALARM_PULSE   : HW_GET_ALARM_PULSE_ON_NEXT;
 GET_TFT_UNACCEPT      : HW_GET_UNACCEPT;  
 GET_TFT_FLASH         : HW_GET_TFT_FLASH; 
 SEND_STOP_HORN        : HW_TFT_EAS_SEND_STOP_HORN;
 REDRAW_SCREEN         : HW_FORCE_REDRAW_DISPLAY;
 SET_TFT_PAGE          : HW_SET_TFT_PAGE;
         
 ALARM_FLASHER        : BOOL;
   
 CUR_CALL_HORN        : BOOL;
 HORN_TURN_ON_CALL    : BOOL := FALSE; 
 CUR_TYPE_PANEL       : INT;
 DO_LOCAL_HORN_ON     : BOOL;
 DO_CALL : BOOL;  
 DO_ARRAY_RESET : BOOL; 
 
 DATE_DRAW_CNT        : DINT := 0;
 
 EXTRA_ALARM_CNT_STORE   : BYTE := 0;
 EXTRA_ALARM_INDEX_STORE : INT  := 0;
 EXTRA_ALARM_CNT_STORE_HLP   : BYTE := 0;
 EXTRA_ALARM_INDEX_STORE_HLP : INT  := 0;
 STANDBYON_STORE : BYTE :=0;
 
 EXTRA_NOACK_CNT_STORE   : BYTE := 0;
   
 END_VAR

 //TYPE_PANEL 0-31 CABINS
 //TYPE PANEL 32 MESS
 //TYPE PANEL 33 GROUP
 //TYPE PANEL 34 ALARM PANEL

 TLOOP();                 
 LOOP_MSEC := INT_TO_FINT(TLOOP.TIME_BETWEEN_CYCLES) ;   // MSEC PREVIOUS LOOP  

 
 IBUTTON := 0;
 TON_ON(IN:= TRUE, PT := T#5s ) ;
 
 // FLASHERS 
 FLASH_S( START:= TRUE , PULSE:= 500, CYCLE:= 3000 , TSCAN:= LOOP_MSEC ) ;    // TAKE-OVER 


GET_TFT_FLASH();
IFLASH := GET_TFT_FLASH.IRET;
IF IFLASH = 0 THEN
  FLASH := FALSE;
ELSE
  FLASH := TRUE;
END_IF
ALARM_FLASHER := FLASH;

FLASH_SLOW :=  FLASH_S.Q ;


IF STANDBYON <> STANDBYON_STORE THEN
  STANDBYON_STORE:=STANDBYON;
  IF (STANDBYON=BYTE#3) THEN //RESET STUFF
    HANDLE_GROUPS_ACT:=0;      
    EXTRA_ALARM_CNT_STORE:= 0;
    EXTRA_ALARM_INDEX_STORE:= 0;
    EXTRA_ALARM_CNT_STORE_HLP:= 0;
    EXTRA_ALARM_INDEX_STORE_HLP:= 0;       
  END_IF
END_IF

//STOP HORN BUTTON
IF ALLOW_LOCAL_HORN_RESET THEN
  PB_STOPHORN(CLK:=TBUTTON_STOP_HORN OR BUTTON_2);
  IF PB_STOPHORN.Q THEN 
    //TODO ALLOW
    LOCAL_HORN_RESET:=TRUE;  
    SEND_STOP_HORN(IINPUT:=1);   
    IRESET_STOPHORN:=20;
  ELSE
    IF IRESET_STOPHORN > 0 THEN 
      IRESET_STOPHORN:=IRESET_STOPHORN-1;;
    END_IF
    IF IRESET_STOPHORN = 0 THEN
      SEND_STOP_HORN(IINPUT:=0);
    END_IF     
  END_IF
  //IS HORN ON
  IF LOCAL_BUZZER THEN
    BUTTON_STATE_STOPHORN:=1;
  ELSE
    BUTTON_STATE_STOPHORN:=0;
  END_IF 
ELSE
  BUTTON_STATE_STOPHORN:=2; //NO BUZZER VISIBLE
END_IF


// SCROLL BUTTONS
PB_UP(CLK:= TBUTTON_SCROLL_UP );
IF PB_UP.Q THEN UP(); END_IF    

PB_DN(CLK:= TBUTTON_SCROLL_DOWN );
IF PB_DN.Q THEN  DN(); END_IF  
 
//UNACC_ALARM
GET_TFT_UNACCEPT(IRET=>IRETURN);
IF IRETURN = 1 THEN UNACC_ALARM := TRUE; ELSE UNACC_ALARM:= FALSE; END_IF

//ANY_ALARM
GET_TFT_ALARM_PULSE(IRET=>IRETURN);
//IRETURN := GET_TFT_ALARM_PULSE.;
IF IRETURN = 1 THEN ANY_ALARM := TRUE; ELSE ANY_ALARM := FALSE; END_IF

// ALARM_FLASHER
SET_TFT_FLASH(IINPUT:=BOOL_TO_INT(ALARM_FLASHER));


GET_RESET(IINPUT:=0);
IRESET_CNT := GET_RESET.IRET;

 IF IRESET_CNT > 9 THEN   
   IF RESET_PANEL THEN
     RESET_PANEL:=FALSE;  
     FOR N:=0 TO 255 DO
       GROUP_NR[N]:=0;
       NR_OF_NOTACK_ALARMS[N]:=0;
     END_FOR
     //ON DUTY, NO IOSERVER CONNECTION LEFT, TURN ON BUZZER
     IF (EAS_BMP_3_STATE = 1) OR (STANDBYON=BYTE#3) THEN               
       LOCAL_BUZZER:=TRUE;      
       IF EXT_HORN_ACTIVE = BYTE#1 THEN
         HORN_RELAIS_OUTPUT:=TRUE;
       END_IF
     END_IF                          
   END_IF  
 ELSE
   RESET_PANEL:=TRUE;
 END_IF

 //ADD ALLOW ACCEPT 
 IF TYPE_PANEL >= BYTE#33 AND CFG_ACCEPT >= BYTE#1 THEN //ALARM PANEL OR GROUP PANEL
   BUTTON_STATE_ACK := 1; //SHOW ACK BUTTON    
 END_IF
  
 IF BUTTON_STATE_ACK = 1 THEN 
   PB_ACC(CLK:= TBUTTON_ACK );
   IF PB_ACC.Q THEN 
     ACCEPT(); 
   END_IF   // ACCEPT ALARM LIST
 END_IF 

 //BUTTON_NR1_FLASH := FLASH;
 //BUTTON_NR2_FLASH := FLASH;
  
 //STRASGN(BUTTON_TEXT_NR_1, 'MAIN ENGINE');
 
 //BUTTON_TEXT_NR_1:=11:25:0:"MAIN ENGINE";
 //BUTTON_TEXT_NR_1:=11:25:0; 

 IBUTTON:=0;
 //GENERAL BOTTOM BUTTONS
 IF BUTTON_1 OR BOT_BUTTON_1 THEN
   IBUTTON:=1;
 ELSIF BUTTON_2 OR BOT_BUTTON_2 THEN
   IBUTTON:=2;
 ELSIF BUTTON_3 OR BOT_BUTTON_3 THEN
   IBUTTON:=3;
   IF DISPLAY_NUMBER = 0 THEN //main page active   
     SET_GROUPNR(IINPUT:=0);
     SET_GROUP_ACTIVE := FALSE;      
     DISPLAY_NUMBER:=1;
   END_IF 
 ELSIF BUTTON_4 OR BOT_BUTTON_4 OR TBUTTON_NR THEN
   IBUTTON:=4;   
   IF DISPLAY_NUMBER = 0 THEN //main page active   
     IF IGROUPNR <> 0 OR TBUTTON_NR_13 THEN      
       DISPLAY_NUMBER:=2;
       SET_GROUPNR(IINPUT:=IGROUPNR);    
       SET_GROUP_ACTIVE := TRUE;
     ELSE
       DISPLAY_NUMBER:=3; //GROUP SELECTION      
     END_IF     
   END_IF        
 ELSIF BUTTON_5 OR BOT_BUTTON_5 THEN
   IBUTTON:=5;     
 ELSIF BUTTON_6 OR BOT_BUTTON_6 THEN
   IBUTTON:=6;   
   IF DISPLAY_NUMBER = 4 THEN //GROUP PAGE ACTIVE
     SET_GROUP_ACTIVE:=TRUE; //RESET TO GROUP 0 ALARM LINE  
   END_IF            
   IF DISPLAY_NUMBER <> 0 THEN
     DISPLAY_NUMBER:=0;  
   END_IF    
 END_IF
    
 //CHANNEL PAGE ACTIVATE
 //IF DISPLAY_NUMBER = 1 AND TBUTTON_CHANNEL THEN
   //DISPLAY_NUMBER:=5;  
 //END_IF
  
 //RESET SET GROUP PAGE
 IF DISPLAY_NUMBER <> 2 AND DISPLAY_NUMBER <> 4 AND SET_GROUP_ACTIVE THEN
   SET_GROUPNR(IINPUT:=0);
   SET_GROUP_ACTIVE := FALSE;
 END_IF         

  
 IF BUTTON_ARROW_LEFT THEN   
   IF GROUP_BUTTON_START_CNT > 0 THEN
     GROUP_BUTTON_START_CNT:=GROUP_BUTTON_START_CNT-1;
     REDRAW_SCREEN(IINPUT:=1);
   END_IF             
 END_IF
 
 IF BUTTON_ARROW_RIGHT THEN   
   IF GROUP_BUTTON_START_CNT < GROUP_BUTTON_CNT_MAX THEN
     GROUP_BUTTON_START_CNT:=GROUP_BUTTON_START_CNT+1;
     REDRAW_SCREEN(IINPUT:=1);
   END_IF             
 END_IF
 
  
 (* IF STARTUP_BACK THEN
    STARTUP_BACK:=FALSE; 
    BUTTON_TEXT_NR_1:='PROPULSION CONTROL PS';
    BUTTON_TEXT_NR_2:='PROPULSION CONTROL SB';
    BUTTON_TEXT_NR_3:='MAIN ENGINE PS WING';
    BUTTON_TEXT_NR_4:='GEARBOX PS WING';
    BUTTON_TEXT_NR_5:='MAIN ENGINE PS CL';
    BUTTON_TEXT_NR_6:='GEARBOX PS CL';
    BUTTON_TEXT_NR_7:='MAIN ENGINE SB CL';
    BUTTON_TEXT_NR_8:='GEARBOX SB CL';
    BUTTON_TEXT_NR_9:='MAIN ENGINE SB WING';
    BUTTON_TEXT_NR_10:='GEARBOX SB WING'; 
  END_IF *)  
  
  EAS_BMP_1_STATE:=0;
  ENG_CALL_TEXT_FRAME:=0;
  
  IF GEAON <> BYTE#2 THEN
    EAS_BMP_1_STATE:=3;
  ELSE                
    IF CALL THEN   
      IF (CALLER_ID=BYTE#0) THEN
        EAS_BMP_1_STATE:=1;
        ENG_CALL_TEXT_FRAME:=2;
      ELSE 
        IF (CALLER_ID=BYTE#1) THEN
          EAS_BMP_1_STATE:=2;
          ENG_CALL_TEXT_FRAME:=2;
        END_IF
      END_IF                
    END_IF
    IF CALL_ALL THEN   
      IF (CALLER_ID=BYTE#0) THEN
        EAS_BMP_1_STATE:=4;
      ELSE 
        IF (CALLER_ID=BYTE#1) THEN
          EAS_BMP_1_STATE:=5;
        END_IF
      END_IF                
    END_IF        
  END_IF 
  
  //DISPLAY ATTENDED / UNATTENDED
  IF ATTENDED THEN 
    EAS_BMP_2_STATE:=0;
  ELSE 
    IF UNATTENDED THEN 
      EAS_BMP_2_STATE:=1;
    END_IF
  END_IF 
  
  //ACCEPT UNATTENDED BY PANEL
  IF ACKUNATTENDEDENABLED AND REQUESTUNATTENDED AND TYPE_PANEL >= BYTE#32 AND CFG_ACCEPT_UNATT THEN   
    IF FLASH THEN
      EAS_BMP_2_STATE:=1;
    ELSE
      EAS_BMP_2_STATE:=0;    
    END_IF   
    LOCAL_BUZZER:=FLASH;  
  END_IF
        
  
  //ENGINEER SELECT TEXT
  IF ENGONDUTY <> CUR_ENGONDUTY THEN
    READ_EAS(IINDEX:=(ENGONDUTY-1), IALT:=0);
    EAS_TEXT_ENG_SEL := READ_EAS.SZRESULT;
    CUR_ENGONDUTY:=ENGONDUTY;
  END_IF  
  
  //ENGINEER SELECT CALL TEXT  
  IF CALL_ENG > 0 THEN  
    IF CALL_ENG <> CUR_ENG_CALL THEN
      READ_EAS(IINDEX:=(CALL_ENG-1), IALT:=0);
      EAS_TEXT_ENG_CALL := READ_EAS.SZRESULT;
      CUR_ENG_CALL:=CALL_ENG;
    END_IF
  END_IF  
    
  //DISPLAY ON DUTY
  CUR_TYPE_PANEL:=BYTE_TO_INT(TYPE_PANEL)+1;
  IF UNATTENDED THEN
    IF CUR_TYPE_PANEL = ENGONDUTY THEN  //IS IT CABIN PANEL 
      EAS_BMP_3_STATE:=1;
      ENG_TEXT_FRAME:=0;
    ELSIF ENGONSTANDBY = 1 THEN  //IS THIS CABIN STANDBY
      EAS_BMP_3_STATE:=2;
      ENG_TEXT_FRAME:=0;
    ELSE  
      EAS_BMP_3_STATE:=0;
      ENG_TEXT_FRAME:=1;
    END_IF
  ELSE
    EAS_BMP_3_STATE:=0;   
    ENG_TEXT_FRAME:=1;   
  END_IF
                
  //no communication with server, reset panel  
  IF RESET_PANEL = FALSE THEN
    EAS_BMP_1_STATE:=0;
    EAS_BMP_2_STATE:=2;  
    EAS_BMP_3_STATE:=0;   
    ENG_TEXT_FRAME:=1;    
    ENG_CALL_TEXT_FRAME:=0;    
  END_IF
                  
  INDEX_START:=1;
  
  IF GROUP_BUTTON_START_CNT >= 1 THEN  
    INDEX_START:=(12*GROUP_BUTTON_START_CNT)+1;         
  END_IF
    
  INDEX_MAX:=INDEX_START+11;  
  INDEX_CNT:=1;
  INDEX_CNT_NO_NOTACK:=0;
  INDEX_CNT_NOTACK:=0;
  
    
  // -CREATE GROUP ARRAY 32, WHICH GROUPS ARE CONFIGURED    
  // -LOAD IT FROM CONFIG
  // -CHECK GROUP ALLOW
  // -YES, CHECK MODE ON DUTY, UNATT, ATT
  // -CHECK DO HORN?
  // -YES, CHECK MODE / PULSE OR NOT / ALLOW RESET  

  
   
  FOR INDEX:=INDEX_START TO INDEX_MAX DO
     
    //ITEST := GROUP_NR[INDEX];
                  
    IF (GROUP_NR[INDEX]=BYTE#0) THEN
        
     CASE INDEX_CNT OF
        1:  BUTTON_ACTIVE_NR_1:=FALSE; 
        2:  BUTTON_ACTIVE_NR_2:=FALSE; 
        3:  BUTTON_ACTIVE_NR_3:=FALSE; 
        4:  BUTTON_ACTIVE_NR_4:=FALSE; 
        5:  BUTTON_ACTIVE_NR_5:=FALSE; 
        6:  BUTTON_ACTIVE_NR_6:=FALSE; 
        7:  BUTTON_ACTIVE_NR_7:=FALSE; 
        8:  BUTTON_ACTIVE_NR_8:=FALSE; 
        9:  BUTTON_ACTIVE_NR_9:=FALSE; 
        10: BUTTON_ACTIVE_NR_10:=FALSE;
        11: BUTTON_ACTIVE_NR_11:=FALSE;
        12: BUTTON_ACTIVE_NR_12:=FALSE;                                                                                
      END_CASE
      
    ELSE
              
      CASE INDEX_CNT OF
        1:  BUTTON_ACTIVE_NR_1:=TRUE;  
        2:  BUTTON_ACTIVE_NR_2:=TRUE;  
        3:  BUTTON_ACTIVE_NR_3:=TRUE; 
        4:  BUTTON_ACTIVE_NR_4:=TRUE;  
        5:  BUTTON_ACTIVE_NR_5:=TRUE; 
        6:  BUTTON_ACTIVE_NR_6:=TRUE; 
        7:  BUTTON_ACTIVE_NR_7:=TRUE; 
        8:  BUTTON_ACTIVE_NR_8:=TRUE; 
        9:  BUTTON_ACTIVE_NR_9:=TRUE;   
        10: BUTTON_ACTIVE_NR_10:=TRUE;  
        11: BUTTON_ACTIVE_NR_11:=TRUE; 
        12: BUTTON_ACTIVE_NR_12:=TRUE;                                                                                
      END_CASE           
    END_IF
    
    //flashing state of buttons        
    IF (NR_OF_NOTACK_ALARMS[INDEX]=BYTE#0) THEN
    
      CASE INDEX_CNT OF
        1:  BUTTON_NR1_FLASH:=FALSE; 
        2:  BUTTON_NR2_FLASH:=FALSE; 
        3:  BUTTON_NR3_FLASH:=FALSE; 
        4:  BUTTON_NR4_FLASH:=FALSE; 
        5:  BUTTON_NR5_FLASH:=FALSE; 
        6:  BUTTON_NR6_FLASH:=FALSE; 
        7:  BUTTON_NR7_FLASH:=FALSE; 
        8:  BUTTON_NR8_FLASH:=FALSE; 
        9:  BUTTON_NR9_FLASH:=FALSE; 
        10: BUTTON_NR10_FLASH:=FALSE;
        11: BUTTON_NR11_FLASH:=FALSE;
        12: BUTTON_NR12_FLASH:=FALSE;                                                                                
      END_CASE
      
      INDEX_CNT_NO_NOTACK:=INDEX_CNT_NO_NOTACK+1;
      
    ELSE
                  
      //IF NEW ALARM IS COMMING
      IF HANDLE_GROUPS_ACT = 0 THEN
        HANDLE_GROUPS_ACT:=1;
      END_IF
          
      CASE INDEX_CNT OF
        1:  BUTTON_NR1_FLASH := FLASH;  
        2:  BUTTON_NR2_FLASH := FLASH;  
        3:  BUTTON_NR3_FLASH := FLASH;
        4:  BUTTON_NR4_FLASH := FLASH; 
        5:  BUTTON_NR5_FLASH := FLASH;
        6:  BUTTON_NR6_FLASH := FLASH; 
        7:  BUTTON_NR7_FLASH := FLASH; 
        8:  BUTTON_NR8_FLASH := FLASH; 
        9:  BUTTON_NR9_FLASH := FLASH;   
        10: BUTTON_NR10_FLASH := FLASH;  
        11: BUTTON_NR11_FLASH := FLASH; 
        12: BUTTON_NR12_FLASH := FLASH;                                                                                
      END_CASE    
      
      INDEX_CNT_NOTACK:=INDEX_CNT_NOTACK+1;
             
    END_IF
               
    INDEX_CNT:=INDEX_CNT+1;  
    
  END_FOR
  
  //CHECK OTHER ALARM GROUPS  
  EXTRA_ALARM_CNT_STORE:= 0;
  EXTRA_ALARM_INDEX_STORE:= 0; 
  NOT_ACK_CNT:=0; 
  FOR INDEX:=1 TO 64 DO   
    IF INDEX < INDEX_START OR INDEX > INDEX_MAX THEN          
      //IF SOMEWHERE NEW ALARM MAKE SURE BUZZER BE ACTIVATED
      IF (NR_OF_NOTACK_ALARMS[INDEX]<>BYTE#0) THEN            
        EXTRA_ALARM_CNT_STORE:=EXTRA_ALARM_CNT_STORE+NR_OF_NOTACK_ALARMS[INDEX];
        EXTRA_ALARM_INDEX_STORE:=EXTRA_ALARM_INDEX_STORE+INDEX;      
        INDEX_CNT_NOTACK:=INDEX_CNT_NOTACK+1;                                  
      END_IF          
    END_IF
    IF NR_OF_NOTACK_ALARMS[INDEX]<>BYTE#0 THEN
      NOT_ACK_CNT:=NOT_ACK_CNT+1;
    END_IF           
  END_FOR
  
  //HANDLE GROUP ZERO 
  IF (NR_OF_NOTACK_ALARMS[0]<>BYTE#0) AND (NOT_ACK_CNT=0) AND USE_GROUP_ZERO THEN  
    BUTTON_NR13_FLASH := FLASH; 
    BUTTON_ACTIVE_NR_13:=TRUE;    
    EXTRA_ALARM_CNT_STORE:=NR_OF_NOTACK_ALARMS[0];
    EXTRA_ALARM_INDEX_STORE:=1024;//Special index      
    INDEX_CNT_NOTACK:=INDEX_CNT_NOTACK+1;
  ELSE
    BUTTON_NR13_FLASH := FALSE; 
    BUTTON_ACTIVE_NR_13:=FALSE;                       
  END_IF    
      
  //TURN ON BUZZER IF NEW ALARM IS SEEN
  IF EXTRA_ALARM_CNT_STORE<>EXTRA_ALARM_CNT_STORE_HLP OR EXTRA_ALARM_INDEX_STORE<>EXTRA_ALARM_INDEX_STORE_HLP THEN
    //ONLY WHEN NEW ALARM IS DETECTED; NOT WHEN ONE ALARM OF MULTIPLE NOT ACK ALARMS IS ACK
    IF EXTRA_ALARM_CNT_STORE_HLP < EXTRA_ALARM_CNT_STORE OR EXTRA_ALARM_INDEX_STORE<>EXTRA_ALARM_INDEX_STORE_HLP THEN    
      IF CUR_TYPE_PANEL = ENGONDUTY OR TYPE_PANEL = BYTE#32 OR TYPE_PANEL = BYTE#33 OR TYPE_PANEL = BYTE#34 THEN    
        IF HANDLE_GROUPS_ACT = 0 THEN           
          HANDLE_GROUPS_ACT:=1;     
        END_IF
      END_IF
    END_IF         
    EXTRA_ALARM_CNT_STORE_HLP:=EXTRA_ALARM_CNT_STORE;
    EXTRA_ALARM_INDEX_STORE_HLP:=EXTRA_ALARM_INDEX_STORE;                
    IF EXTRA_ALARM_INDEX_STORE=1024 THEN
      USE_GROUP_ZERO_INDEX:=TRUE;
    END_IF           
  END_IF
    
  //for group panel or alarm panel or mess panel or onduty cabin, nr of notack is changed 
  IF EXTRA_NOACK_CNT_STORE <> NR_OF_NOTACK_ALARMS[0] THEN     
    IF EXTRA_NOACK_CNT_STORE <> BYTE#0 AND EXTRA_NOACK_CNT_STORE < NR_OF_NOTACK_ALARMS[0] THEN
      IF CUR_TYPE_PANEL = ENGONDUTY OR TYPE_PANEL = BYTE#32 OR TYPE_PANEL = BYTE#33 OR TYPE_PANEL = BYTE#34 THEN    
        HANDLE_GROUPS_ACT:=1;  
      END_IF
    END_IF
    EXTRA_NOACK_CNT_STORE:=NR_OF_NOTACK_ALARMS[0];     
  END_IF  
                                         
  //GROUP HANDLING  
  IF HANDLE_GROUPS_ACT >= 2 THEN
    IF INDEX_CNT_NO_NOTACK >= 12 THEN //RESET
      HANDLE_GROUPS_ACT := 0;
    END_IF  
  END_IF
  
  //RESET NR OF GROUPS IN ALARM IS CHANGED
  IF INDEX_CNT_NOTACK_STORE<>INDEX_CNT_NOTACK THEN
    IF HANDLE_GROUPS_ACT >= 2 THEN
      HANDLE_GROUPS_ACT := 0;
    END_IF     
    INDEX_CNT_NOTACK_STORE:=INDEX_CNT_NOTACK;
  END_IF
  
  
  //CNT GROUPS IN ALARM
  DO_ARRAY_RESET:=FALSE;
  GROUP_CNT:=0;
    
  FOR INDEX:=1 TO 255 DO 
   IF (GROUP_NR[INDEX]<>BYTE#0) THEN
     GROUP_CNT:=GROUP_CNT+1;
   END_IF  
               
   //FIND LAST RECORD   
   IF DO_ARRAY_RESET = FALSE THEN    
     IF (GROUP_NR[INDEX]=BYTE#0) AND (NR_OF_NOTACK_ALARMS[INDEX]=BYTE#0) AND (NR_OF_ALARMS[INDEX]=BYTE#0) THEN
       DO_ARRAY_RESET:=TRUE;    
     END_IF
   ELSE      
     GROUP_NR[INDEX]:=BYTE#0;  
     NR_OF_NOTACK_ALARMS[INDEX]:=BYTE#0;
     NR_OF_ALARMS[INDEX]:=BYTE#0;
   END_IF
               
  END_FOR
   
       
  IF GROUP_CNT > 12 THEN    
    GROUP_BUTTON_CNT_MAX:=(GROUP_CNT -1) / 12;
    STATE_BUTTON_LEFT:=0;
    STATE_BUTTON_RIGHT:=0;    
  ELSE
    GROUP_BUTTON_CNT_MAX:=0;
    STATE_BUTTON_LEFT:=1;
    STATE_BUTTON_RIGHT:=1;    
  END_IF
  
  //CHECK IF REDRAW IS REQUIRED
  IF CURRENT_GROUP_CNT <> GROUP_CNT THEN
    CURRENT_GROUP_CNT:=GROUP_CNT;
    REDRAW_SCREEN(IINPUT:=1);
  END_IF
    
  //get clusterhorn
  GET_RESET(IINPUT:=1);
  CLUSTER_RET := GET_RESET.IRET;
  IF CLUSTER_RET = 1 THEN
    LOCAL_BUZZER:=FALSE;
    HORN_PULSE := FALSE;    
    SET_HORN_FROM_GROUP_ALARM:=FALSE;
    SET_HORN_FROM_GROUP_ALARM_TWO:=FALSE;
    ALLOW_LOCAL_HORN_RESET:=TRUE;
    HORN_TURN_ON_CALL:=FALSE;
  END_IF
    
  //HORN RESET
  IF LOCAL_HORN_RESET AND LOCAL_BUZZER THEN
    LOCAL_BUZZER:=FALSE;
    HORN_PULSE := FALSE;    
    SET_HORN_FROM_GROUP_ALARM:=FALSE;
    SET_HORN_FROM_GROUP_ALARM_TWO:=FALSE;
    HORN_TURN_ON_CALL:=FALSE;
  END_IF 
    
  IF LOCAL_HORN_RESET AND HORN_RELAIS_OUTPUT THEN
    HORN_RELAIS_OUTPUT := FALSE;
  END_IF 
  

  //DO NOT TURN HORN WHEN NO NEEDED
  DO_LOCAL_HORN_ON := TRUE;
  IF GEAON = BYTE#2 AND DEADMANON = BYTE#2 THEN //NO GEA OR DEADMEN       
    IF CALL = FALSE AND CALL_ALL = FALSE THEN   //NO CALL AT ALL
      IF SET_HORN_FROM_GROUP_ALARM = FALSE THEN //NO GROUP ALARM, SEE HANDLE GROUPS
        DO_LOCAL_HORN_ON:=FALSE;  
      END_IF
    END_IF
  END_IF
    
  IF GEAON = BYTE#2 AND DEADMANON = BYTE#2 THEN //NO GEA OR DEADMEN       
    IF CALL AND CALL_ALL = FALSE AND (TYPE_PANEL+BYTE#1) <> INT_TO_BYTE(CALL_ENG) THEN      // NOT CALL FOR THIS PANEL
      IF TYPE_PANEL <> BYTE#32 THEN
        IF SET_HORN_FROM_GROUP_ALARM = FALSE THEN //NO GROUP ALARM, SEE HANDLE GROUPS
          DO_LOCAL_HORN_ON:=FALSE;  
        END_IF
      END_IF
    END_IF
  END_IF
          
  //TURN HORN ON, GLOBAL FOR ALARM PANEL  
  IF TYPE_PANEL = BYTE#34 THEN    
    IF HORN1ISON THEN //OR HORN2ISON        
      IF LOCAL_HORN_RESET = FALSE AND DO_LOCAL_HORN_ON THEN
        LOCAL_BUZZER:=TRUE;        
        IF EXT_HORN_ACTIVE = BYTE#1 THEN
          HORN_RELAIS_OUTPUT:=TRUE;  
        END_IF          
      END_IF      
    ELSE
      LOCAL_HORN_RESET := FALSE;
    END_IF                         
  END_IF    

  //LOCAL RESET       
  IF HORN1ISON = FALSE THEN         
    LOCAL_HORN_RESET := FALSE;
  END_IF
    
  //HORN WITH CALL
  DO_CALL:=FALSE;
  IF CALL AND (TYPE_PANEL+BYTE#1) = INT_TO_BYTE(CALL_ENG) AND (HORN_STATUS <> BYTE#0) THEN  //WHEN CALL CERTAIN ENGINEER
    DO_CALL:=TRUE;
  END_IF    
  IF CALL AND TYPE_PANEL = BYTE#32 AND (HORN_STATUS <> BYTE#0) THEN //WHEN MESS PANEL TURN ON
    DO_CALL:=TRUE;
  END_IF  
  IF CALL_ALL AND (HORN_STATUS <> BYTE#0) THEN
    DO_CALL:=TRUE;  
  END_IF
    
  IF DO_CALL THEN
    IF CUR_CALL_HORN=FALSE THEN
      CUR_CALL_HORN:=TRUE;
      HORN_TURN_ON_CALL:=TRUE;    
      LOCAL_BUZZER:=TRUE;
      LOCAL_HORN_RESET:=FALSE;      
      IF EXT_HORN_ACTIVE = BYTE#1 THEN
        HORN_RELAIS_OUTPUT:=TRUE;  
      END_IF                  
    END_IF
  ELSE
    CUR_CALL_HORN:=FALSE;        
  END_IF
  
    
  //HANDLE HORN PULSE  
  IF HORN_PULSE THEN
    IF FLASH THEN
      LOCAL_BUZZER:=TRUE;
    ELSE
      LOCAL_BUZZER:=FALSE;
    END_IF      
    IF EXT_HORN_ACTIVE = BYTE#1 THEN
      IF FLASH THEN         
        HORN_RELAIS_OUTPUT:=TRUE;
      ELSE
        HORN_RELAIS_OUTPUT:=FALSE;       
      END_IF  
    END_IF                      
  END_IF
  
  //RESET HORN FROM SERVER
  IF HORN1ISON = FALSE AND HORN_STATUS = BYTE#0 THEN   // AND HORN2ISON = FALSE  
//    IF GEAON = BYTE#2 AND DEADMANON = BYTE#2 THEN       
      IF CALL = FALSE AND CALL_ALL = FALSE THEN        
        IF SET_HORN_FROM_GROUP_ALARM = FALSE AND RESET_PANEL THEN
          HORN_PULSE:=FALSE; 
          HORN_RELAIS_OUTPUT:=FALSE;
          LOCAL_BUZZER:=FALSE;
          ALLOW_LOCAL_HORN_RESET:=TRUE;
          HORN_TURN_ON_CALL:=FALSE;
        END_IF        
      END_IF  
//    END_IF    
  END_IF
  
  
  //RESET HORN FROM SERVER CALL IS REMOVED  
  IF HORN_TURN_ON_CALL AND HORN_STATUS = BYTE#0 THEN  
    IF CALL = FALSE AND CALL_ALL = FALSE THEN        
      IF SET_HORN_FROM_GROUP_ALARM = FALSE AND RESET_PANEL THEN
        HORN_PULSE:=FALSE; 
        HORN_RELAIS_OUTPUT:=FALSE;
        LOCAL_BUZZER:=FALSE;
        ALLOW_LOCAL_HORN_RESET:=TRUE;
        HORN_TURN_ON_CALL:=FALSE;
      END_IF        
    END_IF  
  END_IF
      
  //WHEN MESS PANEL AND UNATTENDED RESET HORN FROM SERVER HORN_STATUS IS REMOVED 
  // THIS HAPPENS WHEN STOPHORN IS PRESSED ON DUTY PANEL  
  IF TYPE_PANEL = BYTE#32 AND HORN_STATUS = BYTE#0 AND UNATTENDED THEN  
    IF GEAON = BYTE#2 AND DEADMANON = BYTE#2 THEN //NO GEA OR DEADMEN    
      IF HORN1ISON THEN  //OR HORN2ISON    
        IF CALL = FALSE AND CALL_ALL = FALSE THEN        
          IF SET_HORN_FROM_GROUP_ALARM = FALSE AND RESET_PANEL THEN
            HORN_PULSE:=FALSE; 
            HORN_RELAIS_OUTPUT:=FALSE;
            LOCAL_BUZZER:=FALSE;
            ALLOW_LOCAL_HORN_RESET:=TRUE;
            HORN_TURN_ON_CALL:=FALSE;
          END_IF        
        END_IF
      END_IF
    END_IF  
  END_IF  
  
       
  TIME_REDRAW_STATE:=TIME_REDRAW_STATE+1;
  IF TIME_REDRAW_STATE > 2 THEN
    TIME_REDRAW_STATE:=0;
  END_IF
  
  IF DATE_DRAW_CNT < 4 THEN
    DATE_REDRAW_STATE:=DATE_REDRAW_STATE+1;
    IF DATE_REDRAW_STATE > 2 THEN
      DATE_REDRAW_STATE:=0;
    END_IF    
  END_IF

  //10 TIMER PER SEC
  DATE_DRAW_CNT:=DATE_DRAW_CNT+1;
  IF DATE_DRAW_CNT > 600 THEN  //10 x 300, EVERY 5 mins  / 600 every min
    DATE_DRAW_CNT:=0;
  END_IF
  
  SET_TFT_PAGE(iInput:=DISPLAY_NUMBER);
 
END_PROGRAM

PROGRAM GROUP_BUTTONS
 VAR_EXTERNAL (*$AUTO*) END_VAR
 
 VAR
 READ_GROUP_BUTTON_DESC : HW_READ_GROUP_DESC;
 INDEX:INT;
 START_INDEX:INT;
 GROUP:INT;
 CNT:INT;
 END_VAR
 
  //ADDRESS:=ADR(BUTTON_NR1_BORDER_W); 
 
  START_INDEX:=0;
  CNT:=0;
  
  IF GROUP_BUTTON_START_CNT >= 1 THEN  
    START_INDEX:=(12*GROUP_BUTTON_START_CNT);         
  END_IF
    
  //GROUP BUTTON 1
  IF BUTTON_ACTIVE_NR_1 THEN
    BUTTON_NR1_STATE:=0;
    BUTTON_NR1_BORDER_W:=1;
    BUTTON_NR1_BORDER_L:=20;    
    BUTTON_NR1_INVERT:=TRUE;    
    INDEX:=1+START_INDEX;
    GROUP:=BYTE_TO_INT(GROUP_NR[INDEX]);
    IF (GROUP > 0) AND GROUP <> BUTTON_NR1_GROUP THEN
      READ_GROUP_BUTTON_DESC(IGROUPNR:=GROUP, IALT:=0);
      BUTTON_TEXT_NR_1 := READ_GROUP_BUTTON_DESC.SZTEXT;
    END_IF                                    
  ELSE
    BUTTON_NR1_STATE:=8;
    BUTTON_NR1_FLASH := FALSE;
    BUTTON_NR1_BORDER_W:=0;
    BUTTON_NR1_BORDER_L:=0;  
    BUTTON_NR1_INVERT:=FALSE;  
    GROUP:=0;  
    BUTTON_TEXT_NR_1 := '';
  END_IF
  BUTTON_NR1_GROUP := GROUP;
      
  //GROUP BUTTON 2
  IF BUTTON_ACTIVE_NR_2 THEN
    BUTTON_NR2_STATE:=0;
    BUTTON_NR2_BORDER_W:=1;
    BUTTON_NR2_BORDER_L:=20;
    BUTTON_NR2_INVERT:=TRUE;
    INDEX:=2+START_INDEX;
    GROUP:=BYTE_TO_INT(GROUP_NR[INDEX]);    
    IF (GROUP > 0) AND GROUP <> BUTTON_NR2_GROUP THEN
      READ_GROUP_BUTTON_DESC(IGROUPNR:=GROUP, IALT:=0);
      BUTTON_TEXT_NR_2 := READ_GROUP_BUTTON_DESC.SZTEXT;
    END_IF                            
  ELSE
    BUTTON_NR2_STATE:=8;
    BUTTON_NR2_FLASH := FALSE;
    BUTTON_NR2_BORDER_W:=0;
    BUTTON_NR2_BORDER_L:=0; 
    BUTTON_NR2_INVERT:=FALSE;
    GROUP:=0;
    BUTTON_TEXT_NR_2 := '';   
  END_IF
  BUTTON_NR2_GROUP := GROUP;
  
  //CHANGE DETECTED
  IF BUTTON_NR2_GROUP <> GROUP THEN
    BUTTON_NR2_GROUP:=GROUP;
    BUTTON_NR2_STATE:=1; //FORCE REDRAW
  END_IF  

  //GROUP BUTTON 3
  IF BUTTON_ACTIVE_NR_3 THEN
    BUTTON_NR3_STATE:=0;
    BUTTON_NR3_BORDER_W:=1;
    BUTTON_NR3_BORDER_L:=20;
    BUTTON_NR3_INVERT:=TRUE;
    INDEX:=3+START_INDEX;
    GROUP:=BYTE_TO_INT(GROUP_NR[INDEX]);
    IF (GROUP > 0) AND GROUP <> BUTTON_NR3_GROUP THEN
      READ_GROUP_BUTTON_DESC(IGROUPNR:=GROUP, IALT:=0);
      BUTTON_TEXT_NR_3 := READ_GROUP_BUTTON_DESC.SZTEXT;
    END_IF                                                
  ELSE
    BUTTON_NR3_STATE:=8;
    BUTTON_NR3_FLASH := FALSE;
    BUTTON_NR3_BORDER_W:=0;
    BUTTON_NR3_BORDER_L:=0;   
    BUTTON_NR3_INVERT:=FALSE;   
    GROUP:=0;
    BUTTON_TEXT_NR_3 := ''; 
  END_IF
  BUTTON_NR3_GROUP := GROUP;
    
  //GROUP BUTTON 4
  IF BUTTON_ACTIVE_NR_4 THEN
    BUTTON_NR4_STATE:=0;
    BUTTON_NR4_BORDER_W:=1;
    BUTTON_NR4_BORDER_L:=20;
    BUTTON_NR4_INVERT:=TRUE;
    INDEX:=4+START_INDEX;
    GROUP:=BYTE_TO_INT(GROUP_NR[INDEX]);
    IF (GROUP > 0) AND GROUP <> BUTTON_NR4_GROUP THEN
      READ_GROUP_BUTTON_DESC(IGROUPNR:=GROUP, IALT:=0);
      BUTTON_TEXT_NR_4 := READ_GROUP_BUTTON_DESC.SZTEXT;
    END_IF                                        
  ELSE
    BUTTON_NR4_STATE:=8;
    BUTTON_NR4_FLASH := FALSE;
    BUTTON_NR4_BORDER_W:=0;
    BUTTON_NR4_BORDER_L:=0;
    BUTTON_NR4_INVERT:=FALSE;
    GROUP:=0;
    BUTTON_TEXT_NR_4 := '';    
  END_IF
  BUTTON_NR4_GROUP := GROUP;
  
  //GROUP BUTTON 5
  IF BUTTON_ACTIVE_NR_5 THEN
    BUTTON_NR5_STATE:=0;
    BUTTON_NR5_BORDER_W:=1;
    BUTTON_NR5_BORDER_L:=20; 
    BUTTON_NR5_INVERT:=TRUE; 
    INDEX:=5+START_INDEX;
    GROUP:=BYTE_TO_INT(GROUP_NR[INDEX]);
    IF (GROUP > 0) AND GROUP <> BUTTON_NR5_GROUP THEN
      READ_GROUP_BUTTON_DESC(IGROUPNR:=GROUP, IALT:=0);
      BUTTON_TEXT_NR_5 := READ_GROUP_BUTTON_DESC.SZTEXT;
    END_IF                                        
  ELSE
    BUTTON_NR5_STATE:=8;
    BUTTON_NR5_FLASH := FALSE;
    BUTTON_NR5_BORDER_W:=0;
    BUTTON_NR5_BORDER_L:=0;   
    BUTTON_NR5_INVERT:=FALSE;   
    GROUP:=0;
    BUTTON_TEXT_NR_5 := ''; 
  END_IF
  BUTTON_NR5_GROUP := GROUP;
    
  //GROUP BUTTON 6
  IF BUTTON_ACTIVE_NR_6 THEN
    BUTTON_NR6_STATE:=0;
    BUTTON_NR6_BORDER_W:=1;
    BUTTON_NR6_BORDER_L:=20;
    BUTTON_NR6_INVERT:=TRUE;
    INDEX:=6+START_INDEX;
    GROUP:=BYTE_TO_INT(GROUP_NR[INDEX]);
    IF (GROUP > 0) AND GROUP <> BUTTON_NR6_GROUP THEN
      READ_GROUP_BUTTON_DESC(IGROUPNR:=GROUP, IALT:=0);
      BUTTON_TEXT_NR_6 := READ_GROUP_BUTTON_DESC.SZTEXT;
    END_IF                                        
  ELSE
    BUTTON_NR6_STATE:=8;
    BUTTON_NR6_FLASH := FALSE;
    BUTTON_NR6_BORDER_W:=0;
    BUTTON_NR6_BORDER_L:=0;  
    BUTTON_NR6_INVERT:=FALSE; 
    GROUP:=0;
    BUTTON_TEXT_NR_6 := '';  
  END_IF
  BUTTON_NR6_GROUP := GROUP;
      
  //GROUP BUTTON 7
  IF BUTTON_ACTIVE_NR_7 THEN
    BUTTON_NR7_STATE:=0;
    BUTTON_NR7_BORDER_W:=1;
    BUTTON_NR7_BORDER_L:=20;
    BUTTON_NR7_INVERT:=TRUE;
    INDEX:=7+START_INDEX;
    GROUP:=BYTE_TO_INT(GROUP_NR[INDEX]);
    IF (GROUP > 0) AND GROUP <> BUTTON_NR7_GROUP THEN
      READ_GROUP_BUTTON_DESC(IGROUPNR:=GROUP, IALT:=0);
      BUTTON_TEXT_NR_7 := READ_GROUP_BUTTON_DESC.SZTEXT;
    END_IF                                    
  ELSE
    BUTTON_NR7_STATE:=8;
    BUTTON_NR7_FLASH := FALSE;
    BUTTON_NR7_BORDER_W:=0;
    BUTTON_NR7_BORDER_L:=0; 
    BUTTON_NR7_INVERT:=FALSE; 
    GROUP:=0;
    BUTTON_TEXT_NR_7 := '';       
  END_IF
  BUTTON_NR7_GROUP := GROUP;
    
  //GROUP BUTTON 8
  IF BUTTON_ACTIVE_NR_8 THEN
    BUTTON_NR8_STATE:=0;
    BUTTON_NR8_BORDER_W:=1;
    BUTTON_NR8_BORDER_L:=20;
    BUTTON_NR8_INVERT:=TRUE;
    INDEX:=8+START_INDEX;
    GROUP:=BYTE_TO_INT(GROUP_NR[INDEX]);
    IF (GROUP > 0) AND GROUP <> BUTTON_NR8_GROUP THEN
      READ_GROUP_BUTTON_DESC(IGROUPNR:=GROUP, IALT:=0);
      BUTTON_TEXT_NR_8 := READ_GROUP_BUTTON_DESC.SZTEXT;
    END_IF                                    
  ELSE
    BUTTON_NR8_STATE:=8;
    BUTTON_NR8_FLASH := FALSE;
    BUTTON_NR8_BORDER_W:=0;
    BUTTON_NR8_BORDER_L:=0;
    BUTTON_NR8_INVERT:=FALSE;
    GROUP:=0;
    BUTTON_TEXT_NR_8 := '';    
  END_IF
  BUTTON_NR8_GROUP := GROUP;
    
  //GROUP BUTTON 9
  IF BUTTON_ACTIVE_NR_9 THEN
    BUTTON_NR9_STATE:=0;
    BUTTON_NR9_BORDER_W:=1;
    BUTTON_NR9_BORDER_L:=20;
    BUTTON_NR9_INVERT:=TRUE;
    INDEX:=9+START_INDEX;
    GROUP:=BYTE_TO_INT(GROUP_NR[INDEX]);
    IF (GROUP > 0) AND GROUP <> BUTTON_NR9_GROUP THEN
      READ_GROUP_BUTTON_DESC(IGROUPNR:=GROUP, IALT:=0);
      BUTTON_TEXT_NR_9 := READ_GROUP_BUTTON_DESC.SZTEXT;
    END_IF                                    
  ELSE
    BUTTON_NR9_STATE:=8;   
    BUTTON_NR9_FLASH := FALSE;
    BUTTON_NR9_BORDER_W:=0;
    BUTTON_NR9_BORDER_L:=0; 
    BUTTON_NR9_INVERT:=FALSE;
    GROUP:=0;
    BUTTON_TEXT_NR_9 := '';   
  END_IF
  BUTTON_NR9_GROUP := GROUP;
    
  //GROUP BUTTON 10
  IF BUTTON_ACTIVE_NR_10 THEN
    BUTTON_NR10_STATE:=0;
    BUTTON_NR10_BORDER_W:=1;
    BUTTON_NR10_BORDER_L:=20;
    BUTTON_NR10_INVERT:=TRUE;
    INDEX:=10+START_INDEX;
    GROUP:=BYTE_TO_INT(GROUP_NR[INDEX]);
    IF (GROUP > 0) AND GROUP <> BUTTON_NR10_GROUP THEN
      READ_GROUP_BUTTON_DESC(IGROUPNR:=GROUP, IALT:=0);
      BUTTON_TEXT_NR_10 := READ_GROUP_BUTTON_DESC.SZTEXT;
    END_IF                                    
  ELSE
    BUTTON_NR10_STATE:=8;
    BUTTON_NR10_FLASH := FALSE;
    BUTTON_NR10_BORDER_W:=0;
    BUTTON_NR10_BORDER_L:=0; 
    BUTTON_NR10_INVERT:=FALSE; 
    GROUP:=0;
    BUTTON_TEXT_NR_10 := '';       
  END_IF
  BUTTON_NR10_GROUP := GROUP;
    
  //GROUP BUTTON 11
  IF BUTTON_ACTIVE_NR_11 THEN
    BUTTON_NR11_STATE:=0;
    BUTTON_NR11_BORDER_W:=1;
    BUTTON_NR11_BORDER_L:=20;
    BUTTON_NR11_INVERT:=TRUE;
    INDEX:=11+START_INDEX;
    GROUP:=BYTE_TO_INT(GROUP_NR[INDEX]);
    IF (GROUP > 0) AND GROUP <> BUTTON_NR11_GROUP THEN
      READ_GROUP_BUTTON_DESC(IGROUPNR:=GROUP, IALT:=0);
      BUTTON_TEXT_NR_11 := READ_GROUP_BUTTON_DESC.SZTEXT;
    END_IF                                        
  ELSE
    BUTTON_NR11_STATE:=8;   
    BUTTON_NR11_FLASH := FALSE;
    BUTTON_NR11_BORDER_W:=0;
    BUTTON_NR11_BORDER_L:=0;    
    BUTTON_NR11_INVERT:=FALSE;   
    GROUP:=0;
    BUTTON_TEXT_NR_11 := '';
  END_IF
  BUTTON_NR11_GROUP := GROUP;
    
  //GROUP BUTTON 12
  IF BUTTON_ACTIVE_NR_12 THEN
    BUTTON_NR12_STATE:=0;
    BUTTON_NR12_BORDER_W:=1;
    BUTTON_NR12_BORDER_L:=20;
    BUTTON_NR12_INVERT:=TRUE;
    INDEX:=12+START_INDEX;
    GROUP:=BYTE_TO_INT(GROUP_NR[INDEX]);
    IF (GROUP > 0) AND GROUP <> BUTTON_NR12_GROUP THEN
      READ_GROUP_BUTTON_DESC(IGROUPNR:=GROUP, IALT:=0);
      BUTTON_TEXT_NR_12 := READ_GROUP_BUTTON_DESC.SZTEXT;
    END_IF                                        
  ELSE
    BUTTON_NR12_STATE:=8;   
    BUTTON_NR12_FLASH := FALSE;
    BUTTON_NR12_BORDER_W:=0;
    BUTTON_NR12_BORDER_L:=0;
    BUTTON_NR12_INVERT:=FALSE;
    GROUP:=0;
    BUTTON_TEXT_NR_12 := '';    
  END_IF
  BUTTON_NR12_GROUP := GROUP;
    
  //GROUP BUTTON 13
  IF BUTTON_ACTIVE_NR_13 THEN
    BUTTON_NR13_STATE:=0;
    BUTTON_NR13_BORDER_W:=1;
    BUTTON_NR13_BORDER_L:=20;
    BUTTON_NR13_INVERT:=TRUE;
    GROUP:=0;
    IF (GROUP >= 0) AND GROUP <> BUTTON_NR13_GROUP THEN
      BUTTON_TEXT_NR_13 := 'FAIL BY GROUP 0';
    END_IF                                        
  ELSE
    BUTTON_NR13_STATE:=2;   
    BUTTON_NR13_FLASH := FALSE;
    BUTTON_NR13_BORDER_W:=0;
    BUTTON_NR13_BORDER_L:=0;
    BUTTON_NR13_INVERT:=FALSE;
    GROUP:=1024;
    BUTTON_TEXT_NR_13 := '';    
  END_IF
  BUTTON_NR13_GROUP := GROUP;
   

END_PROGRAM

PROGRAM STARTUP
 VAR_EXTERNAL (*$AUTO*) END_VAR
 
 VAR

 END_VAR


  IF STARTUP_MAIN THEN
   STARTUP_MAIN:=FALSE; 
   TIME_REDRAW_STATE:=0;
   DATE_REDRAW_STATE:=0; 
   BUTTON_TEXT_NR_1:='A'; 
   BUTTON_TEXT_NR_2:='B';
   BUTTON_TEXT_NR_3:='C';
   BUTTON_TEXT_NR_4:='D';
   BUTTON_TEXT_NR_5:='E';
   BUTTON_TEXT_NR_6:='F';
   BUTTON_TEXT_NR_7:='G';
   BUTTON_TEXT_NR_8:='H';
   BUTTON_TEXT_NR_9:='I';
   BUTTON_TEXT_NR_10:='J';
   BUTTON_TEXT_NR_11:='K';
   BUTTON_TEXT_NR_12:='L';
   BUTTON_TEXT_NR_13:='M';    
   DATE_TEXT:='01-01-2000';
   TIME_TEXT:='12:00:00';     
   GEAON:=2;
   DEADMANON:=2;          
   BUTTON_NR1_STATE:=0;
   BUTTON_NR2_STATE:=0;  
   BUTTON_NR3_STATE:=0;
   BUTTON_NR4_STATE:=0;  
   BUTTON_NR5_STATE:=0;
   BUTTON_NR6_STATE:=0;  
   BUTTON_NR7_STATE:=0;
   BUTTON_NR8_STATE:=0;  
   BUTTON_NR9_STATE:=0;
   BUTTON_NR10_STATE:=0;  
   BUTTON_NR11_STATE:=0;
   BUTTON_NR12_STATE:=0;
   BUTTON_NR13_STATE:=0; 
   
   BUTTON_NR1_BORDER_W:=1;
   BUTTON_NR2_BORDER_W:=1;  
   BUTTON_NR3_BORDER_W:=1;
   BUTTON_NR4_BORDER_W:=1;  
   BUTTON_NR5_BORDER_W:=1;
   BUTTON_NR6_BORDER_W:=1;  
   BUTTON_NR7_BORDER_W:=1;
   BUTTON_NR8_BORDER_W:=1;  
   BUTTON_NR9_BORDER_W:=1;
   BUTTON_NR10_BORDER_W:=1;  
   BUTTON_NR11_BORDER_W:=1;
   BUTTON_NR12_BORDER_W:=1;
   BUTTON_NR13_BORDER_W:=1;  
   
   BUTTON_NR1_BORDER_L:=20;
   BUTTON_NR2_BORDER_L:=20;  
   BUTTON_NR3_BORDER_L:=20;
   BUTTON_NR4_BORDER_L:=20;  
   BUTTON_NR5_BORDER_L:=20;
   BUTTON_NR6_BORDER_L:=20;  
   BUTTON_NR7_BORDER_L:=20;
   BUTTON_NR8_BORDER_L:=20;  
   BUTTON_NR9_BORDER_L:=20;
   BUTTON_NR10_BORDER_L:=20;  
   BUTTON_NR11_BORDER_L:=20;
   BUTTON_NR12_BORDER_L:=20;
   BUTTON_NR13_BORDER_L:=20;  
   
   BUTTON_NR1_GROUP:=0;
   BUTTON_NR2_GROUP:=0;
   BUTTON_NR3_GROUP:=0;
   BUTTON_NR4_GROUP:=0;
   BUTTON_NR5_GROUP:=0;
   BUTTON_NR6_GROUP:=0;
   BUTTON_NR7_GROUP:=0;
   BUTTON_NR8_GROUP:=0;
   BUTTON_NR9_GROUP:=0;
   BUTTON_NR10_GROUP:=0;
   BUTTON_NR11_GROUP:=0;
   BUTTON_NR12_GROUP:=0;
   BUTTON_NR13_GROUP:=1024;    
   
   EAS_BMP_1_STATE:=0;
   EAS_BMP_2_STATE:=0;
   EAS_BMP_3_STATE:=0;   
   RESET_PANEL:=TRUE;       
      
   STATE_ARROW_LEFT:=0;
   STATE_ARROW_RIGHT:=0;
   STATE_BUTTON_LEFT:=0;
   STATE_BUTTON_RIGHT:=0;  
   STATE_SELECT_ENGINEER:=0;    
   CUR_ENGONDUTY:=0;    
   
   BOT_BUTTON_1:=FALSE;
   BOT_BUTTON_2:=FALSE;
   BOT_BUTTON_3:=FALSE;
   BOT_BUTTON_4:=FALSE;
   BOT_BUTTON_5:=FALSE;
   BOT_BUTTON_6:=FALSE;
      
   TBUTTON_NR_1:=FALSE;
   TBUTTON_NR_2:=FALSE;
   TBUTTON_NR_3:=FALSE;
   TBUTTON_NR_4:=FALSE;
   TBUTTON_NR_5:=FALSE;
   TBUTTON_NR_6:=FALSE;
   TBUTTON_NR_7:=FALSE;
   TBUTTON_NR_8:=FALSE;
   TBUTTON_NR_9:=FALSE;
   TBUTTON_NR_10:=FALSE;
   TBUTTON_NR_11:=FALSE;
   TBUTTON_NR_12:=FALSE;
   TBUTTON_NR_13:=FALSE;
   
   BUTTON_ARROW_LEFT:=FALSE;
   BUTTON_ARROW_RIGHT:=FALSE;  
   
   SET_GROUP_ACTIVE := FALSE;    
   GROUP_BUTTON_START_CNT:=0;
   GROUP_BUTTON_CNT_MAX:=0; 
    
   TBUTTON_SCROLL_UP:=FALSE;
   TBUTTON_SCROLL_DOWN:=FALSE;
   TBUTTON_ACK:=FALSE;
   TBUTTON_STOP_HORN:=FALSE;  
   
   HORN_RELAIS_OUTPUT:=FALSE;
   LOCAL_BUZZER:=FALSE;
   STOP_HORN_INPUT:=FALSE;            
   ENG_TEXT_FRAME:=1; 
   ALLOW_LOCAL_HORN_RESET:=TRUE;  
   HANDLE_GROUPS_ACT:=0;
   SET_HORN_FROM_GROUP_ALARM := FALSE;
   SET_HORN_FROM_GROUP_ALARM_TWO:=FALSE;
   CURRENT_GROUP_CNT:=0;       
   BUTTON_STATE_ACK:=0;
   DIMMING_STEP:=10;    
   BUTTON_STATE_STOPHORN:=0;      
   CFG_TURN_HORN_ON:=0;
   CFG_ACCEPT:=0;
   CFG_RESET_HORN_1:=0;
   CFG_RESET_HORN_2:=0;          
   CUR_ENG_CALL:=0;
   ENG_CALL_TEXT_FRAME:=0;
   USE_GROUP_ZERO_INDEX:=FALSE;
   FLASH_UNATTENDED:=FALSE;    
   
   USE_GROUP_ZERO:=FALSE;
   ENGONSTANDBY:=0;
   STANDBYON:=0;
   CFG_ACCEPT_UNATT:=FALSE;                                   
 END_IF



END_PROGRAM

PROGRAM GROUP_SELECTION
 VAR_EXTERNAL (*$AUTO*) END_VAR
 
 VAR

 END_VAR
 
 
 TBUTTON_NR:=FALSE;
 IGROUPNR:=0;
  
 //GROUP PAGE SELECTION OF GROUP DESC BUTTONS PAGE 0
 IF TBUTTON_NR_1 AND BUTTON_ACTIVE_NR_1 THEN
   IGROUPNR:=BUTTON_NR1_GROUP;
   TBUTTON_NR:=TRUE; 
 END_IF
 
 IF TBUTTON_NR_2 AND BUTTON_ACTIVE_NR_2 THEN
   IGROUPNR:=BUTTON_NR2_GROUP;
   TBUTTON_NR:=TRUE; 
 END_IF

 IF TBUTTON_NR_3 AND BUTTON_ACTIVE_NR_3 THEN
   IGROUPNR:=BUTTON_NR3_GROUP;
   TBUTTON_NR:=TRUE; 
 END_IF

 IF TBUTTON_NR_4 AND BUTTON_ACTIVE_NR_4 THEN
   IGROUPNR:=BUTTON_NR4_GROUP;
   TBUTTON_NR:=TRUE; 
 END_IF

 IF TBUTTON_NR_5 AND BUTTON_ACTIVE_NR_5 THEN
   IGROUPNR:=BUTTON_NR5_GROUP;
   TBUTTON_NR:=TRUE; 
 END_IF

 IF TBUTTON_NR_6 AND BUTTON_ACTIVE_NR_6 THEN
   IGROUPNR:=BUTTON_NR6_GROUP;
   TBUTTON_NR:=TRUE; 
 END_IF

 IF TBUTTON_NR_7 AND BUTTON_ACTIVE_NR_7 THEN
   IGROUPNR:=BUTTON_NR7_GROUP;
   TBUTTON_NR:=TRUE; 
 END_IF

 IF TBUTTON_NR_8 AND BUTTON_ACTIVE_NR_8 THEN
   IGROUPNR:=BUTTON_NR8_GROUP;
   TBUTTON_NR:=TRUE; 
 END_IF

 IF TBUTTON_NR_9 AND BUTTON_ACTIVE_NR_9 THEN
   IGROUPNR:=BUTTON_NR9_GROUP;
   TBUTTON_NR:=TRUE; 
 END_IF

 IF TBUTTON_NR_10 AND BUTTON_ACTIVE_NR_10 THEN
   IGROUPNR:=BUTTON_NR10_GROUP;
   TBUTTON_NR:=TRUE; 
 END_IF

 IF TBUTTON_NR_11 AND BUTTON_ACTIVE_NR_11 THEN
   IGROUPNR:=BUTTON_NR11_GROUP;
   TBUTTON_NR:=TRUE; 
 END_IF

 IF TBUTTON_NR_12 AND BUTTON_ACTIVE_NR_12 THEN
   IGROUPNR:=BUTTON_NR12_GROUP;
   TBUTTON_NR:=TRUE; 
 END_IF

 IF TBUTTON_NR_13 AND BUTTON_ACTIVE_NR_13 AND BUTTON_NR13_GROUP <> 1024 THEN
   IGROUPNR:=BUTTON_NR13_GROUP;
   TBUTTON_NR:=TRUE; 
 END_IF

END_PROGRAM

PROGRAM HANDLE_GEA
 VAR_EXTERNAL (*$AUTO*) END_VAR
 
 VAR

 //GEA_CFG_GET: HW_READ_EAS_CFG_ITEM;
 
 CUR_GEA  : BOOL;
  
 GEA_ACTIVE : BYTE;
 GEA_MODE : BYTE;
 GEA_HORN_MODE : BYTE;
 GEA_HORN_TYPE : BYTE;
 GEA_HORN_RESET : BYTE;
 
 TURN_ON_HORN: BOOL;
 GEAON_STORE:BYTE;
 
 END_VAR
 
  IF CUR_GEA THEN
    IF GEAON=BYTE#1 AND GEAON_STORE=BYTE#3 THEN //retrigger on gea, gea is flashing again
      CUR_GEA:=FALSE;
    END_IF       
  END_IF
  
  //HORN WITH GEA    
  IF GEAON <> BYTE#2 THEN    
    IF CUR_GEA = FALSE THEN      
      CUR_GEA := TRUE;
      TURN_ON_HORN:=FALSE;      
            
      GEA_ACTIVE:=1;
      GEA_MODE:=1;
      GEA_HORN_MODE:=HORN_MODE;
      GEA_HORN_TYPE:=HORN_STATUS;
      GEA_HORN_RESET:=HORN_RESET;
      
      CASE BYTE_TO_INT(GEA_HORN_MODE) OF
        0: TURN_ON_HORN:=FALSE; //NONE
        1: IF ATTENDED THEN TURN_ON_HORN:=TRUE; END_IF  //ATT      
        2: IF UNATTENDED THEN TURN_ON_HORN:=TRUE; END_IF  //UNATT
        3: TURN_ON_HORN:=TRUE; //BOTH
        4: IF (EAS_BMP_3_STATE = 1) OR (STANDBYON=BYTE#3) THEN TURN_ON_HORN:=TRUE; END_IF //ON_DUTY
      END_CASE
      
           //GET CONFIG SETTINGS - GEA
      
      //GEA_CFG_GET(FUNC:=BYTE#2,FUNCDATA:=BYTE#0);      
      //GEA_ACTIVE:=GEA_CFG_GET.ACTIVE;
      //GEA_MODE := GEA_CFG_GET.MODE;
      //GEA_HORN_MODE := GEA_CFG_GET.HORNMODE;
      //GEA_HORN_TYPE := GEA_CFG_GET.HORNTYPE;
      //GEA_HORN_RESET := GEA_CFG_GET.HORNRESET;
            
      //GET CONFIG SETTINGS GEA OR DEADMAN      
      //IF (GEA_ACTIVE = BYTE#0) THEN
        //GEA_CFG_GET(FUNC:=BYTE#4,FUNCDATA:=BYTE#0);      
        //GEA_ACTIVE:=GEA_CFG_GET.ACTIVE;
        //GEA_MODE := GEA_CFG_GET.MODE;
        //GEA_HORN_MODE := GEA_CFG_GET.HORNMODE;
        //GEA_HORN_TYPE := GEA_CFG_GET.HORNTYPE;
        //GEA_HORN_RESET := GEA_CFG_GET.HORNRESET;              
      //END_IF
      
      //GEA CONFIGURED      
      IF (GEA_ACTIVE <> BYTE#0) THEN
              
        IF TURN_ON_HORN THEN
                        
          LOCAL_BUZZER:=TRUE;
          LOCAL_HORN_RESET:=FALSE;      
            
          IF GEA_HORN_TYPE = BYTE#2 THEN
            HORN_PULSE:=TRUE;
          ELSE
            HORN_PULSE:=FALSE;
          END_IF
                        
          IF EXT_HORN_ACTIVE = BYTE#1 THEN
            HORN_RELAIS_OUTPUT:=TRUE;  
          END_IF
          
          IF GEA_HORN_RESET = BYTE#0 THEN
            ALLOW_LOCAL_HORN_RESET:=FALSE;
          ELSE
            ALLOW_LOCAL_HORN_RESET:=TRUE;
          END_IF
                    
        END_IF
       
     END_IF //GEA CONFIGURED
                              
    END_IF //CUR GEA IS SET
  ELSE  
    CUR_GEA:=FALSE;    
  END_IF
 
  //STORE PREVIOUS ONE 
  GEAON_STORE:=GEAON; 

END_PROGRAM

PROGRAM HANDLE_DEADMAN
 VAR_EXTERNAL (*$AUTO*) END_VAR
 
 VAR
  
 CUR_DEADMAN  : BOOL;
  
 DM_ACTIVE : BYTE;
 DM_MODE : BYTE;
 DM_HORN_MODE : BYTE;
 DM_HORN_TYPE : BYTE;
 DM_HORN_RESET : BYTE;
 TURN_ON_HORN : BOOL;
  
 DEADMANON_STORE:BYTE;
 
 END_VAR
 
  IF CUR_DEADMAN THEN
    IF DEADMANON=BYTE#1 AND DEADMANON_STORE=BYTE#3 THEN //retrigger on deadman, deadman is flashing again, value 3 not reset
      CUR_DEADMAN:=FALSE;
    END_IF       
  END_IF
  
  
  //HORN WITH DEADMAN
  IF DEADMANON <> BYTE#2 THEN
  
    IF CUR_DEADMAN = FALSE THEN      
      CUR_DEADMAN := TRUE;  
      TURN_ON_HORN:= FALSE;    
      
      DM_ACTIVE:=1;
      DM_MODE := 1;
      DM_HORN_MODE := HORN_MODE;
      DM_HORN_TYPE := HORN_STATUS;
      DM_HORN_RESET := HORN_RESET;
      
      CASE BYTE_TO_INT(DM_HORN_MODE) OF
        0: TURN_ON_HORN:=FALSE; //NONE
        1: IF ATTENDED THEN TURN_ON_HORN:=TRUE; END_IF  //ATT      
        2: IF UNATTENDED THEN TURN_ON_HORN:=TRUE; END_IF  //UNATT
        3: TURN_ON_HORN:=TRUE; //BOTH
        4: IF (EAS_BMP_3_STATE = 1) OR (STANDBYON=BYTE#3) THEN TURN_ON_HORN:=TRUE; END_IF //ON_DUTY
      END_CASE
      
      
     //DEADMAN CONFIGURED      
     IF (DM_ACTIVE <> BYTE#0) THEN
          
       IF TURN_ON_HORN THEN
                       
         LOCAL_BUZZER:=TRUE;
         LOCAL_HORN_RESET:=FALSE;      
        
         IF DM_HORN_TYPE = BYTE#2 THEN
           HORN_PULSE:=TRUE;
         ELSE
           HORN_PULSE:=FALSE;
         END_IF
                    
         IF EXT_HORN_ACTIVE = BYTE#1 THEN
           HORN_RELAIS_OUTPUT:=TRUE;  
         END_IF
         
         IF DM_HORN_RESET = BYTE#0 THEN
           ALLOW_LOCAL_HORN_RESET:=FALSE;
         ELSE
           ALLOW_LOCAL_HORN_RESET:=TRUE;
         END_IF
                  
       END_IF
       
     END_IF //DM CONFIGURED
                              
    END_IF //CUR DM IS SET
  ELSE  
    CUR_DEADMAN:=FALSE;    
  END_IF
 
  DEADMANON_STORE:= DEADMANON;

END_PROGRAM

PROGRAM GET_GROUP_CFG
 VAR_EXTERNAL (*$AUTO*) END_VAR
 
 VAR
   STARTUP_GET_CFG: BOOL :=TRUE;
   
   //READ_GROUP: HW_READ_GROUPS_EAS_CFG;
   //N: INT;
   //IRET: INT;
   
 END_VAR
 
   IF STARTUP_GET_CFG THEN
     STARTUP_GET_CFG:=FALSE; 
     //CFG_GROUP_INDEX_MAX:=0;
          
//   CFG_GROUP_NR:         ARRAY[0..31] OF BYTE; 
//   CFG_GROUP_MODE:       ARRAY[0..31] OF BYTE;
//   CFG_GROUP_HORN_MODE:  ARRAY[0..31] OF BYTE;    
//   CFG_GROUP_HORN_TYPE:  ARRAY[0..31] OF BYTE;
//   CFG_GROUP_HORN_RESET: ARRAY[0..31] OF BYTE;
//   CFG_GROUP_INDEX_MAX:  INT;      
          
     //FOR N:=0 TO 31 DO
 
       //READ_GROUP(INDEX:=N);
       //IRET := READ_GROUP.GROUPNR;  
           
       //IF IRET >= 0 THEN    
       //  CFG_GROUP_NR[N]:=INT_TO_BYTE(IRET);
       //  CFG_GROUP_INDEX_MAX:=CFG_GROUP_INDEX_MAX+1;
       //END_IF

     //END_FOR
        
   END_IF
 
END_PROGRAM

PROGRAM HANDLE_GROUPS
 VAR_EXTERNAL (*$AUTO*) END_VAR
 
 VAR
 INDEX: INT;
 INDEX_START: INT;
 ALLOW_HORN_RESET: BOOL;
 HORN_MODE_LOCAL: BYTE;
 HORN_TYPE_PULSE: BOOL;
 VALUE : BYTE; 
 LOCAL_BUZZER_CFG: BOOL; 
 END_VAR
 
  
IF HANDLE_GROUPS_ACT = 1 THEN
  HANDLE_GROUPS_ACT:=2;
  
  INDEX_START:=1;
  IF USE_GROUP_ZERO_INDEX THEN
    INDEX_START:=0;
    USE_GROUP_ZERO_INDEX:=FALSE;     
  END_IF
  
  FOR INDEX:=INDEX_START TO 64 DO

    ALLOW_HORN_RESET:=FALSE;
    HORN_MODE_LOCAL:=0;
    HORN_TYPE_PULSE:=FALSE;
    LOCAL_BUZZER_CFG:=FALSE; 
        
    //flashing state of buttons        
    IF (NR_OF_NOTACK_ALARMS[INDEX]<>BYTE#0) THEN
    
      VALUE:=GROUP_HORN_CFG[INDEX];                
      
      IF VALUE >= BYTE#128 THEN
        ALLOW_HORN_RESET := TRUE;
        VALUE:=VALUE - BYTE#128;
      END_IF
      
      IF VALUE >= BYTE#64 THEN
        HORN_TYPE_PULSE := TRUE;
        VALUE:=VALUE - BYTE#64;
      END_IF   
                        
      HORN_MODE_LOCAL:=VALUE;
                              
      CASE BYTE_TO_INT(HORN_MODE_LOCAL) OF
        0: LOCAL_BUZZER_CFG:=FALSE; //NONE
        1: IF ATTENDED THEN LOCAL_BUZZER_CFG:=TRUE; END_IF  //ATT      
        2: IF UNATTENDED THEN LOCAL_BUZZER_CFG:=TRUE; END_IF  //UNATT
        3: LOCAL_BUZZER_CFG:=TRUE; //BOTH
        4: IF (EAS_BMP_3_STATE = 1) OR (STANDBYON=BYTE#3) THEN LOCAL_BUZZER_CFG:=TRUE; END_IF //ON_DUTY
      END_CASE
      
      IF TYPE_PANEL = BYTE#34 AND CFG_TURN_HORN_ON >= BYTE#1 THEN //IF ALARM PANEL AND CFG TURN HORN ON
        LOCAL_BUZZER_CFG:=TRUE;  //BOTH
        ALLOW_HORN_RESET := TRUE;  //LOCAL RESET
      END_IF
                            
      IF LOCAL_BUZZER_CFG THEN
           
        LOCAL_BUZZER :=TRUE;      
        SET_HORN_FROM_GROUP_ALARM:=TRUE;           
        SET_HORN_FROM_GROUP_ALARM_TWO:=TRUE;          
        LOCAL_HORN_RESET:=FALSE;        
        
        IF ALLOW_HORN_RESET THEN
          ALLOW_LOCAL_HORN_RESET:=TRUE;
        ELSE
          ALLOW_LOCAL_HORN_RESET:=FALSE;      
        END_IF               
                                          
        IF EXT_HORN_ACTIVE = BYTE#1 THEN
          HORN_RELAIS_OUTPUT:=TRUE;  
        END_IF   
        
        IF HORN_TYPE_PULSE THEN
          HORN_PULSE:=TRUE;
        ELSE
          HORN_PULSE:=FALSE;
        END_IF                  
                       
      END_IF
      
    END_IF
                     
  END_FOR
  
END_IF

  //NOW THE HORN IS SET BY IOSERVER TOO, GROUP ALARM
  IF SET_HORN_FROM_GROUP_ALARM AND HORN_STATUS > BYTE#0 THEN

    LOCAL_BUZZER:=TRUE;     
    IF EXT_HORN_ACTIVE = BYTE#1 THEN
      HORN_RELAIS_OUTPUT:=TRUE;  
    END_IF
     
    SET_HORN_FROM_GROUP_ALARM:=FALSE;
    
  END_IF

END_PROGRAM

PROGRAM DIMMING
 VAR_EXTERNAL (*$AUTO*) END_VAR
 
 VAR
    DIM_DN   : R_TRIG ;
    DIM_UP   : R_TRIG ;
    DIM_DN_CONTINUOUS   : TON ;
    DIM_UP_CONTINUOUS   : TON ;
    
    DIM_OPERATED : BOOL ;
    
    DIM_MIN_VALUE : FINT := 0;
    DIM_MAX_VALUE : FINT := 100;
    
    DIMMING : FINT := 100;
    DIMMING_RECEIVED : BYTE :=0;
 END_VAR


IF DISPLAY_NUMBER = 0  THEN

    /// TRIGGER BUTTONS
    DIM_DN(CLK := (BOT_BUTTON_5 OR BUTTON_5)) ;
    DIM_DN_CONTINUOUS(IN:=BOT_BUTTON_5 OR BUTTON_5,PT:=T#500);

    IF DIMMING <= 10 THEN
      DIMMING_STEP := 1;
    ELSE
      DIMMING_STEP := 10;
    END_IF    

    IF DIM_DN.Q OR DIM_DN_CONTINUOUS.Q THEN
        DIMMING := DIMMING - DIMMING_STEP ;
    END_IF
    
    DIM_UP(CLK := (BOT_BUTTON_6 OR BUTTON_6)) ;
    DIM_UP_CONTINUOUS(IN:=BOT_BUTTON_6 OR BUTTON_6,PT:=T#500);

    IF DIM_UP.Q OR DIM_UP_CONTINUOUS.Q THEN
        DIMMING := DIMMING + DIMMING_STEP ;
    END_IF
    
    /// LIMIT DIMMING MIN / MAX
    IF DIMMING <= DIM_MIN_VALUE THEN
        DIMMING := DIM_MIN_VALUE ;
    END_IF
    
    IF DIMMING >= DIM_MAX_VALUE THEN
        DIMMING := DIM_MAX_VALUE ;
    END_IF

END_IF

//Value received from ioserver
IF DIMMING_RECEIVED <> DIMMING_IOS THEN
    DIMMING_RECEIVED:=DIMMING_IOS;
    DIMMING := INT_TO_FINT( BYTE_TO_INT(DIMMING_IOS) );
    DIMMING := FINT#100 - DIMMING;         
END_IF

//WHEN ON DUTY AND QUITE DARK DIMMING, RESET DIMMING 
IF DIMMING < FINT#40 THEN 
  IF ((EAS_BMP_3_STATE = 1) OR (STANDBYON=BYTE#3)) AND LOCAL_BUZZER = TRUE THEN  
    IF SET_HORN_FROM_GROUP_ALARM OR SET_HORN_FROM_GROUP_ALARM_TWO OR (GEAON <> BYTE#2) OR (DEADMANON <> BYTE#2) THEN  
      DIMMING:=FINT#10;
    END_IF
  END_IF   
END_IF


TFT_DIM := FINT#100 - DIMMING;

END_PROGRAM

PROGRAM EDIT_SELECTION
 VAR_EXTERNAL (*$AUTO*) END_VAR
 
 VAR

   SHOWN     : BOOL;
   TBMODE    : INT;
   MODE      : INT;
   IVALUE    : INT := 0;
   GROUP_SEL_NR : INT := 0;  //GROUP LIST ON TFT 
   TBTRIGGER : R_TRIG;
   TRIGGER   : R_TRIG;
   BUT_ID    : HW_BUTTON_ID;
   SET_GROUP : HW_SET_TFT_GROUP_NR_PAGE;
   GET_SEL_LIST : HW_GET_EAS_RESET_SIGNAL;

 END_VAR
 
  TBMODE := -1;  
  MODE := -1;
  
  IF DISPLAY_NUMBER=3 THEN
    SHOWN:=TRUE;
  ELSE
    SHOWN:=FALSE;       
  END_IF 
    
  IF SHOWN THEN  
    IF TB_0 THEN
      TBMODE := 0;
    ELSIF TB_1 THEN
      TBMODE := 1;
    ELSIF TB_2 THEN
      TBMODE := 2;
    ELSIF TB_3 THEN
      TBMODE := 3;
    ELSIF TB_4 THEN
      TBMODE := 4;
    ELSIF TB_5 THEN
      TBMODE := 5;
    ELSIF TB_6 THEN
      TBMODE := 6;
    ELSIF TB_7 THEN
      TBMODE := 7;
    ELSIF TB_8 THEN
      TBMODE := 8;
    ELSIF TB_9 THEN
      TBMODE := 9;
    //ELSIF TB_DOT THEN
      //TBMODE := 11;
    ELSIF TB_DEL THEN
      TBMODE := 12;
    //ELSIF TB_MIN THEN
      //TBMODE := 10;
    END_IF   
        
    TBTRIGGER(CLK:= (TBMODE > -1));
    IF TBTRIGGER.Q THEN
      
      IF TBMODE >= 0 AND TBMODE <= 9 THEN
        IVALUE := IVALUE * 10;
        IVALUE := IVALUE + TBMODE;
      END_IF
      
      IF TBMODE = 12 AND IVALUE >= 10 THEN
        IVALUE := IVALUE / 10;                                 
      ELSIF TBMODE = 12 AND IVALUE >= 1 THEN
        IVALUE := 0;
      END_IF
      
      IF IVALUE >= 0 AND IVALUE <= 255 THEN                           
        TB_EDIT_VALUE :=INT_TO_FINT(IVALUE);
      ELSE
        IVALUE :=FINT_TO_INT(TB_EDIT_VALUE);
      END_IF
          
    END_IF
        
    IF TBUTTON_ACK THEN
      MODE := 1;
    ELSIF TBUTTON_STOP_HORN THEN
      MODE := 2;   
    ELSIF TBUTTON_SCROLL_DOWN THEN
      MODE := 3;     
    ELSIF TBUTTON_SCROLL_UP THEN
      MODE := 4;     
    ELSIF BUTTON_5 THEN
      MODE := 5;     
    ELSIF BUTTON_6 THEN
      MODE := 6;     
    END_IF  
 
    TRIGGER(CLK:= (MODE > 0));
    IF TRIGGER.Q THEN
      BUT_ID(IINPUT:=MODE);      
      IF MODE = 5 THEN
        IF IVALUE <= 0 THEN  //INVALID NUMBER, CHECK SCROLL
          GET_SEL_LIST(IINPUT:=2);
          GROUP_SEL_NR := GET_SEL_LIST.IRET;
        END_IF      
        IF IVALUE > 0 THEN
          SET_GROUP(IINPUT:=IVALUE);
          DISPLAY_NUMBER:=4;
          SET_GROUP_ACTIVE:=TRUE;
        ELSIF GROUP_SEL_NR > 0 THEN
          SET_GROUP(IINPUT:=GROUP_SEL_NR);
          DISPLAY_NUMBER:=4;
          SET_GROUP_ACTIVE:=TRUE;
        END_IF                
      END_IF      
    END_IF     
  END_IF
  
END_PROGRAM

PROGRAM GROUP_PAGE
 VAR_EXTERNAL (*$AUTO*) END_VAR
 

 VAR

   SHOWN     : BOOL;
   MODE      : INT;
   TRIGGER   : R_TRIG;
   BUT_ID    : HW_BUTTON_ID;

 END_VAR
 

  MODE := -1;
  
  IF DISPLAY_NUMBER=4 THEN
    SHOWN:=TRUE;
  ELSE
    SHOWN:=FALSE;       
  END_IF 
    
  IF SHOWN THEN  

        
    IF TBUTTON_ACK THEN
      MODE := 1;
    ELSIF TBUTTON_STOP_HORN THEN
      MODE := 2;   
    ELSIF TBUTTON_SCROLL_DOWN THEN
      MODE := 3;     
    ELSIF TBUTTON_SCROLL_UP THEN
      MODE := 4;     
    ELSIF BUTTON_5 THEN
      MODE := 5;     
    ELSIF BUTTON_6 THEN
      MODE := 6;     
    END_IF  
 
    TRIGGER(CLK:= (MODE > 0));
    IF TRIGGER.Q THEN
      BUT_ID(IINPUT:=MODE);      
    END_IF     
           
  END_IF
  
END_PROGRAM

(*$TASKS 
.TASK TASK
.LOOPPARAM 0 100
GLOBALS
STARTUP
GROUP_SELECTION
MAIN
GROUP_BUTTONS
HANDLE_GEA
HANDLE_DEADMAN
GET_GROUP_CFG
HANDLE_GROUPS
DIMMING
EDIT_SELECTION
GROUP_PAGE
.END_TASK
*)
(*$END_LIBRARY*)
